/* -*- crc -*-
 * 
 * Purpose:
 *    Definitions of variables to use with the rules about freedays,
 *    free weekend, check in times, VA- LA-scheduling, FG-cycles.
 *    Definition of time off variables.
 *
 * Sections:
 *     1: Fundamental definitions.
 *     2: Freedays in one calendar month.
 *     3: Freedays in two or more calendar months.
 *     4: Freedays in an interval.
 *     5: Qualifying days in one, two and three months
 *     6: Qualifying days in an interval
 *     7: Computation of the required number of freedays specified by agreements.
 *     8: The required number of freedays after production.
 *     9: The correct pattern of VA- and LA-days
 *    10: Check in/out times around free weekend, vacation, freedays, etc.
 *    11: Freedays in any 7x24 period.
 *    12: Definitions regarding FG used in Tracking
 *    13: Free weekends
 *    14: FS days on weekends
 *    15: Freeday assign script vars - under construction 
 *
 * Created by:
 *    Peter Jonsson 24-Apr-2006
 *    Henrik Mouritsen Major rehaul July 2007 
 *
 * Agreement:
 *    OM-A chapter 7.
 *    CAU
 *    SCCA
 *    NKF, Feriebilag Nydalen
 *    FC 1, 9, 13, 
 *  
 * Notes:
 *    - this module utilizes %cabin_crew% %flight_crew% vars to differ instead
 *      of the more general _cc _fc module design principle
 *    - Potential sling parttime freedays for CC SKD LH (rule case 290 291)
 *    - script vars are wop dependant (because of variable reuse) this requires
 *      wop presence for scriot to work
 *    
 */

root module freedays

import base_utils;
import base_calendar;
import fundamental;
import system_db_parameters;
import parameters;
import levels;
import rules;
import trip;
import crew;
import wop;
import duty;
import leg;
import base_product;
import accumulators;
import calendar;
import month;
import roster;
import pp;
import bought_days;
import task;
import recency;
import training;
import compdays;
import crew_contract;
import model_crew;
import model_freedays;
import attributes;
import iterators;

/****************************************************************
 * Section 1: Fundamental definitions.
 ***************************************************************/

/*
 * These are the requirements to count a wop and the freedays after it 
 * when we compute the requirements of the number of freedays in a calendar 
 * month. The more qualifying number of wops, the more freedays required.
 * These requirements might differ between SKD, SKN and SKS. 
 * This variable decides whether a wop qualifies for freedays.
*/
%wop_is_qualifying% =
  wop.%is_on_duty% and
/* Freeday requirement during standby lines are handled in Tracking. */
  not wop.%is_standby_line% and
/* Vacation is not qualifying, not even if it is bought. */
  not (wop.%is_vacation% or
       %is_bought_vacation%) and
  (crew.%k4exng_cc_sp5_1_valid%(wop.%start_month_start%) or
 /* before 4ExNG. */
 /* Long course periods and certain ground duty periods are not qualifying. */
   (not (wop.%in_long_course_period% or
         %non_qualifying_ground_duty_period%) and
    not (%cabin_crew% and
 /* Long haul production is not qualifying for CC SKD */
         crew.%is_SKD% and
         wop.%is_long_haul%)));
  
%is_bought_vacation% = 
  any(duty(wop), task.%is_vacation%(bought_days.%duty_bought_type%));
  
export %possible_pt_freedays_1_month% =
  %possible_pt_freedays_in_period%(wop.%start_month_start%, wop.%start_month_end%);
  
export %possible_pt_freedays_2_months% =
  accumulators.%qual_pt_freedays_in_period%(%prev_month_start%, wop.%start_month_end%);

export %possible_pt_freedays_1_month_pp% =
  %possible_pt_freedays_in_period%(%pp_start%, %publ_period_end%);

/**************************************************************************
 * Section 2: Freedays in one calendar month.
 *  
 * This is month specific variables that count the number of qualifying 
 * freedays in a month where crew is in variable group. Further down is
 * more general variables that count qualifying freedays in a abritrary 
 * interval.
 **************************************************************************/

/* Function that counts the qualifying freedays in a month for VG.*/
export %nr_qualifying_in_1_month% =
  let start_t = wop.%start_month_start%,
      end_t = wop.%start_month_end%;
  %nr_qualifying_in_1_given_month%(start_t, end_t);

export %nr_qualifying_in_1_given_month%(AbsTime start_t, AbsTime end_t) =
      %qual_freedays_in_period%(crew.%variable_group_start%(start_t, end_t),
                            crew.%variable_group_end%(start_t, end_t));



/*
** Number of freedays in a month for FG
**
** FG F-days and other time-off days are assigned before any production, so
** this variable counts the assigned time-off days only. Empty days are where
** production will be assigned, and so are not considered as 'qualifying'.
*/

export %nr_qualifying_in_1_month_fg% =
  let start_t = crew.%fixed_group_start%(wop.%start_month_start%,
                                         wop.%start_month_end%),
      end_t = crew.%fixed_group_end%(wop.%start_month_start%,
                                     wop.%start_month_end%);

  sum(wop(roster),%nr_qualifying_in_1_month_fg_wop%(start_t,end_t))
    where (wop.%is_off_duty% and
           wop.%end_hb% > start_t and
           wop.%start_hb% < end_t);
    
%nr_qualifying_in_1_month_fg_wop% (Abstime start_t, Abstime end_t) =
  sum(trip(wop),overlap(start_t,end_t,trip.%start_hb%,trip.%end_hb%) / 24:00)
    where (trip.%is_off_duty% and
           trip.%end_hb% > start_t and
           trip.%start_hb% < end_t);

export %nr_qualifying_in_publ_period% =
  %qual_freedays_in_period%(%pp_start%, %publ_period_end%);

export %days_freedays_possible%(Abstime s, Abstime e) =
  duty.%days_with_selection_possible%(duty.%duty_sel_freeday%, s, e)
  + %fdc15_sbl_contribution%(s, e)
  - %single_day_gaps_not_freedays%(s, e)
  - %two_day_gaps_not_freedays%(s, e);

export %days_freedays_possible_pp% =
  %days_freedays_possible%(round_down_month(%pp_start%),round_up_month(%pp_start% + 0:01));
  /*duty.%days_with_selection_possible_calendar_month%(duty.%duty_sel_freeday%,%pp_start%);*/

export %days_freedays%(Abstime s, Abstime e) =
  duty.%days_with_selection%(duty.%duty_sel_freeday%, s, e);
  
export %days_freedays_pp% =
  duty.%days_with_selection_calendar_month%(duty.%duty_sel_freeday%, %pp_start%);
  
/****************************************************************************
 * Section 3: Freedays in two or more calendar months.
 * *************************************************************************/
export %nr_qualifying_in_2_months% =
  accumulators.%qual_freedays_in_period%(%prev_month_start%, wop.%start_month_end%);

export %prev_month_start% = round_down_month(wop.%start_month_start% - 0:01);

/***************************************************************************
 * Section 4: Freedays in an interval.
 *  
 * This is variables that count the number of qualifying freedays in a 
 * specified interval.
 *************************************************************************/

/* Calculate days in period and subtract non-qualifying days + freedays. */
export %qual_freedays_in_period%(Abstime start, Abstime stop) =
  (stop - start) / 24:00 -
  %nr_days_not_qualifying_freedays%(start, stop);
  
/* %qual_freedays_in_period_fulltime_fc_sh%
** 
** Only calculates qualifying freedays in an interval where crew
** is 100% SH flight-crew in variable group. 
*/  
export %qual_freedays_in_period_fulltime_fc_sh%(Abstime start, Abstime stop) =
  if %_crew_is_fulltime_vg%(start) then
    if %_crew_is_fulltime_vg%(stop) then
      %qual_freedays_in_period%(start, stop)
    else 
      %qual_freedays_in_period%(start, %_fulltime_vg_contract_end_in_period%(start, stop))    
  else
    if %_crew_is_fulltime_vg%(stop) then
      %qual_freedays_in_period%(%_fulltime_vg_contract_start_in_period%(start, stop),
                                stop)
    else
      0;

%_crew_is_fulltime_vg%(Abstime date) =
  (crew.%is_sks_at_date%(date) or crew.%is_skd_at_date%(date)) and 
  crew.%in_variable_group%(date) and
  crew.%is_full_time_at_date%(date);
    
%_fulltime_vg_contract_end_in_period%(Abstime start, Abstime stop) =
  let days = (stop - start) / 24:00;
  first(times(days), start + ((%times_index_0% - 1) * 24:00)) 
  where(not %_crew_is_fulltime_vg%(start + (%times_index_0% - 1) * 24:00));
  
%_fulltime_vg_contract_start_in_period%(Abstime start, Abstime stop) =
  first(times((stop-start)/24:00), start + (%times_index_0% - 1) * 24:00)
  where(%_crew_is_fulltime_vg%(start + (%times_index_0% -1) * 24:00));

/* Nr days not qualified freeday, i.e. working days plus freedays for 
 * non-qualifying working periods. */

/* Note: incorporate LH prod + ascc freedays as non_qual for CAU 80% N262 */ 
export %nr_days_not_qualifying_freedays%(Abstime start, Abstime stop) =
  sum(wop(roster), %wop_days_non_qual_freedays%(start, stop))
  where (not all(trip(wop), trip.%is_freeday% and not trip.%is_F0%) and /* SKCMS-2248: Special treatment of F0 since it is not in activity grp CMP anymore */
         not (wop.%is_bought% and 
              first(leg(wop),bought_days.%leg_bought_type% = "F7")) and
         wop.%start_hb% < stop and
         default(wop.%rest_end%, wop.%end_hb%) > start);

%wop_days_non_qual_freedays%(Abstime start, Abstime stop) =
  (if wop.%start_day% >= start and default(wop.%rest_end_day% <= stop, false) then
    %days_excluding_bought_days%
  else
    overlap(wop.%start_day%, wop.%end_day% + 24:00, start, stop) / 24:00 - 
    sum(duty(wop),overlap(duty.%start_day%, duty.%end_day% + 24:00, start, stop) / 24:00) 
    where ((duty.%is_bought% and 
            not first(leg(duty),bought_days.%leg_bought_type% = "F7") and
            not default((duty.%start_day% = next(duty(wop),duty.%end_day%)), false)) or
            (duty.%is_freeday% and not duty.%is_F0%))) /* SKCMS-2248: Special treatment of F0 since it is not in activity grp CMP anymore */
  - %wop_possible_single_freedays%(start, stop);

export %lh_non_qual_freedays_in_month_cc_skd%(AbsTime start, AbsTime stop) = 
  if crew.%is_skd% and %cabin_crew% then
    sum(wop(chain), %lh_wop_non_qual_freedays_in_period%(start, stop))
    where(wop.%is_long_haul%)
  else
    0;

%lh_wop_non_qual_freedays_in_period%(AbsTime start, AbsTime stop) =
  let days_after_wop = last(duty(wop), nmin(%min_required_freedays_after_duty_total%,
                                            %freedays_after_duty%));
  if wop.%is_long_haul% then
    overlap(start, stop, wop.%end_day% + 24:00, wop.%end_day% + (days_after_wop + 1) * 24:00) / 24:00
  else
    0;

export %days_excluding_bought_days% = 
  wop.%days% - sum(duty(wop), %nr_bought_days_in_duty%) where 
    (duty.%is_bought% and 
     not default((duty.%start_day% = next(duty(wop),duty.%end_day%)),false) and
     not first(leg(duty),bought_days.%leg_bought_type% = "F7") or
     (duty.%is_freeday% and not duty.%is_F0%)); /* SKCMS-2248: Special treatment of F0 since it is not in activity grp CMP anymore */

/* SKCMS-3241 added a way to count the days that is bought in case bought duty spans over midnight = 1 duty, but 2 bought days */
%nr_bought_days_in_duty% =
  count(times(duty.%days%))
  where(not void(bought_days.%type_on_day%(duty.%start_day% + (%times_index_0%-1)*24:00)));
  
/*
** Working days between freedays
*/
export %work_days_btw_freedays% =
  if %flight_crew% and
     crew.%in_5_4_flex_group_wop_start% then /* Crew in flex includes single f-days */
    wop.%days_incl_single_freedays%
  else
    %wop_max_work_with_single_f%(%pp_start%, add_months(%pp_start%, 1)) +
    sum(wop(roster), %wop_work_days%)
    from(prev) backwards while(wop.%is_on_duty% and wop.%consecutive_wops_fw% or
                               wop.%wop_is_isolated_fs_in_production_block%);

/* Redefined for CCT */
%wop_work_days% =
  wop.%days% - wop.%gnd_days% - 
  %nr_off_duty_cmp_first_in_wop% -
  %nr_off_duty_cmp_last_in_wop% -
  %wop_possible_single_freedays%(%pp_start%,add_months(%pp_start%, 1));


/* FC IC: Freedays after standby should be counted.
 * For the normal cases all freedays after non-qualifying wops should not
 * be included in the monthly freedays. */
%freedays_after_non_qual_wop_should_be_reduced% =
  %cabin_crew% and not (wop.%is_standby% and not wop.%in_pp%) or
  not crew.%is_long_haul_wop_start% or
  not wop.%is_standby%;

/***************************************************************************
 * Section 5: Qualifying days in one, two and three months.
 *  
 * Variable that counts the number of qualifying days in the month. The 
 * number of qual days determines the minimum number of freedays necerssary.
 * The qual days consist of qualifying wops and freedays after these wops.
 **************************************************************************/

export %qual_days_in_month% = 
  %qual_days_in_period%(wop.%start_month_start%, wop.%start_month_end%);

/***************************************************************************
 * Section 6: Qualifying days in an interval
 * 
 * Functions that determine the number of qualifying days in a specified
 * interval.
 ***************************************************************************/

/* Calculate days in period and subtract non-qualifying days. 
**
** NB! New GM agreement states that SKN FC crew has no requirement
** if qualifying days are less than 10
**
** K11: GM agreement no longer applies
*/
export %qual_days_in_period%(Abstime start, Abstime stop) =
  if %flight_crew% and 
     not parameters.%k11_fc_sp10_9_valid%(start) and
     crew.%is_skn% and
     %gm_agreement_valid%(start) then
    %qual_days_in_period_skn_fc%(start, stop)
  else
    %qual_days_in_period_not_skn_fc%(start, stop);
     
%_qual_days_in_period%(Abstime start, Abstime stop) =
  let days = (stop - start) / 24:00,
  divider =  100;
  if crew.%is_cabin% then
   /*  In stanbdy-line there exists freedays that will be created when the 
    ** stand-by line is changed to production. SAS wants the "density of 
    ** freedays within the sby line" to be the same for part time crew as 
    ** for full time crew. Therfore the non-qualfying days are divided into the    **  qdays for stanby-line and the rest of qual days. SKCMS-337
  */ 
    days 
    - (%nr_non_qualifying_sby_line%(start,stop)*crew.%part_time_factor% + divider/2)/divider 
    -   %nr_non_qualifying_other%(start,stop)
  else
    (stop - start) / 24:00 
    - %nr_non_qualifying_days%(start, stop);
  
%qual_days_in_period_skn_fc%(Abstime start, Abstime stop) =
  let qual_days = %_qual_days_in_period%(start, stop);
   if (qual_days < 10 and not %use_min_freedays_formula_skn_fc%(start)) and
     %flight_crew% and
     crew.%is_skn% and
     %gm_agreement_valid%(start) then
    0
  else 
    qual_days;

%qual_days_in_period_not_skn_fc%(Abstime start, Abstime stop) =
  if %cabin_crew% and crew.%is_skn% then 
    (stop - start) / 24:00 -
    accumulators.%nr_non_qualifying_days_in_period_cc_skn%(start, stop) - 
    %max_required_la_days_in_period%(start, stop)
  else
    %_qual_days_in_period%(start,stop);

export %pt_qual_days_in_period%(AbsTime start, AbsTime stop) =
  (stop - start) / 24:00 -
  (if %flight_crew% then
     %nr_non_pt_qualifying_days%(start, stop)
   else
     0);

export %nr_non_qualifying_days_in_period_fulltime_fc_vg%(Abstime start, Abstime stop) =
  if %_crew_is_fulltime_vg%(start) then
    if %_crew_is_fulltime_vg%(stop) then
      %nr_non_qualifying_days%(start, stop)
    else 
      %nr_non_qualifying_days%(start, %_fulltime_vg_contract_end_in_period%(start, stop))    
  else
    if %_crew_is_fulltime_vg%(stop) then
      %nr_non_qualifying_days%(%_fulltime_vg_contract_start_in_period%(start, stop),
                                stop)
    else
      0;

export %nr_non_qualifying_days_in_period_cc_skn_vg%(Abstime start, Abstime stop) =

   /*  In stanbdy-line there exists freedays that will be created when the 
    ** stand-by line is changed to production. SAS wants the "density of 
    ** freedays within the sby line" to be the same for part time crew as 
    ** for full time crew. Therfore the non-qualfying days are divided into the    **  qdays for stanby-line and the rest of qual days. SKCMS-337
  */ 

  let divider =  100;
   (%nr_non_qualifying_sby_line%(start,stop)*crew.%part_time_factor% + divider/2)/divider 
    +   %nr_non_qualifying_other%(start,stop);

/* Nr non-qualifying days, i.e. non-qual working periods standby-line excluded*/
%nr_non_qualifying_other%(Abstime start, Abstime stop) =
  sum(wop(roster), %wop_non_qual_days%(start, stop))
  where (not %wop_is_qualifying% and
         not wop.%is_freeday% and
         not wop.%is_standby_line% and
         wop.%start_hb% < stop and
         default(wop.%rest_end%, wop.%end_hb%) > start) + 
  /* Since illness does not break wop in all cases we have to add 
  ** the illness days inside wops. Same for off duty compensation days and F31 */
  sum(wop(roster), %illness_days_in_wop%(start, stop) +
                   %f31_days_in_period_in_wop%(start, stop) +
                   %off_duty_cmp_in_period_in_qualifying_wop%(start, stop)) 
  where (wop.%is_on_duty%) +
  sum(wop(roster), %nr_la_days_in_period_cc%(start, stop))
  where (wop.%is_freeday% and not %wop_is_qualifying%);

/* Nr non-qualifying days, that is standby_line */
%nr_non_qualifying_sby_line%(Abstime start, Abstime stop) =
  sum(wop(roster), %wop_non_qual_days%(start, stop))
  where (not %wop_is_qualifying% and
         not wop.%is_freeday% and
         wop.%is_standby_line% and
         wop.%start_hb% < stop and
         default(wop.%rest_end%, wop.%end_hb%) > start);

/* Nr non-qualifying days, i.e. non-qual working periods */
%nr_non_qualifying_days%(Abstime start, Abstime stop) =
  sum(wop(roster), %wop_non_qual_days%(start, stop))
  where (not %wop_is_qualifying% and
         not wop.%is_freeday% and
         wop.%start_hb% < stop and
         default(wop.%rest_end%, wop.%end_hb%) > start) + 
  /* Since illness does not break wop in all cases we have to add 
  ** the illness days inside wops. Same for off duty compensation days and F31 */
  sum(wop(roster), %illness_days_in_wop%(start, stop) +
                   %f31_days_in_period_in_wop%(start, stop) +
                   %off_duty_cmp_in_period_in_qualifying_wop%(start, stop)) 
  where (wop.%is_on_duty%) +
  sum(wop(roster), %nr_la_days_in_period_cc%(start, stop))
  where (wop.%is_freeday% and not %wop_is_qualifying%);
 


%nr_non_pt_qualifying_days%(AbsTime start, AbsTime stop) =
  sum(wop(roster), %illness_days_in_wop%(start, stop));

%max_required_la_days_in_period%(Abstime start, Abstime stop) =
  let days = (stop - start) / 24:00;
  if %flight_crew% and
     (parameters.%k11_fc_sp10_9_valid%(start) or
      not crew.%is_skn%) then
    if days > 0 then
        nmax((%required_pt_days_in_period%(start, stop)) / %days_in_month%(start),
             %scheduled_pt_days_in_period%(start, stop))
    else
        0
  else 
    0;
  
export %nmax_required_actual_pt_days_in_period%(Abstime start,
                                                Abstime stop) =
  let days = (stop - start) / 24:00;
  if days > 0 then
    nmax(%required_pt_days_in_period%(start, stop) / days,
         %scheduled_pt_days_in_period%(start, stop))
  else
    0;

%required_pt_days_in_period%(Abstime start, Abstime stop) =
  %target_pt_freedays_in_period_1_month%(start, stop);

export %scheduled_pt_days_in_period%(Abstime start, Abstime stop) =
  sum(trip(roster), trip.%days_in_period%(start, stop))
  where(trip.%is_group_valid_pt_freeday% and
        trip.%start_hb% >= start and trip.%start_hb% < stop );

%wop_non_qual_days%(Abstime start, Abstime stop) =
  if (wop.%is_f36% or wop.%is_f0%) then
    0
  else
  if wop.%start_day% >= start and default(wop.%rest_end_day% <= stop, false) then
    if %bought_va_days_in_wop% > 0 then
      %bought_va_days_in_wop%
    else
      wop.%days% + %_wop_non_qual_days%
  else 
    if %bought_va_days_in_wop% > 0 then
      bought_days.%bought_type_days_in_period%("VA", nmax(wop.%start_day%, start), 
                                               nmin(wop.%end_day% + 24:00, stop))
    else
      overlap(wop.%start_day%, default(wop.%end_day% + %_wop_non_qual_days% * 24:00, wop.%end_day%)
            + 24:00, start, stop) / 24:00;

%illness_days_in_wop%(Abstime start, Abstime stop) =
  sum(duty(wop), overlap(start, stop, duty.%start_hb%, duty.%end_hb%)/24:00)
  where(duty.%is_illness%);
  
%f31_days_in_period_in_wop%(Abstime start, Abstime stop) =
  sum(trip(wop), trip.%days_in_period%(start, stop))
  where(trip.%is_f31%);
  
%off_duty_cmp_in_period_in_qualifying_wop%(Abstime start, Abstime stop) =
  if %wop_is_qualifying% then
    sum(trip(wop), trip.%days_in_period%(start, stop))
    where(trip.%is_off_duty_cmp%)
  else 0;
  
%bought_va_days_in_wop% =
  bought_days.%bought_type_days_in_period%("VA", wop.%start_day%, wop.%end_day% + 24:00);
  
%_wop_non_qual_days% = 
  if  wop.%is_on_duty% and
      %freedays_after_non_qual_wop_should_be_reduced%
  then
    last(duty(wop), %min_required_freedays_after_duty_total%)
  else 0;

export %wop_ill_days%(Abstime start, Abstime stop) =
  sum(trip(wop), trip.%days_in_period%(start, stop))
  where(trip.%is_illness%);

export %required_f36_days_in_month% =
  default(crew.%monthly_f36_target%,0);

export %f36_target_in_month_p% = 
  parameter "target_for_f36_optimization"
  remark "ETAB: F36 target in month calculated in script";

export %table_f36_target_in_month% = %etab_path%(%f36_target_in_month_p%);

export %f36_days_in_period%(Abstime start, Abstime stop) =
  sum(wop(roster), wop.%days_in_period%(start, stop))
  where(wop.%is_f36%);

export %f36_days_in_month% =
  %f36_days_in_period%(wop.%start_month_start%, wop.%start_month_end%);

export %f36_days_in_pp_month% =
  %f36_days_in_period%(%pp_start%, round_up_month(%pp_start%+0:01));

/****************************************************************************
 * Section 7: Computation of the required number of freedays specified by 
 *            agreements.
 * 
 * This might be heavy. How many changes of relevant parameters (part-time,
 * fixed group, duty module) are possible to consider in one (two) month or an
 * interval. The current implementation handles one change each of part time
 * factor. If a crew has some FG, this is taken care of by
 * the %wop_is_qualifying% flag.
 ***************************************************************************/

/*  
** The required number of freedays according to the union agreements. The 
** variable depends on the number of qualifying days in the month and if
** there are any changes in part time factor. A maximum of one part time change
** in a month is assumed.
**
** This requirement variable accumulates ordinary freedays (F) and 
** parttime freedays (LA8/ F88). 
**
** For CC this requirement is the sum of F and F88. Both F and F88 are reduced
** in relation to qualifying days in month.
**
** For FC SH VG this requirement is the sum of F and LA8. LA8 however is NOT reduced
** in relation to qualifying days in month, but are nevertheless calculated as 
** part of the monthly freeday requirement. 
*/
/* 2008-08-29 Janne C WP CCR 495 */
export %min_required_in_interval%(Abstime start_date, Abstime end_date) =
  if crew.%part_time_change_in_period%(start_date, end_date) then
    %req_freedays_in_interval%(start_date, crew.%part_time_change_date_in_period%(start_date, end_date)) +
    %req_freedays_in_interval%(crew.%part_time_change_date_in_period%(start_date, end_date), end_date)
  else
    %req_freedays_in_interval%(start_date, end_date);

/* Only the sub interval of the month where the crew is on
** a variable group contract is counted.
*/
export %min_required_in_1_month% =
    /* wop dependant */
    let start_t = wop.%start_month_start%,
        end_t = wop.%start_month_end%;
    %min_required_in_1_given_month%(start_t, end_t);

export %min_required_in_1_given_month%(AbsTime start_t, Abstime end_t) = 
  nmax(default(%min_required_in_1_month_override%(wop.%start_hb%), 0),
             %min_required_in_1_month_by_month_startdate%(crew.%variable_group_start%(start_t, end_t),
                                                 crew.%variable_group_end%(start_t, end_t)));

/* Chain dependant, used for column generation */
export %chain_min_required_in_1_given_month%(AbsTime start_t, Abstime end_t) = 
  nmax(default(%min_required_in_1_month_override%(start_t), 0),
             %min_required_in_1_month_by_month_startdate%(crew.%variable_group_start%(start_t, end_t),
                                                 crew.%variable_group_end%(start_t, end_t)));

%min_required_in_1_month_override%(abstime date) = 
  if %use_freeday_requirement_override_p% then
    %_min_required_in_1_month_override%(date)
  else 
    0;


table min_required_1_month(abstime date) =
  crew.%id%, date ->  Int %_min_required_in_1_month_override%;
  external %etab_path%("freeday_requirement_override");
  id, (validfrom, validto( -> minfreedays;
  - , - -> 0;
end

%use_freeday_requirement_override_p% =
  parameter false
  remark "Use freeday requirement override";

export %min_required_in_1_month_wop_indep% =
   /* use planning period */   
    let start_t = round_down_month(%pp_start%),
        end_t = round_up_month(start_t + 0:01);
    %min_required_in_1_month_by_month_startdate%(start_t, end_t);
    
export %min_required_in_1_month_by_month_startdate%(Abstime start_t, Abstime end_t) = 
    let parttime_change_date = default(crew.%part_time_change_date_in_period%(start_t,end_t),1jan1986),
        days = (end_t-start_t)/24:00;
    if days = 0 then
        0
    else if parttime_change_date <> 1jan1986 then
      if crew.%change_fg_to_vg_at_date%(parttime_change_date) 
      then
            /* mandatory with two LA days when going from fixed to variable */
          ((10*(%target_days_in_period_1_month%(start_t, 
                                                nmax(parttime_change_date-2*24:00,start_t)) +  
              %target_days_in_period_1_month%(parttime_change_date, end_t)))/days+5)/10+2 /* the two extra days*/
      else
        ((10*(%target_days_in_period_1_month%(start_t, parttime_change_date) +  
              %target_days_in_period_1_month%(parttime_change_date, end_t)))/days+5)/10
    else
        %req_freedays_in_interval%(start_t, end_t);
        
 
/*
** Accumulates the sum of freedays and parttime freedays pr month
** in relation to 1 month spanning rules.
**
** NB! FC K11: SKN/SKD/SKS now have the same rules, but the old SKN rules for
** F-days reduction according to available days no longer apply, another
** reduction formula applies instead.
*/
%target_days_in_period_1_month%(Abstime start, Abstime stop) =
    if %flight_crew% then
      if crew.%is_ski% then
         %target_days_in_period_1_month_fclh_k11%(start, stop)
      else
         %target_days_in_period_1_month_fcsh_k11%(start, stop)
    else
      %normal_target_days_in_period_1_month%(start, stop);
      

      
%normal_target_days_in_period_1_month%(Abstime start, Abstime stop) =
  %ind_min_nr_freedays_in_1_month%(start) * %qual_days_in_period%(start, stop) +
  nmax(%target_pt_freedays_in_period_1_month%(start, stop),
       %target_pt_freedays_in_period_2_month%(start, stop));
        
/*
** FC K11 SH: Maximum 2 reduced months per calendar year, and maximum 1 reduced
**            month in 3 consecutive months.
**
** FC K12 SH Passive +: not 2 consecutive reduced months.
**
** A 'reduced month' is one for which freedays_requirement table contains a
** value that is less than the normal 12 F-days specified in the agreement.
**
** FC 4ExNG: Maximum 4 reduced months per calendar year, and maximum 2 reduced
**           month in 3 consecutive months.
**           NB! Although the minimum F-days required per month is reduced from
**           12 to 11, a 'reduced month' is still one where freedays_requirement
**           table specifies less than 12!
*/

%target_days_in_period_1_month_fcsh_k11%(AbsTime start, AbsTime stop) = 
  %_target_days_in_period_1_month_fcsh_k11%(start, stop) 
  - %target_days_correction_75_fcsh_k4exng%(start);
/*  + (if %has_too_many_reduced_months_fcsh%(start) then
     %days_in_month%(start)
   else
     0)*/

%has_too_many_reduced_months_fcsh%(AbsTime start) =
  %freeday_requirement_is_reduced%(start) and
  (accumulators.%no_of_reduced_months_in_calendar_year_skn%(round_down_year(start), start)
     >= %max_no_of_reduced_months_in_year%(start) or
   ((not crew.%is_passive_plus%(start) and
     accumulators.%no_of_reduced_months_in_calendar_year_skn%(add_months(start,-2), start)
       >= %max_no_of_reduced_months_in_3_months%(start)) or
    (crew.%is_passive_plus%(start) and
     accumulators.%no_of_reduced_months_in_calendar_year_skn%(add_months(start,-1), start) > 0)));
     
%max_no_of_reduced_months_in_year%(AbsTime start) =
  if parameters.%k4exng_fc_sp5_1_valid%(start) then
    4
  else
    2;

%max_no_of_reduced_months_in_3_months%(AbsTime start) =
  if parameters.%k4exng_fc_sp5_1_valid%(start) then
    2
  else
    1;

/*
**  4ExNG: There is a problem with 75% crew in the months where they have 8LA,
** and where the min F-day requirement is 12 or less.
** The F-day reduction table, and the equivalent formula used here, give 9,
** F-days, which gives F+LA = 17, whereas the agreement text says the minimum 
** requirement is 16.
** In the months where there are 7LA, or where the the min F-day requirement is
** more than 12, the formula gives the required result
** The discrepancy is handled here, by subtracting days in the month, which
** gives one less F-day.
*/

%target_days_correction_75_fcsh_k4exng%(AbsTime start) =
  if parameters.%k4exng_fc_sp5_1_valid%(start) and
     %_part_time_factor%(start,true) = 75 and
     %_min_freedays_1_month_fc_sh%(start) <= 12 and
     %_monthly_var_pt%(start) = true then
    %days_in_month%(start)
  else
    0;
/*
** FC K11 SH: Minimum F-days reduction according to the pilot's available days
**            must use the normal minimum F-days for 100% pilots as registered
**            in freedays_requirement table, even when the pilot is part-time. 
*/

export %_target_days_in_period_1_month_fcsh_k11%(Abstime start, Abstime stop) =
    let pt_factor = model_crew.%crew_contract_part_time_factor_at_date%(crew.%id%, start);
    model_freedays.%fdc15_month_entitled_basic_fd_qa%(pt_factor, crew.%id%, start)
    * %qual_days_in_period%(start, stop);
        
/*
** FC K11 LH: Minimum F-days reduction according to the pilot's available days
**            must use the normal minimum F-days for 100% pilots even when the
**            pilot is part-time. 
*/

%target_days_in_period_1_month_fclh_k11%(Abstime start, Abstime stop) =
    let pt_factor = model_crew.%crew_contract_part_time_factor_at_date%(crew.%id%, start);
    model_freedays.%fdc15_month_entitled_basic_fd_qa%(pt_factor, crew.%id%, start)
    * %qual_days_in_period%(start, stop);

%fd_vg_with_two_freeday_reduced_months_in_calendar_year% =
  crew.%is_pilot% and crew.%in_variable_group_ppstart% and
  accumulators.%no_of_reduced_months_in_calendar_year_skn%(round_down_year(%pp_end%), %pp_end%) >= 2;
    
%use_min_freedays_formula_skn_fc_p% = 
    parameter True
    remark "Use minimum freeday formula [SKN FC]";

%use_min_freedays_formula_skn_fc%(Abstime date) = 
    %use_min_freedays_formula_skn_fc_p% or 
    (%_min_freedays_1_month_fc_sh%(date) >= 14);

%days_in_month%(Abstime date) =
    let start_date = round_down_month(date),
        end_date = round_up_month(date+0:01);
        
    (end_date - start_date) / 24:00;

/* Needed to calculate number of parttime days as result of special schedule */
%target_days_in_period_1_month_contract%(Abstime start, Abstime stop) =
  /* ordinary f demand */
  %_min_freedays_1_month%(start, true) * %qual_days_in_period%(start, stop) +
  (if crew.%in_variable_group%(start) then
    %_min_pt_freedays_1_month%(start, true)
   else 0);

%target_pt_freedays_in_period_1_month%(Abstime start, Abstime stop) = 
  let days = (stop - start) / 24:00;
  
  if crew.%in_variable_group%(start) and
     crew.%is_part_time_at_date%(start)
  then
    if %flight_crew% and parameters.%k11_fc_sp10_9_valid%(start) then
      %_min_pt_freedays_1_month%(start,true) * days
    else
      (if crew.%is_skn% and %flight_crew% then
           %min_pt_freedays_1_month_skn%(start)
       else
         %min_pt_freedays_1_month%(start))
      * %pt_qual_days_in_period%(start, stop)
  else
    0;
    
export %min_required_in_3_months% =
  (accumulators.%min_required_freedays_in_3_months%(%prev_prev_month_start%, wop.%start_month_end%) + 5) / 10;

/* Lookup for 100% contract start */
%_crew_ft_contract_start%(Abstime start, Abstime date) =
  let contract_date = crew.%agreement_at_date_valid_from%(date);
  if %_crew_is_fulltime_vg%(contract_date) then 
    if contract_date <= start then 
      start
    else if not %_crew_is_fulltime_vg%(contract_date - 24:00) then
      contract_date
    else if not %_crew_is_fulltime_vg%(crew.%agreement_at_date_valid_from%(contract_date - 24:00)) then
      crew.%agreement_at_date_valid_from%(contract_date - 24:00)
    else
      first(times((date-start)/24:00), date - ((%times_index_0% - 1) * 24:00))
      where(not %_crew_is_fulltime_vg%(date - %times_index_0% * 24:00))
  else
    first(times((date-start)/24:00), date - ((%times_index_0% - 1) * 24:00))
    where(not %_crew_is_fulltime_vg%(date - %times_index_0% * 24:00));
  
/* Min required freedays in 3 months for fc sh 100% crew */
export %min_required_in_3_months_fulltime_fc_sh% =
  let stop = wop.%start_month_end%,
      start_ft = %_crew_ft_contract_start%(%prev_prev_month_start%, stop),
      start = %prev_prev_month_start%,
      days_ft = (stop - start_ft) / 24:00,
      days = (stop - start) / 24:00;
  (((days - (days-days_ft) - 
     accumulators.%nr_non_qualifying_days_in_period_fulltime_fc_sh%(start, 
                                                                    stop)) 
     * 10 * %ind_min_nr_freedays_3_months_fulltime_fc_sh%) /
  days + 5) / 10;

/* Min required freedays in 6 months for fc sh 100% crew */
export %min_required_in_6_months_fulltime_fc_sh% =
  let stop = wop.%start_month_end%,
      start = add_months(stop, -6),
      start_ft = %_crew_ft_contract_start%(start, stop),
      days_ft = (stop - start_ft) / 24:00,
      days = (stop - start) / 24:00;
  (((days - (days-days_ft) - 
     accumulators.%nr_non_qualifying_days_in_period_fulltime_fc_sh%(start, 
                                                                    stop)) 
     * 10 * %ind_min_nr_freedays_6_months_fulltime_fc_sh%) /
  days + 5) / 10;
  
%req_freedays_in_interval%(abstime start, abstime stop) =
  let days = (round_up_month(stop) - round_down_month(start))/24:00;
  if start < stop then
    ((10 * %target_days_in_period_1_month%(start, stop) / days) + 5) / 10
  else
    0;

/*
** For SKN there are special vg categories
** arbeids/fritidsordning 5/3
*/
%ind_min_nr_freedays_in_1_month%(Abstime start) =
    if crew.%is_skn% and %flight_crew% and
    not parameters.%k11_fc_sp10_9_valid%(start) then
      %min_freedays_1_month_skn%(start)
    else
      %min_freedays_1_month%(start);
    
table min_nr_freedays_in_3_6_months_fulltime_fc_sh_tab =
  crew.%region%, crew.%is_fdrc_wop_start% -> 
    %ind_min_nr_freedays_3_months_fulltime_fc_sh%,
    %ind_min_nr_freedays_6_months_fulltime_fc_sh%;
  "SKN",     - -> 35, 0;
  &
      -, false -> 35, 72;
      -,  true -> 34, 0;
      -,     - -> 0, 0;
end
  
    
/* The required number of freedays in a month specified by the agreements 
 * listed in the beginning of rule module. This is if all of the days in
 * a month are qualifying. */
/* Removed BX dependencies, HenrikA 09nov2006 */
/* Added Q400 and F50 limits, HenrikA 18dec2006 */
/* Rewrote after many WP and discussion with Bill, /EKG 090220 */

/* Helper variable to make table for req freedays nicer */

table freeday_agreement_table(AbsTime date, Bool contract) =
  crew.%main_func_at_date%(date),
  crew.%is_long_haul%(date) ->
    %freeday_agreement%;
  /* 4EXNG */  
  "F" ,  false -> "FC_SH_4EXNG";
  "F" ,  true  -> "FC_SKI_4EXNG";
  "C" ,  -     -> "CC_4EXNG";
  - ,    -     -> "-";
end

%freeday_agreement_cc_skn%(Abstime date) = 
    if crew.%is_afo_skn%(date) then
        "CC_SKN_AFO"
    else if crew.%is_fulltime_temp_SKN_at_date%(date) then
        "CC_SKN_TMP"
    else 
        "CC_SKN";    

%_part_time_factor%(AbsTime date, Bool contract) = 
  if contract then 
    crew.%crew_contract_part_time_factor_at_date%(date)
  else 
    crew.%part_time_factor_at_date%(date);

/* In general we check contract + special schedule for parttime, but in some
   specific cases we need to check one or the other. */
%min_freedays_1_month%(Abstime date) = %_min_freedays_1_month%(date, false);
%min_freedays_2_month%(Abstime date) = %_min_freedays_2_month%(date, false);
%min_pt_freedays_1_month%(Abstime date) = 
    let start_date = round_down_month(date),
        end_date = round_up_month(date);
        
    if crew.%is_sks% and 
       %flight_crew% and 
       %part_time_change_date_in_period%(start_date, end_date) then 
        nmin(%_min_pt_freedays_1_month%(start_date, false),
            %_min_pt_freedays_1_month%(end_date, false))
    else
        %_min_pt_freedays_1_month%(date, false);   

%min_pt_freedays_2_month%(Abstime date) = 
    let start_date = %start_date_pt_2_month%(date),
        end_date = %end_date_pt_2_month%(date);
            
    if crew.%is_sks% and 
       %flight_crew% and 
       %part_time_change_date_in_period%(start_date, end_date) then
       nmin(%_min_pt_freedays_2_month%(start_date, false),
            %_min_pt_freedays_2_month%(end_date, false))      
       
    else
        %_min_pt_freedays_2_month%(date, false);   
        
%start_date_pt_2_month%(Abstime date) = 
    if fundamental.%even_month_by_month_start%(date) then 
        add_months(round_down_month(date), -1)
    else 
        round_down_month(date);
        
%end_date_pt_2_month%(Abstime date) =     
    if fundamental.%even_month_by_month_start%(date) then
        round_up_month(date)
    else 
        add_months(round_up_month(date), 1);
            
%part_time_change_date_in_period%(Abstime start_date, Abstime end_date) = 
    not void(crew.%part_time_change_date_in_period%(start_date, 
                                                    end_date));   

table ind_min_pt_freedays(Abstime date, Bool contract) =
  %_part_time_factor%(date, contract) ->
    %_min_pt_freedays_in_month%;

  100 -> 0;
  90  -> 3;
  80  -> 6;
  75  -> 7;
  64  -> 11; /*CORONA*/
  60  -> 12;
  50  -> 15;
  48  -> 16; /*CORONA*/
  45  -> 17; /*CORONA*/
  40  -> 18; /*CORONA*/
  36  -> 19; /*CORONA*/
  30  -> 21; /*CORONA*/
  24  -> 23; /*CORONA*/
  20  -> 24; /*CORONA*/
  16  -> 26; /*CORONA*/
  15  -> 26; /*CORONA*/
  10  -> 27; /*CORONA*/
  -   -> 0;
end
  
table ind_min_nr_freedays(Abstime date, Bool contract) =
  %freeday_agreement%(date, contract),
  %_part_time_factor%(date, contract),
  %_monthly_var_pt%(date) ->
    %_min_freedays_1_month%,
    %_min_freedays_2_month%,
    %_min_pt_freedays_1_month%,
    %_min_pt_freedays_2_month%;

  /* 4EXNG */
  "FC_SH_4EXNG" , 100, -     -> %_min_freedays_1_month_fc_sh%(date),            0,  0,  0;
  "FC_SH_4EXNG" ,  83, -     -> %min_f_and_la_days_pt_fc_4exng%(date) -  6,     0,  6,  0;
  "FC_SH_4EXNG" ,  80, -     -> %min_f_and_la_days_pt_fc_4exng%(date) -  6,     0,  6,  0;
  "FC_SH_4EXNG" ,  75, false -> %min_f_and_la_days_pt_fc_4exng%(date) -  7,     0,  7,  0;
  "FC_SH_4EXNG" ,  75, true  -> %min_f_and_la_days_pt_fc_4exng%(date) -  8,     0,  8,  0;
  "FC_SH_4EXNG" ,  60, -     -> %min_f_and_la_days_pt_fc_4exng%(date) - 12,     0,  12, 0; /********CORONA*******/  
  "FC_SH_4EXNG" ,  50, -     -> %min_f_and_la_days_pt_fc_4exng%(date) - 15,     0,  15, 0;
  "FC_SH_4EXNG" ,  45, -     -> %min_f_and_la_days_pt_fc_4exng%(date) - 17,     0,  17, 0; /********CORONA*******/  
  "FC_SH_4EXNG" ,  40, -     -> %min_f_and_la_days_pt_fc_4exng%(date) - 18,     0,  18, 0; /********CORONA*******/
  "FC_SH_4EXNG" ,  38, -     -> %min_f_and_la_days_pt_fc_4exng%(date) - 19,     0,  19, 0; /********CORONA*******/
  "FC_SH_4EXNG" ,  35, -     -> %min_f_and_la_days_pt_fc_4exng%(date) - 20,     0,  20, 0; /********CORONA*******/   
  "FC_SH_4EXNG" ,  30, -     -> %min_f_and_la_days_pt_fc_4exng%(date) - 21,     0,  21, 0; /********CORONA*******/
  "FC_SH_4EXNG" ,  28, -     -> %min_f_and_la_days_pt_fc_4exng%(date) - 22,     0,  22, 0; /********CORONA*******/ 
  "FC_SH_4EXNG" ,  25, -     -> %min_f_and_la_days_pt_fc_4exng%(date) - 23,     0,  23, 0; /********CORONA*******/
  "FC_SH_4EXNG" ,  20, -     -> %min_f_and_la_days_pt_fc_4exng%(date) - 24,     0,  24, 0; /********CORONA*******/
  "FC_SH_4EXNG" ,  15, -     -> %min_f_and_la_days_pt_fc_4exng%(date) - 26,     0,  26, 0; /********CORONA*******/
  "FC_SH_4EXNG" ,  10, -     -> %min_f_and_la_days_pt_fc_4exng%(date) - 27,     0,  27, 0; /********CORONA*******/  
  "FC_SKI_4EXNG", 100, -     -> %min_freedays_1_month_fclh_4exng%,              0,  0,  0;
  "FC_SKI_4EXNG" , 83, -     -> %min_f_and_la_days_pt_fc%(date) -  6,     0,  6,  0; /********CORONA FD SKI September 2020*******/
  "FC_SKI_4EXNG" , 80, -     -> %min_f_and_la_days_pt_fc%(date) -  6,     0,  6,  0; /********CORONA FD SKI September 2020*******/
  "FC_SKI_4EXNG",  75, false -> %min_f_and_la_days_pt_fc%(date) - 7,      0,  7, 15;
  "FC_SKI_4EXNG",  75, true  -> %min_f_and_la_days_pt_fc%(date) - 8,      0,  8, 15;
  "FC_SKI_4EXNG" , 60, -     -> %min_f_and_la_days_pt_fc%(date) - 12,     0,  12, 0; /********CORONA FD SKI September 2020*******/  
  "FC_SKI_4EXNG" , 50, -     -> %min_f_and_la_days_pt_fc%(date) - 15,     0,  15, 0; /********CORONA FD SKI September 2020*******/
  "FC_SKI_4EXNG" , 45, -     -> %min_f_and_la_days_pt_fc%(date) - 17,     0,  17, 0; /********CORONA FD SKI September 2020*******/  
  "FC_SKI_4EXNG" , 40, -     -> %min_f_and_la_days_pt_fc%(date) - 18,     0,  18, 0; /********CORONA FD SKI September 2020*******/
  "FC_SKI_4EXNG" , 38, -     -> %min_f_and_la_days_pt_fc%(date) - 19,     0,  19, 0; /********CORONA FD SKI September 2020*******/
  "FC_SKI_4EXNG" , 35, -     -> %min_f_and_la_days_pt_fc%(date) - 20,     0,  20, 0; /********CORONA FD SKI September 2020*******/   
  "FC_SKI_4EXNG" , 30, -     -> %min_f_and_la_days_pt_fc%(date) - 21,     0,  21, 0; /********CORONA FD SKI September 2020*******/
  "FC_SKI_4EXNG" , 28, -     -> %min_f_and_la_days_pt_fc%(date) - 22,     0,  22, 0; /********CORONA FD SKI September 2020*******/ 
  "FC_SKI_4EXNG" , 25, -     -> %min_f_and_la_days_pt_fc%(date) - 23,     0,  23, 0; /********CORONA FD SKI September 2020*******/
  "FC_SKI_4EXNG" , 20, -     -> %min_f_and_la_days_pt_fc%(date) - 24,     0,  24, 0; /********CORONA FD SKI September 2020*******/
  "FC_SKI_4EXNG" , 15, -     -> %min_f_and_la_days_pt_fc%(date) - 26,     0,  26, 0; /********CORONA FD SKI September 2020*******/
  "FC_SKI_4EXNG" , 10, -     -> %min_f_and_la_days_pt_fc%(date) - 27,     0,  27, 0; /********CORONA FD SKI September 2020*******/  
  
  "CC_4EXNG"    ,  - , -     -> %min_freedays_1_month_4exng_cc%(date,contract), 0,  0,  0;
  
  -, -, -                    -> 0, 0, 0, 0;
end

%_min_freedays_1_month_fclh%(Abstime date) =
    %min_freedays_1_month_fclh_4exng%;

%min_freedays_1_month_fclh_4exng% = 11;

table min_f_and_la_days_pt_fc_4exng (Abstime date) =
  %freeday_requirement_is_reduced%(date),
  %_part_time_factor%(date, true)
    -> %min_f_and_la_days_pt_fc_4exng%;
    
  true,  83 -> 14;
  false, 83 -> 15;
  true,  80 -> 14;
  false, 80 -> 15;
  true,  75 -> 15;
  false, 75 -> 16;
  true,  50 -> 20;
  false, 50 -> 21;
    -  ,  - -> 99;
end
 
 
table min_f_and_la_days_pt_fc (Abstime date) =
  %freeday_requirement_is_reduced%(date),
  %_part_time_factor%(date, true)
    -> %min_f_and_la_days_pt_fc%;
    
  true,  90 -> 13;
  true,  83 -> 15;
  true,  80 -> 15;
  true,  75 -> 16;
  true,  60 -> 18;
  true,  50 -> 20;
  false, 90 -> 14;
  false, 83 -> 16;
  false, 80 -> 16;
  false, 75 -> 17;
  false, 60 -> 19;
  false, 50 -> 21;
    -  ,  - -> 99;
end

/* Auxiliary formulas for F-days min values in 'internal' table */
table gm_freeday_table(AbsTime date) =
  %gm_agreement_valid%(date) -> %_rc_100%, %_sh_100_1m%, %_sh_100_2m%, %_sh_pt_2m%;
  true -> %_min_freedays_1_month_fc_sh%(date), %_min_freedays_1_month_fc_sh%(date), 0, 0;
  false -> 11, 12, 26, 11;
end

export %min_freedays_1_month_skn%(Abstime date) = 
    nmax(%_min_freedays_1_month_skn%(date) + %_min_freedays_1_month_fc_sh%(date) - 13, 0);
    
table ind_min_nr_freedays_skn(AbsTime date) =
    (round_up_month(date+0:01)-round_down_month(date)) / 24:00, 
    %qual_days_in_period_skn_fc%(
      crew.%variable_group_start%(round_down_month(date), 
                                  round_up_month(date+0:01)),
      crew.%variable_group_end%(round_down_month(date), 
                                round_up_month(date+0:01)))
        -> %_min_freedays_1_month_skn%;
    31, 31 -> 13;
    31, 30 -> 12;
    31, (28, 29) -> 11;
    31, (25, 27) -> 10;
    31, (22, 24) -> 9;
    31, (20, 21) -> 8;
    31, (17, 19) -> 7;
    31, (15, 16) -> 6;
    31, (10, 14) -> 5;
    
    30, 30 -> 13;
    30, 29 -> 12;
    30, (27, 28) -> 11;
    30, (24, 26) -> 10;
    30, (22, 23) -> 9;
    30, (19, 21) -> 8;
    30, (17, 18) -> 7;
    30, (14, 16) -> 6;
    30, (10, 13) -> 5;
    
    29, 29 -> 13;
    29, 28 -> 12;
    29, (26, 27) -> 11;
    29, (23, 25) -> 10;
    29, (21, 22) -> 9;
    29, (19, 20) -> 8;
    29, (16, 18) -> 7;
    29, (14, 15) -> 6;
    29, (10, 13) -> 5;
    
    28, 28 -> 13;
    28, 27 -> 12;
    28, (25, 26) -> 11;
    28, (23, 24) -> 10;
    28, (20, 22) -> 9;
    28, (18, 19) -> 8;
    28, (16, 17) -> 7;
    28, (13, 15) -> 6;
    28, (10, 12) -> 5;
    -, - -> 0;
end

export %min_pt_freedays_1_month_skn%(AbsTime date) =
    let freedays_1_month = %min_freedays_1_month_skn%(date) + %_use_reduction_table%(date) - %_min_freedays_1_month_fc_sh%(date);
    (10 * %_min_pt_freedays_1_month_skn%(date) * freedays_1_month / 
    %_use_reduction_table%(date) + 5) / 10 - %min_freedays_1_month%(date);

table min_pt_freedays_skn(AbsTime date) =
    (round_up_month(date+0:01)-round_down_month(date)) / 24:00, 
    crew.%part_time_factor_at_date%(date), 
    %_min_freedays_1_month_fc_sh%(date) -> 
        %_min_pt_freedays_1_month_skn%, %_use_reduction_table%;
    -, 100, 13 -> 13, 13;
    -, 100, 12 -> 12, 12;
    -, 100, 11 -> 11, 11;
        
     -, 90, 13 -> 15, 13;
     -, 90, 12 -> 14, 12;
     -, 90, 11 -> 13, 11;
     
    31, 83, 13 -> 17, 13;
    30, 83, 13 -> 17, 13;
    29, 83, 13 -> 17, 13;
    28, 83, 13 -> 16, 12;
     -, 83, 12 -> 16, 12;
     -, 83, 11 -> 15, 11;

    31, 80, 13 -> 17, 13;
    30, 80, 13 -> 17, 13;
    29, 80, 13 -> 17, 13;
    28, 80, 13 -> 16, 12;
     -, 80, 12 -> 16, 12;
     -, 80, 11 -> 15, 11;

    31, 75, 13 -> 18, 13;
    30, 75, 13 -> 18, 13;
    29, 75, 13 -> 17, 12;
    28, 75, 13 -> 17, 12;
    31, 75, 12 -> 17, 12;
    30, 75, 12 -> 17, 12;
    29, 75, 12 -> 17, 12;
    28, 75, 12 -> 16, 11;
     -, 75, 11 -> 16, 11;
     
    31, 60, 13 -> 21, 13;
    30, 60, 13 -> 20, 13;
    29, 60, 13 -> 20, 13;
    28, 60, 13 -> 19, 12;
    31, 60, 12 -> 20, 13;
    30, 60, 12 -> 20, 13;
    29, 60, 12 -> 19, 12;
    28, 60, 12 -> 19, 12;
    31, 60, 11 -> 19, 12;
    30, 60, 11 -> 19, 12;
    29, 60, 11 -> 19, 12;
    28, 60, 11 -> 18, 11;

    31, 50, 13 -> 22, 13;
    30, 50, 13 -> 22, 13;
    29, 50, 13 -> 21, 12;
    28, 50, 13 -> 21, 12;
    31, 50, 12 -> 22, 13;
    30, 50, 12 -> 21, 12;
    29, 50, 12 -> 21, 12;
    28, 50, 12 -> 20, 11;
    31, 50, 11 -> 21, 12;
    30, 50, 11 -> 21, 12;
    29, 50, 11 -> 20, 11;
    28, 50, 11 -> 20, 11;

    -, -, - -> 0, void_int;
end

%_min_freedays_1_month_fc_sh%(Abstime date) =
    default(%__min_freedays_1_month_fc_sh%(date),
            %_min_freedays_1_month_fc_sh_default%(date));

%__min_freedays_1_month_fc_sh%(Abstime date) =
    default(%___min_freedays_1_month_fc_sh%(date, crew.%ac_family_by_qual%), 
            %___min_freedays_1_month_fc_sh%(date, "*"));

/* 4ExNG */    
table freeday_requirement_CC (Abstime date, Bool contract) =
  round_down_month(date), 
  crew.%region_at_date%(date),
  %part_time_factor_string%(date,contract) -> 
    Int %min_freedays_1_month_4exng_cc%;

  external %freeday_requirement_table_cc%;

  (validfrom, validto(, region, servicegrade -> minfreedays;
            -         ,   -   ,      -       -> void_int;
end

export %part_time_factor_string% (Abstime date, Bool contract)=
  format_int(%_part_time_factor%(date, contract),"%i%%");
  
%freeday_requirement_table_cc% =
  "freeday_requirement_cc";

export %min_nr_freedays_parttime%(Abstime date) = default(%agreement_freedays_in_month%(model_crew.%agreement_at_date%(crew.%id%,date)) / 100, 0);

table default_freeday_requirement_fc_sh(Abstime date) =
  parameters.%k4exng_fc_sp5_1_valid%(date),
  parameters.%k11_fc_sp10_9_valid%(date),
  system_db_parameters.%freedays_fd_corona%(date),
  %crew_has_corona_parttime%,
  crew.%region_at_date%(date),
  not crew.%is_fdrc%(date),
  %crew_employed_before_25Jan2005% ->
    %_min_freedays_1_month_fc_sh_default%;
    
  true,    - , -   , false,    -  ,     -,     - -> 11; /* 4ExNG */
  true,    - , true, true,    -    ,     -,     - -> %corona_min_freedays_parameter_p%; /* CORONA */ 
  false, true,  -  , false,   -  ,     -,     - -> 12; /* K11 */
  false, false, -  , false, "SKN",     -,     - -> 13;
  &
    -  ,  -  ,  -  ,false,    -, false,  true -> 12; /* Crew in RC employed before 25Jan2005 */
    -  ,    -,  -  ,false,    -, false, false -> 11; /* Crew in RC employed after 25Jan2005 */
    -  ,    -,  -  ,false,    -,  true,     - -> 13; /* Crew in MAIN */
  
    -  ,    -,    -,    -,    -,     -,     - -> 13;
end

%crew_has_corona_parttime% =
crew.%has_corona_at_date%(%pp_start%) or crew.%has_corona_at_date%(%pp_end%) ;

%corona_min_freedays_parameter_p% =
parameter 11
remark "Minimum freedays parameter Corona";

%crew_employed_before_25Jan2005% =
  crew.%employment_date_at_date%(%now%) <= 25Jan2005;

%___min_freedays_1_month_fc_sh%(Abstime date, String ac_fam) =
  if crew.%is_passive_plus%(date) then
    %___min_freedays_1_month_fc_sh_passive%(date, ac_fam)
  else
    %___min_freedays_1_month_fc_sh_standard%(date, ac_fam);
        
table freeday_requirement(Abstime date, String ac_fam) =
  round_down_month(date), 
  crew.%region_at_date%(date), 
  not crew.%is_fdrc%(date),
  ac_fam -> 
    Int %___min_freedays_1_month_fc_sh_standard%,
	Int %___min_freedays_1_month_fc_sh_passive%;
  external %freeday_requirement_table%;
  validmonth, 
  region, 
  maingroup,
  acfamily -> 
    minfreedays,
	freedayspassive;
  -,
  -,
  -,
  - -> 
    void_int,
	void_int;
end

%freeday_requirement_table% =
  "freeday_requirement";

/*
** K4ExNG FC: Minimum F-days per month is now 11 instead of 12, but the rules
** for reduced months still apply to months with 11F, so a month is considered
** to be reduced if the freeday_requirement tables specifies less than 12F!
*/
export %freeday_requirement_is_reduced%(AbsTime start) =
  %_min_freedays_1_month_fc_sh%(start) < 12;
  
export %has_reduced_freeday_requirement_in_month_fc_sh%(AbsTime month_start) = 
  let start_t = round_down_month(month_start),
      end_t = round_up_month(start_t + 0:01);
      
  %_min_freedays_1_month_fc_sh%(start_t) > 
  %min_required_in_1_month_by_month_startdate%(start_t, end_t);

/*
** 50% and 75% crew get extra pt freeday the months with 31 days
** Crew in SKS CC should have one freeday less during February
*/
%_monthly_var_pt%(AbsTime date) =
  if crew.%main_func_at_date%(date) = "C" and crew.%region_at_date%(date) = "SKS" then
    format_time(date, "%02m") = "02"
  else
    %__monthly_var_pt%(date);

table month_variation_freedays(Abstime date) =
  format_time(date, "%02m") -> %__monthly_var_pt%;
  "02" -> false;
  "04" -> false;
  "06" -> not (crew.%is_skn% or crew.%is_sks%);
  "07" -> crew.%is_skn%;
  "09" -> false;
  "11" -> false;
  - -> true;
end

/* Only FC relevant - for accumulator module compile */
/* Moved definitions below back here because of tracking rule set compile errors - JonasC 07076 */

/* ONLY FC SH VG relevant - possible move to freedays_fc */
export %ind_req_pt_freedays_2_months_1_month_part%(Abstime start, Abstime stop) =
  if crew.%part_time_change_in_period%(start, stop) then
    %ind_req_pt_freedays_2_months_with_month_as_two_intervals%(start, stop)
  else
    %ind_req_pt_freedays_2_months_with_month_as_one_interval%(start, stop);

/* ONLY FC SH VG relevant - possible move to freedays_fc */
%ind_req_pt_freedays_2_months_with_month_as_two_intervals%(Abstime start, Abstime stop)  =
  let part_time_change_date = crew.%part_time_change_date_in_period%(start, stop),
      days_in_month = (stop - start) / 24:00;
  10 *
  (%target_pt_freedays_in_period_2_month%(calendar.%month_start%, part_time_change_date) +
   %target_pt_freedays_in_period_2_month%(part_time_change_date, calendar.%month_end%)) / days_in_month;

/* ONLY FC SH VG relevant - possible move to freedays_fc */
%ind_req_pt_freedays_2_months_with_month_as_one_interval%(Abstime start, Abstime stop) =
  10 * %target_pt_freedays_in_period_2_month%(start, stop) / ((stop - start) / 24:00);
  
export %ind_req_3_months_1_month_part%(Abstime start, Abstime stop) =
  let days = (stop-start) / 24:00;
  if crew.%part_time_change_in_period%(start,stop) then
    %ind_req_3_months_split%(start,stop)
  else
    (10 * %min_required_in_month%(start) * nmin(%qual_days_for_pt%(start,stop,days,days),days)) / days;

%ind_req_3_months_split%(Abstime start,Abstime stop) = 
  let days = (stop-start) / 24:00,
      split_day = crew.%part_time_change_date_in_period%(start,stop),
      first_days = (split_day-start) / 24:00;
    ( %min_required_in_month%(start) * first_days * nmin(%qual_days_for_pt%(start,split_day,first_days,days),first_days)
     + %min_required_in_month%(split_day) * (days-first_days) * nmin(%qual_days_for_pt%(split_day,stop,days-first_days,days),days-first_days)
    ) * 10 / days/ days;
  

%qual_days_for_pt%(Abstime start,Abstime stop,Int first_days,Int days) = 
  %qual_days_in_period%(start, stop) + (first_days * %_min_pt_freedays_1_month%(start,true))/days;

%min_required_in_month%(AbsTime date) = %min_required_in_quarter%(date) / 3;



/*
** NB! FC 4EXNG - accepting 100% and 75% only is a temporary solution,
** because we don't have information for other part-time percents that will
** still be in use, e.g. SKN Norwegian Vacation Law contracts.
*/
table min_required_in_quarter_table(AbsTime date) =
  parameters.%k4exng_fc_sp5_1_valid%(date) and
  (crew.%part_time_factor_at_date%(date) = 100 or
   crew.%part_time_factor_at_date%(date) = 75),
  crew.%part_time_factor_at_date%(date) 
      -> export %min_required_in_quarter%;

  True , 100 -> 34; /* 4ExNG */
  True ,  80 -> 43;
  True ,  75 -> 48;
  True ,  50 -> 61;

  False, 100 -> 36; /* K11 */
  False,  90 -> 42;
  False,  83 -> 48;
  False,  80 -> 48;
  False,  75 -> 51;
  False,  60 -> 57;
  False,  50 -> 63;

    -  ,  -  -> 0; 
end

  
/* Note: Need handling of excees freedays in first month of 2 !! - coordinate with cost */
export %min_required_in_2_months% = 
  (accumulators.%min_required_freedays_in_2_months%(%prev_month_start%, wop.%start_month_end%) + 5) / 10;
export %min_required_in_2_months_wop_indep% = 
  (accumulators.%min_required_freedays_in_2_months%(round_down_month(%pp_start%-00:01),
                                                    %publ_period_end%) + 5) / 10;
export %min_required_in_2_months_by_month_start%(abstime month_start_hbt) = 
  (accumulators.%min_required_freedays_in_2_months%(round_down_month(month_start_hbt-00:01),
                                                    round_up_month(month_start_hbt + 0:01)) + 5) / 10;
/*
** This variable calculates a 1 month minimum freeday requirement 
** in proportion two a 2 months demand.a (2 months spanning rules)
** 
** Assumption is max one parttime change in a calendar month.
** -> max two changes in two calendar months
** 
** Algorithm is:
**   For each parttime subinterval in month
**     reduce the 2 month freedays requirement for the relevant
**     parttime factor with fraction 
**     nr_qualifying_days_in_subinterval / days in 2 month  
** If two subintervals in month sum them up.
*/

export %ind_req_2_months_1_month_part%(Abstime start, Abstime stop) = 
  let days_in_month = (stop - start) / 24:00;
  (if crew.%part_time_factor_at_date%(start) <>
      crew.%part_time_factor_at_date%(stop-0:01) then
     %ind_req_freedays_2_months_with_month_as_two_intervals%(start, stop)
   else
     %ind_req_freedays_2_months_with_month_as_one_interval%(start, stop)) / days_in_month;

/*
** Two subintervals in one month - sum up
** The subinterval freeday requirement target must be averaged against
** a month, so we divide the 2 months requirement by 2 even though this
** is not 100% correct.  
** This function is used for accumulators which is why it has 
** signature with arguments.
*/

/* stop and start are assumed to span 1 month */
%ind_req_freedays_2_months_with_month_as_two_intervals%(Abstime start, Abstime stop)  =

  let part_time_change_date = crew.%part_time_change_date_in_period%(start, stop);

  (%target_days_in_period_2_month%(start, part_time_change_date) +
   %target_days_in_period_2_month%(part_time_change_date, stop));

/* stop and start are assumed to span 1 month */
%ind_req_freedays_2_months_with_month_as_one_interval%(Abstime start, Abstime stop) =
  %target_days_in_period_2_month%(start, stop);

/*
** Accumulates the sum of freedays and parttime freedays pr month
** in relation to 2 month spanning rules.
** Despite the variable name's general character it will only work on
** a monthly basis ! 
*/
%target_days_in_period_2_month%(Abstime start, Abstime stop) =
  ((10 * %ind_min_nr_freedays_in_2_month%(start)) / 2) * 
  %qual_days_in_period%(start, stop) +
  10 * %target_pt_freedays_in_period_2_month%(start, stop);

%target_pt_freedays_in_period_2_month%(Abstime start, Abstime stop) =
  /* potential parttime f demand */
  (if crew.%is_part_time_at_date%(start) then
     ((100* %min_pt_freedays_2_month%(start)
       * %pt_qual_days_in_period%(start, stop)) / 2 +50)/100 
   else
     0);

/*
** For SKN there are special vg categories
** arbeids/fritidsordning 5/3
*/
%ind_min_nr_freedays_in_2_month%(Abstime start) =
    %min_freedays_2_month%(start);

export %req_lh_freedays_in_month_skd%(AbsTime start_t, AbsTime end_t) =
  if crew.%is_skd% and %cabin_crew% then
    sum(wop(roster), overlap(wop.%end_day% + 24:00, wop.%end_day% + (last(duty(wop), %min_required_freedays_after_duty%) + 1) * 24:00, 
                             start_t, end_t)/24:00)
    where(wop.%is_long_haul%)
  else
    0;


/* The required number of freedays according to OMA. The 
   variable depends on the number of vacation and illness days. The required
   number of freedays decreases when the number of vacation and/or illness 
   days increases.
/* The required freedays for the OMA-rule. Equals 
   %oma_standard_freedays_limit_in_month% if there are not any vacation or 
   illness in the month.*/
export %oma_required_freedays_in_month% = 
  (10 * %oma_standard_freedays_limit_in_month% 
      * %oma_considered_days_in_month%
   / wop.%month_days% + 5) / 10;

export %oma_standard_freedays_limit_in_month% = 7;

/*
**  Support variables for yearly OMA offduty days rule (OMA 7.1.6)
**
**  Rule is evaluated against average demand acc. to
**  time span inside calendar year.
**
**  offduty demand is also reduced for vacation, illness and leave
*/

export %oma_required_freedays_in_calendar_year% = 
  let days_in_year = (round_up_year(wop.%start_hb%) - 
                      round_down_year(wop.%start_hb%)) / 24:00;
  (((10 * %oma_considered_days_in_calendar_year%) * %oma_standard_freedays_limit_in_calendar_year%) 
   / days_in_year + 5) 
  / 10; 

%oma_standard_freedays_limit_in_calendar_year% = 96;

%days_in_calendar_year% = 
  (%pp_end% - nmax(%year_start%, crew.%employment_date_at_date%(wop.%start_hb%))) / 24:00;

/* Days that are not vacation,illness or leave. */
export %oma_considered_days_in_calendar_year% =
  accumulators.%oma_considered_days_in_period%(
    nmax(%year_start%, crew.%employment_date_at_date%(wop.%start_hb%)), 
    round_up_year(wop.%start_hb%));
/* Days that are not vacation, illness, KD or GD. */
%oma_considered_days_in_month% =
  %oma_considered_days_in_period%(wop.%start_month_start%, wop.%start_month_end%);

export %oma_considered_days_in_period%(Abstime start, Abstime stop) =
  (stop - start) / 24:00 -
  (sum(wop(roster), wop.%days_in_period%(start, stop))
   where (wop.%start_hb% < stop and
          wop.%end_hb% > start and
         (wop.%is_loa% or
          wop.%is_vacation% or
          %wop_is_not_qualifying_for_freedays_common%)) +
   sum(wop(roster), %illness_days_in_wop%(start, stop))
   where(wop.%is_illness% or wop.%has_illness%));

export %oma_freedays_in_month% =
  %oma_freedays_in_period%(wop.%start_month_start%, wop.%start_month_end%);

export %oma_freedays_in_month_caa% =
  %oma_freedays_in_period_caa%(wop.%start_month_start%, wop.%start_month_end%);

export %oma_freedays_in_calendar_year% =
  accumulators.%oma_freedays_in_period%(
    nmax(%year_start%, crew.%employment_date_at_date%(wop.%start_hb%)),
    %pp_end%);
 
/*
** OMA freedays: ordinary freedays + offduty 'qualifying' for freedays
** like F3, BL.
*/
export %oma_freedays_in_period%(Abstime start, Abstime stop) =
  (stop - start) / 24:00 -
  sum(wop(roster), %oma_days_in_wop_contained_in_period%(start, stop))
  where (not wop.%is_freeday% and
         not wop.%is_blank_day% and
         not wop.%is_compensation_day% and
         wop.%start_hb% < stop and
         default(wop.%rest_end%, wop.%end_hb%) > start) + bought_days.%bought_days_in_period%(start, stop);
         
export %oma_freedays_in_period_caa%(Abstime start, Abstime stop) =
  (stop - start) / 24:00 -
  sum(wop(roster), %oma_days_in_wop_contained_in_period%(start, stop))
  where (not wop.%is_freeday% and
         not wop.%is_blank_day% and
         not wop.%is_compensation_day% and
         wop.%start_hb% < stop and
         default(wop.%rest_end%, wop.%end_hb%) > start);
  
  
export %illness_days_in_month% =
  %illness_in_period%(wop.%start_month_start%, wop.%start_month_end%);

export %illness_in_period%(Abstime start, Abstime stop) =
  sum(trip(roster), trip.%days_in_period%(start, stop))
  where (trip.%start_hb% < stop and
         trip.%end_hb% > start and
         trip.%is_illness%);
  
export %n153_time_in_period%(Abstime start, Abstime stop) = 0:00;

/* Note: This wrap around  %days_in_wop_contained_in_month% makes plans that 
 * contain long course blocks and/or stand-by lines legal.
 * Right now a course wop with length > 5 days or stand-by line generate 
 * 2 freedays for every 7 wop days. Is this correct? Discuss.*/
%oma_days_in_wop_contained_in_period%(Abstime start, Abstime stop) =
  if wop.%is_standby_line% or 
     wop.%in_long_course_period% then
    (wop.%days_in_period%(start, stop) / 7) * 5
  else
    wop.%days_in_period%(start, stop) -
    %wop_days_overlap_bwd%;
    
%wop_days_overlap_bwd% =
  default(overlap(wop.%start_day%, wop.%end_day%+24:00,
          prev(wop(chain),wop.%start_day%),
          prev(wop(chain),wop.%end_day%+24:00))/24:00, 0);

/***************************************************************************
 * Section 8: The required number of freedays after production.
 **************************************************************************/
/* All freedays wrapped around vacation and (for cc SKD)
 * F7S should also be counted.
 * The default value 12 is just chosen as a safe value
 * Bought-days should be counted as freedays. Calculation
 * should therefore ignore bought days */
 
/* Freedays after duty
**   This definition can disregard buy-days since it is only
**   used in CCR. This variable is then redefined in freedays_cct 
*/
export %freedays_after_duty% =
  %_freedays_after_duty% + 
  (if %_wrap_around_vacation% and
      (%next_not_freedays_wop_is_vacation% or
       %next_not_freedays_wop_is_vacation_skd_cc%) and
      (%cabin_crew% or
       %next_not_freedays_wop_is_summer_vacation% or
       not %any_off_duty_counts_as_freeday%) then
     next(wop(roster),%nr_freedays_after_va%)
       where (wop.%is_vacation%)
   else 0);
    
  
/* Will be redefined for Tracking and for Request Bidding */  
%_freedays_after_duty% = %_basic_freedays_after_duty%; 

/*
** For SKD CC, compensation days don't count as freedays, but have to be
** ignored, because freedays can be wrapped around them.
*/
%_basic_freedays_after_duty% =
  (default(next(duty(roster),duty.%start_day%)
             where ((not %counts_as_freeday% and
                     not (%cabin_crew% and crew.%is_skd% and
                          duty.%is_compensation_day%)) or 
                    (not %any_off_duty_counts_as_freeday% and
                     %duty_is_SKI_LA%)),
           %_basic_freedays_after_duty_default%) -
   (duty.%end_day% + 24:00)) / 24:00 -
  (if %cabin_crew% and crew.%is_skd% and
      not (%_wrap_around_vacation% and %next_not_freedays_wop_is_vacation%) then
     default(sum(wop(chain),%wop_days%)
               from (next)
               while (any(duty(wop),%counts_as_freeday%) or
                      wop.%is_compensation_day%)
               where (wop.%is_compensation_day%),
             0)
   else
     0);


/*
** The SKK rule for freedays after production checks for precisely the number
** of F-days required, so either use the date of the last assigned F-day,
** or if none are assigned, the date of the last required F-day, as default.
*/
%_basic_freedays_after_duty_default% =
  if crew.%is_skk% then
    default(next(wop(roster),wop.%end_day% + 24:00)
              where (wop.%consecutive_wops_bw% and
                     any(duty(wop),%counts_as_freeday%)),
            wop.%end_day% + 24:00 + 
            %cc_lh_freedays_skk_duty% * 24:00)
  else
    01jan2035;

export %any_off_duty_counts_as_freeday% =
  %flight_crew%;

/*
**  The FC requirement for F-days around summer vacation is included in the
**  rule checking minimum freedays after production, and the FC rule that any
**  time-off day can fulfill the requirement for freedays after production
**  doesn't apply to freedays around summer vacation - those must be F-days.
*/
%counts_as_freeday% =
  (%any_off_duty_counts_as_freeday% and
   not (%prev_onduty_wop_followed_by_summer_vacation% 
        or %illness_followed_by_summer_vacation%)
        and
   duty.%is_off_duty%) or
  (%any_off_duty_counts_as_freeday% and
   %prev_onduty_wop_followed_by_summer_vacation% and
   duty.%group_code% = "FRE") or 
  (not %any_off_duty_counts_as_freeday% and
   (duty.%is_freeday% or
    duty.%is_off_duty_illness% or
    duty.%is_on_duty_illness% or
    duty.%is_unfit_during_duty%));

%illness_followed_by_summer_vacation% = 
    duty.%is_illness%
    and default(prev(duty(wop), duty.%is_on_duty%) 
        where (not duty.%is_illness%), false)
    and %next_not_freedays_wop_is_summer_vacation%;

table post_production_freeday_wrapping =
  %flight_crew%, crew.%region%,
  %next_not_freedays_wop_is_vacation% -> export%_wrap_around_vacation%;
  true,    -  , true -> true;
  false, "SKS", -    -> false;
  false, "SKJ", -    -> false;
  false, "SKK", -    -> false;
  &
  true,  -,     -    -> false;
  false, -,     -    -> true;
end

%duty_is_SKI_LA% = duty.%is_LA% and %flight_crew% and crew.%is_SKI%; 

/* Freedays can be wrapped around anything EXCEPT F7S and F31 */
%_duty_is_special_comp_day% =
  duty.%is_compensation_day% and 
  not (duty.%is_f31% or duty.%is_on_duty_cmp%); 

export %freedays_after_wop% = default(%_freedays_after_wop%, 12);
%_freedays_after_wop% =
  wop.%freedays% +
  sum(wop(roster), wop.%freedays%)
  from (next) forwards
  while (not wop.%is_on_duty%)
  where (wop.%is_vacation%);
  
export %freedays_and_bought_days_after_wop% = 
  default(%_freedays_and_bought_days_after_wop%, 12);
%_freedays_and_bought_days_after_wop% =
  wop.%freedays% +
  bought_days.%bought_days_in_period%(wop.%start_hb%,wop.%end_hb%) +
  sum(wop(roster), wop.%freedays% +
                   accumulators.%bought_days_in_period%(wop.%start_hb%,wop.%end_hb%))
  from (next) forwards
  while (not wop.%is_on_duty%)
  where (wop.%is_vacation%);

/* Agreement:
 *   FC 1.11 G, 13:46 8, SKI K06 ???
 *   CAU J.1.1, J.2.1, P, L.2
 *   NKF/SBK 2.4.3.4
 *   SCCA H, H.2.2
 *   CCJAP 3.9 
 */

/*

/* 
**  Production followed by single FS (super freeday) allowed
*/  
export %next_wop_is_isolated_FS% =
  let wop_end_day = wop.%end_day%;
  default(next(wop(roster), wop.%is_FS% and wop.%days% = 1 and
                            wop.%start_day% - 24:00 = wop_end_day), false);

export %previous_wop_is_isolated_FS% =
  let wop_start_day = wop.%start_day%;
  default(prev(wop(roster), wop.%is_FS% and wop.%days% = 1 and
                            wop.%end_day% + 24:00 = wop_start_day), false);


   
%wop_lh_east_followed_by_west_or_vv% =
  default(%_wop_lh_east_followed_by_west_or_vv%, false);

%_wop_lh_east_followed_by_west_or_vv% =
  (wop.%is_east_bound% and 
   next(wop(roster), wop.%is_west_bound%) where (wop.%is_on_duty%)) or
  (wop.%is_west_bound% and
   next(wop(roster), wop.%is_east_bound%) where (wop.%is_on_duty%));

/* ceil(a/b). Dont use negative numbers */
%roundup_div%(int a,int b) = 
  if (a mod b) = 0 then a / b
  else a / b + 1;
  
export %cabin_freedays_following_one_day_SFJ_return_skd% =
  let /*greenland_start = trip.%start_utc%,*/
      gr_enddate = round_down(wop.%end_hb%,24:00),
      part_time_extra = if (crew.%part_time_factor_wop_start% <> 100 and 
                            %nr_of_one_day_greenland_return_in_wop_not_bought% >= 2) then
                              2
                            else if (crew.%part_time_factor_wop_start% <> 100) then
                              1
                            else
                              0;
      if last(trip(wop), trip.%is_one_day_greenland_return%) 
              where (not trip.%is_bought%) then
        if default(next(wop(chain), 
                        first(trip(wop), 
                              trip.%is_one_day_greenland_return% and 
                              round_down(trip.%end_hb%,24:00) = gr_enddate + 48:00) 
                        where (trip.%is_on_duty% and not trip.%is_bought%))
                    where(not wop.%is_freeday%), 
                   false) then
          1
        else if (%nr_of_one_day_greenland_return_in_wop_not_bought% >= 2) then 
          3 + part_time_extra
        else if %nr_of_production_not_bought_days_in_wop% <= 2 then
          2 + part_time_extra
        else
          3 + part_time_extra
      else
        0;
      
export %nr_of_one_day_greenland_return_in_wop_not_bought% = 
  count(trip(wop)) where (trip.%is_one_day_greenland_return% and not
                          trip.%is_bought%);
export %nr_of_one_day_greenland_return_in_wop% = 
  count(trip(wop)) where (trip.%is_one_day_greenland_return%);
  
%nr_of_production_days_in_wop% =
  let start_date = round_down(wop.%start_hb%, 24:00),
      end_date = round_up(wop.%end_hb%, 24:00);
  default(accumulators.%nr_production_days_in_period%("SH", start_date, end_date),0) +
  default(accumulators.%nr_production_days_in_period%("LH", start_date, end_date),0);

%nr_of_production_not_bought_days_in_wop% =
  let start_date = round_down(wop.%start_hb%, 24:00),
      end_date = round_up(wop.%end_hb%, 24:00);
  default(accumulators.%nr_production_days_in_period%("SH", start_date, end_date),0) +
  default(accumulators.%nr_production_days_in_period%("LH", start_date, end_date),0) -
  default(accumulators.%bought_days_in_period%(start_date, end_date),0);

export %time_off_minimum_duration_fc_k11% = 62:00;

/***************************************************************************
 * Section 9: The correct pattern of VA- and LA-days
 **************************************************************************/

/*
** Freedays before wop, i.e. activity group = "FRE", "ILL" or empty day, or
** SKN cabin crew and activity group = "CMP".
** Used to check the number of F-days before VA.
*/
export %nr_freedays_before_wop% =
    (
        wop.%start_day% -

        default(
            first(duty(wop),
                 prev(duty(chain)
                    where (not (duty.%has_no_duty_time_contribution% and not duty.%is_blank_day%)),
                    duty.%end_day% + 24:00
                )
            ),
            first(wop(chain),wop.%start_day%)
        )
    ) / 24:00 -

    %nr_non_freedays_before_wop%;
  
  
  %nr_non_freedays_before_wop% =
  default(sum(duty(chain), duty.%days%) from (prev) backwards
          while (duty.%has_no_duty_time_contribution% and
                 not duty.%is_blank_day%)
          where ( (%flight_crew% and crew.%is_ski% and task.%is_LAx%(duty.%code%) ) or  /* No LA days are counted as freedays for SKI FD */ 
                  (duty.%group_code% not in off_duty_groups_count_as_freedays_before_va  and (%flight_crew% or not crew.%is_skn% or
                  (not duty.%is_cmp% and not duty.%is_F0%) /* SKCMS-2248: Special treatment of F0 since it is not in activity grp CMP anymore */
                  ))), 0);

set off_duty_groups_count_as_freedays_before_va =
  "FRE", "ILL", "PFR", "PPF";





/* 
** Off duty days before wop - was used for checking freedays before VA and LA
** but shouldn't have been, because it counts all time-off days, whereas the
** rules should check for F-days!
*/
export %off_duty_days_before_wop% =
  default(
          ((if crew.%is_skn% then  wop.%start_day% else %vacation_start_day%) - 
           first(duty(wop), prev(duty(chain) where (not duty.%is_off_duty% and not duty.%is_cmp%), 
                                 duty.%end_day% + 24:00)))/24:00,
           10) 
  - %cmp_days_before_wop%;
  
export %off_duty_days_after_wop% =
  default(
          (last(duty(wop), next(duty(chain) where (not duty.%is_off_duty% and not duty.%is_cmp%),
                                duty.%start_day%)) - (if crew.%is_skn% then wop.%end_day% + 24:00 else %vacation_end_day%))/24:00,
          10) 
  - %cmp_days_after_wop%;
  

%cmp_days_before_wop% =   
  default(sum(duty(chain), duty.%days%) from (prev) backwards
          while (duty.%is_freeday% or duty.%is_cmp%)
          where (duty.%is_cmp%),
          0);
  
%cmp_days_after_wop% =    
   default(sum(duty(chain), duty.%days%) from (next) forwards
          while (duty.%is_off_duty% or duty.%is_cmp% )
          where (duty.%is_cmp%),
          0);
  
/*
**  FC SH VG parttime freedays must be assigned unreduced in relation
**  nr of qualifying days in period. They must be reduced in relation
**  to parttime changes in month though.  
*/
%ind_req_pt_freedays_with_month_as_two_intervals% =
  /*
  ** Required parttime freedays in 1 month based on  
  ** requirements for relevant parttime factor
  */
  %ind_req_pt_freedays_with_month_as_two_intervals_by_dates%(wop.%start_month_start%, wop.%start_month_end%);

%ind_req_pt_freedays_with_month_as_two_intervals_wop_indep% =
  /*
  ** Required parttime freedays in 1 month based on  
  ** requirements for relevant parttime factor
  */
  let   month_start =  round_down_month(%pp_start%),
        month_end = round_up_month(%pp_start%+00:01);
    %ind_req_pt_freedays_with_month_as_two_intervals_by_dates%(month_start, month_end);
    
export %nr_LA_days% =
  sum(wop(roster), wop.%days%)
  from (current) forwards
  while (wop.%is_pt_freeday%);
  
%nr_LA_days_in_period_cc%(AbsTime start, AbsTime stop) =
  if %cabin_crew% then
    sum(duty(wop), overlap(start, stop, duty.%start_hb%, duty.%end_hb%) / 24:00)
    where(duty.%is_la% and not duty.%is_freeday%)
  else
    0;

export %LA_days_are_scheduled_correct% =
 /*Freedays before LA is checked bye ind_min_freedays_before_LA_days_ALL 
  %required_freedays_before_LA% and */
  %required_consecutive_LA%;
  
export %required_freedays_before_LA% =
  %nr_freedays_before_LA% >= %min_freedays_before_LA%;
  
export %required_consecutive_LA% =
  (crew.%part_time_factor_wop_end% <> 90 or 
  %nr_LA_days% >= %min_consecutive_LA_days%);

%min_consecutive_LA_days% = 
  if crew.%part_time_factor_wop_end% = 90 then
    3
  else 1;

/* FC only variables present for compilation purposes */
export %possible_pt_freedays_in_period%(Abstime start, Abstime stop) =
  if %flight_crew% then
    sum(wop(roster), %possible_wop_pt_freedays_in_period_fc%(start, stop))
      where (wop.%start_hb% < stop and
             default(wop.%rest_end%, wop.%end_hb%) > start)
  else
    sum(wop(roster), %possible_wop_pt_freedays_in_period%(start, stop))
    where ((wop.%is_on_duty% or
            wop.%is_vacation%) and
           wop.%start_hb% < stop and
           default(wop.%rest_end%, wop.%end_hb%) > start);

/*
** After K11, FC freedays after production can be any time-off day, so they
** can be F-days, part-time freedays (sub-set of LA-days) etc.
** A separate rule checks the minimum total F+LA days, so the rule checking
** minimum part-time freedays doesn't need to consider the F-day requirement.
**
** This variable therefore counts the assigned LA-days and also considers any
** empty days as potential LA-days, so that Matador doesn't have any problems
** starting with an empty roster.
*/

%possible_wop_pt_freedays_in_period_fc%(Abstime start, Abstime stop) =
  let next_wop_start = default(next(wop(roster),wop.%start_day%),stop);
  (if wop.%is_pt_freeday% then
     wop.%days_in_period%(start,stop)
   else
     0) +
  (if next_wop_start <> wop.%end_day% + 24:00 and
      wop.%end_day% + 24:00 > start and
      wop.%end_day% + 24:00 < stop then
     (nmin(next_wop_start,stop) - nmax(wop.%end_day% + 24:00,start)) / 24:00
   else
     0);

export %min_freedays_before_LA% = 2;

export %nr_freedays_before_LA% = %nr_before_la%;

%wop_pt_freedays%(Abstime start, Abstime stop) = 
  sum(wop(roster), wop.%days_in_period%(start, stop))
  from (next) forwards
  while (not (wop.%is_on_duty% or
              wop.%is_vacation%) and
         wop.%start_hb% < stop)
  where (wop.%is_pt_freeday%);


%actual_wop_freedays%(Abstime start, Abstime stop) = 
  sum(wop(roster), wop.%days_in_period%(start, stop))
  from (next) forwards
  while (not (wop.%is_on_duty% or
              wop.%is_vacation%) and
         wop.%start_hb% < stop)
  where (wop.%is_freeday% and
         not wop.%is_pt_freeday%);

/*
** The number of parttime freedays after wop is the
** max number of actual LA days present, and virtual
** LA days. As virtual pt freedays we consider empty days
** not reserved for sling freedays.  
*/  

export %possible_wop_pt_freedays_in_period%(Abstime start, Abstime stop) = 
  let min_after_wop = last(duty(wop), %min_required_freedays_after_duty%),
      duty_is_offduty = last(duty(wop), duty.%is_off_duty%),
      min_req_freedays_after_wop = if wop.%is_vacation% 
                                   then
                                        0
                                   else if duty_is_offduty
                                        then   
                                            nmin(min_after_wop,2)
                                   else if not (%flight_crew% and crew.%is_ski%) then
                                     2
                                   else min_after_wop,
      actual_freedays_after_wop = %actual_wop_freedays%(wop.%rest_start_day%+
                                                    24:00*min_req_freedays_after_wop,stop),
      req_freedays_after_wop = if wop.%is_vacation% then 0 else min_req_freedays_after_wop,
      possible_pt_freedays = 
        if %cabin_crew% then
          nmax(0, wop.%freedays_in_period%(start, stop) - 
               nmax(last(duty(wop),%min_required_freedays_after_duty%)))
        else
          nmax(0, wop.%freedays_in_period%(start, stop) - 
               (req_freedays_after_wop + actual_freedays_after_wop)),

      actual_pt_freedays = %wop_pt_freedays%(start, stop);
      
    nmax((possible_pt_freedays/%min_consecutive_la_days%) * %min_consecutive_la_days%, 
         actual_pt_freedays);


/* The number of F-days required before vacation */
table min_freedays_before_VA =
  %flight_crew%, %va_period_6_days_or_shorter%, crew.%is_fc_no%,
  %wop_is_only_summer_vacation% ->
    export %min_before_VA%,
    export %nr_before_VA%;
  
  /* Flight crew */
  true, -    ,  true,  true -> 3, %nr_freedays_before_wop%; 
  true, false,  true, false -> 2, %nr_freedays_before_wop%;
  true, true ,  -   , false -> 0, %nr_freedays_before_wop%;
  true, -    , false,  true -> 0, %nr_freedays_before_wop%;
  true, false, false, false -> 2, %nr_freedays_before_wop%;
  
  /* Cabin crew */
  false,    -,    -,     -  -> 2, %nr_freedays_before_wop%;
  
  -, -, -, - -> 0, 0;
end

%va_period_6_days_or_shorter% =
  system_db_parameters.%k22_fd_0_f_before_short_va%(wop.%start_day%)
  and wop.%is_vacation% and wop.%days% < 7;

export %nr_around_va_wop% =
  %off_duty_days_before_wop% +
  %off_duty_days_after_wop%;

/*
**  Number of F-days after VA and before the next on-duty.
**  NB! Any compensation days after VA should just be ignored
**  E.g VA...../F7S/F/F/Prod.... counts as 2 F-days after VA.
*/

%nr_freedays_after_va% =
  let vacation_end_day = %vacation_end_day%;
  (default(next(wop(chain) where (wop.%is_on_duty% and                                   
                                  not wop.%is_compensation_day% and
                                  wop.%start_day% >= vacation_end_day),
                wop.%start_day%),
           31dec2035) - vacation_end_day) / 24:00 -
  default(sum(wop(chain),%wop_days%)
            from (next where (wop.%start_day% >= vacation_end_day))
            while (wop.%is_off_duty% or
                   wop.%is_compensation_day%)
            where (wop.%is_compensation_day%),
          0);

export %wop_should_have_va_freedays_before% =
    not crew.%is_leased_wop_start% and
    crew.%is_short_haul_pp_start% and
    (%flight_crew% and wop.%in_pp_extended% and (not %wop_is_only_summer_vacation%) or
     %cabin_crew% and wop.%starts_in_pp_extended%) and
    not (crew.%is_skd% and crew.%is_temporary%) and
    wop.%is_vacation% and
    crew.%in_variable_group_wop_start% and
    /* Condition to keep AssignPostOpFreedays from assigning freedays an earlier month. */
    wop.%start_hb% > %pp_start% + 48:00;

%nr_before_la% =
  if not wop.%is_pt_freeday% then
        0
  else
    default(%nr_before%(%la_start_day%),100);

export %nr_before_wop% =
    %nr_before%(wop.%start_day%);

/*** Find LA start day ***/

%la_start_day% =
    prev(wop(chain), next(wop(chain), wop.%start_day%))
         where(not %consecutive_pt_freeday%);

%consecutive_pt_freeday% =
    wop.%is_pt_freeday% and 
    wop.%end_day% + 24:00 = next(wop(chain), wop.%start_day%); 

/*******************************************************************************
** BEGIN:
** Find number of freedays before vacation/part time freedays (ccr).
** Empty days count as freedays.
*/

export %nr_before%(Abstime before_time) =
    nmax(0, (before_time - %freeday_start_day_before_va%(before_time)) / 24:00);

%freeday_start_day_before_va%(Abstime before_time) =
    default(last(duty(chain), %freeday_start_day%(before_time))
            where(duty.%start_hb% < before_time),
            01Jan1986);
            
%freeday_start_day%(Abstime before_time) =
    last(duty(chain), duty.%end_day% + 24:00)
         from (current)
         where (not %is_freeday_or_bought_freeday%);

%is_freeday_or_bought_freeday% =
    duty.%is_freeday% or %is_bought_freeday%(duty.%start_day%);

%is_bought_freeday%(Abstime start_day) =
    bought_days.%bought_type_days_in_period%("F", start_day, start_day + 24:00) = 1;

export %nr_before_trip% =
  default((trip.%start_day% - 
          prev(trip(roster), trip.%rest_start_day%) where (trip.%is_on_duty%))
          / 24:00, 100);    
/*
** END:
** Find number of freedays before vacation (ccr).
*******************************************************************************/

export %wop_is_vacation_in_summer_period% = 
  %is_wop_vacation% and
  %vacation_end_day% >= %summer_start% and
  %vacation_start_day% <= %summer_end%;
  
export %wop_is_summer_vacation% =
  %wop_is_vacation_in_summer_period% and
  %vacation_length% >= %length_of_summer_vacation%;
 
%wop_is_only_summer_vacation% =
    %wop_is_summer_vacation% and wop.%start_hb% >= %summer_start%;

export %wop_is_vacation_starting_in_summer_period% =
    %is_wop_vacation%
    and wop.%start_day% >= %summer_start%
    and wop.%start_day% <= %summer_end%;
    
/*******************************************************************************
** BEGIN: Find start/end/length of vacation.
** Treat bought va days (also with 'bought production') as part of vacation.
*/

export %vacation_length% =
    (%vacation_end_day% 
    - %vacation_start_day%) / 24:00;

export %vacation_start_day% =
 if crew.%is_fc_no% then
   %vacation_start_skd_skn_sks%
 else if crew.%is_fc_dk% then
   %vacation_start_skd_skn_sks%
 else if crew.%is_fc_se% and 
 crew.%in_variable_group_wop_start% and 
 crew.%part_time_factor_wop_start% < 100 then
   %vacation_start_vg_pt_sks%  
 else if crew.%is_fc_se% then 
    %vacation_start_skd_skn_sks%
 else
   wop.%start_day%;

%vacation_end_day% =
 if crew.%is_fc_no% then
   %vacation_end_skd_skn_sks%
 else if crew.%is_fc_dk% then
   %vacation_end_skd_skn_sks%
 else if crew.%is_fc_se% and
 crew.%in_variable_group_wop_start% and
 crew.%part_time_factor_wop_start% < 100 then
   %vacation_end_vg_pt_sks%
 else if crew.%is_fc_se% then 
    %vacation_end_skd_skn_sks%
 else
  wop.%end_day% + 24:00;

/*
** A SKN summer vacation period consists not only of the VA days, but includes
** any other activities that are allowed/required before/after VA, e.g. F.days,
** LA-days etc. These will be in separate wops, so it is necessary to check 
** for touching wops to find the start and end of the vacation period.
**
** The following variables assume that the current wop is the VA wop. 
*/
%vacation_start_skd_skn_sks% = 
  default(prev(wop(roster), next(wop(roster),wop.%start_day%)) 
            where (%wop_ends_summer_vacation_skn_sks_bwd%), 
          last(wop(roster),wop.%start_day%));

%wop_ends_summer_vacation_skn_sks_bwd% =
  not wop.%consecutive_wops_fw% or
  not (%activity_is_allowed_around_summer_vacation% or
       wop.%is_vacation%);
   
%vacation_end_skd_skn_sks% =
  default(next(wop(roster), prev(wop(roster), wop.%end_day% + 24:00)) 
            where (%wop_ends_summer_vacation_skn_sks_fwd%),
          last(wop(roster),wop.%end_day% + 24:00));
   
%wop_ends_summer_vacation_skn_sks_fwd% =
  not wop.%consecutive_wops_bw% or
  not (%activity_is_allowed_around_summer_vacation% or
       wop.%is_vacation%);
   
%vacation_start_vg_pt_sks% = 
  wop.%start_day% - default(prev(wop(roster), if wop.%consecutive_wops_fw% then %_loa_days% else 0) * 24:00, 0:00);
%vacation_end_vg_pt_sks% = 
  wop.%end_day% + 24:00 + default(next(wop(roster), if wop.%consecutive_wops_bw% then %_loa_days% else 0) * 24:00, 0:00);
  
%_loa_days% =
  if wop.%is_loa% or wop.%is_la% then 
    wop.%days% 
  else 
    0;

%start_time_day_including_preceding_bought_va_days%(Abstime start_t) =
    first(times(%bought_days_limit%), start_t - (%times_index_0%-1)*24:00)
          where (not %is_bought_va_day%(start_t - %times_index_0%*24:00));

%end_time_day_including_following_bought_va_days%(Abstime end_t) =
    first(times(%bought_days_limit%), end_t + (%times_index_0%-1)*24:00)
          where (not %is_bought_va_day%(end_t + (%times_index_0%-1)*24:00));

%bought_days_limit% = 16;

%is_wop_vacation_connected_forwards% =
    %is_wop_vacation% and
    %is_cxn_time_in_bought_va_period%;

%is_wop_vacation_connected_backwards% =
    %is_wop_vacation% and
    prev(wop(chain), %is_cxn_time_in_bought_va_period%);

export %is_wop_vacation% =
    wop.%is_vacation% or %is_wop_in_bought_va_period%;

%is_wop_in_bought_va_period% =
    wop.%days% = bought_days.%bought_type_days_in_period%("VA", 
                                                          wop.%start_day%, 
                                                          wop.%end_day% + 24:00);
%is_cxn_time_in_bought_va_period% =
    %cxn_time_in_days% 
    = bought_days.%bought_type_days_in_period%("VA", 
                                               wop.%end_day% + 24:00, 
                                               next(wop(chain), wop.%start_day%));

%cxn_time_in_days% =
    (next(wop(chain), wop.%start_day%) - (wop.%end_day% + 24:00)) / 24:00;

%is_bought_va_day%(Abstime start_of_day) =
    bought_days.%bought_type_days_in_period%("VA", 
                                             start_of_day, 
                                             start_of_day + 24:00) = 1;

export %summer_start% = 
  if %flight_crew% then
    %summer_start_FC%
  else
    %summer_start_CC%;

export %summer_end% = 
  if %flight_crew% then
    %summer_end_FC%
  else
    %summer_end_CC%;

export %length_of_summer_vacation% =
  if %flight_crew% then
    %length_of_summer_vacation_FC%
  else
    %length_of_summer_vacation_NKF_CC%;

/*
** END: Find start/end/length of vacation.
*******************************************************************************/

export %next_not_freedays_wop_is_summer_vacation% =
  default(next(wop(roster), %wop_is_summer_vacation%)
          where (wop.%is_on_duty% or wop.%is_vacation%),
  false);
  
export %next_not_freedays_wop_is_summer_vacation_skn% =
  default(next(wop(roster), %wop_is_only_summer_vacation%)
          where (not %activity_is_allowed_around_summer_vacation%),
  false);

/*
** VA will be preceded by F-days and maybe LA, i.e. there may be 1 or more wops
** before the VA wop. This variable is used when checking latest check-out
** before VA, and checks that there are no empty days between the production
** day and the VA wop. If there are, then the check-out must not be considered
** to be check-out before VA.
*/

export %wop_is_followed_by_summer_vacation_skn% =
  %next_not_freedays_wop_is_summer_vacation_skn% and
  default(
    all(wop(roster),wop.%end_day% + 24:00 = next(wop(roster),wop.%start_day%))
      from (current)
      while (not %wop_is_only_summer_vacation%),
  false);  



/* Variables specifying requirements of summer vacations. 
   Redefined in freedays_cct
*/
%activity_is_allowed_around_summer_vacation% = 
   %_activity_is_allowed_around_summer_vacation%; 

%_activity_is_allowed_around_summer_vacation% = 
    if crew.%is_fc_se% then %is_bought_vacation%
    else if  crew.%is_fc_dk% then
        wop.%is_loa% or wop.%is_la% or %is_bought_vacation%
    else (wop.%is_off_duty% and not wop.%is_vacation%) 
        or wop.%is_compensation_day%
        or %is_bought_vacation%;
        
%summer_start_FC% = add_months(%year_start%, 5);
%summer_end_FC% = add_months(%year_start%, 8);
%length_of_summer_vacation_FC% =
  if crew.%in_variable_group_wop_start% and
     crew.%part_time_factor_wop_start% < 100 then
       (%vacation_days_vg_part_time_FC% + %LA_days_around_vacation_vg_pt_FC%)
  else if %freedays_surrounding_summer_vacation_group_at_date%(wop.%start_day%) then
    18
  else if crew.%is_ski% then
    17
  else if crew.%is_fc_no% then
    18 
  else if crew.%is_fc_dk% then
    17
  else if crew.%is_fc_se% then
    17
  else
    17; 


/* see rule rules_indust_ccr.ind_min_freedays_surrouding_summer_vacation  */
/* TODO: when Cimber is removed, this should be valid for all FD */
export %freedays_surrounding_summer_vacation_group_at_date%(Abstime date) =
    let start_day = round_down(date, 24:00);

    crew.%has_agmt_group_ski_fd_at_date%(start_day) or
    crew.%has_agmt_group_skn_fd_at_date%(start_day) or
    crew.%has_agmt_group_skd_fd_at_date%(start_day) or
    model_crew.%has_agmt_qual_sks_fd_oth_at_date%(crew.%id%, start_day);


export %is_summer_vacation%(Bool co) =
       let
        start_day = wop.%start_day%,
        day_for_01Jan = base_calendar.%day_from_date%(start_day,1,1),
        day_for_01Jun = base_calendar.%day_from_date%(start_day,6,1),
        day_for_01Sep = base_calendar.%day_from_date%(start_day,9,1),
        day_for_05Sep = base_calendar.%day_from_date%(start_day,9,5),
	      w= base_calendar.%wd_from_abs%(day_for_01Jan),
          Sun_jan = base_calendar.%first_wday_from_date%(day_for_01jan,7),
          Vacation_start_week  = if (w = 1 or w = 2 or w = 3 or w = 4) then base_calendar.%week_from_date%(Sun_jan,22)
                                else base_calendar.%week_from_date%(Sun_jan,23),
          Vacation_end_week   =   if(w = 1 or w = 2 or w = 3 or w = 4) then base_calendar.%week_from_date%(Sun_jan,36)
                                 else base_calendar.%week_from_date%(Sun_jan,37),
	      V_start_day = base_calendar.%first_wday_from_date%(Vacation_start_week,1),
          V_end_day = round_up(base_calendar.%first_wday_from_date%(Vacation_end_week,7) + 0:01, 24:00),
         reqired_days = model_crew.%no_of_VA_days%(crew.%id%, start_day),
         vacation_days = %count_summer_vacation_days_from_date%(start_day),
         end_day = start_day + vacation_days * 24:00;
         
         vacation_days >= reqired_days and
         (if crew.%has_agmt_group_skn_cc_at_date%(start_day)
          then start_day >= V_start_day and 
           end_day <= V_end_day 
          else
          start_day >= day_for_01Jun and
         (if not co then
          end_day <= day_for_01Sep
          else 
         /* For late check-out 04 sep is counted as end_day */
           end_day <= day_for_05Sep));
              
        
export %count_summer_vacation_days_from_date%(Abstime start) =
    count(times(30))
    while (%is_summer_vacation_day_at_date%(round_down(start + ((%times_index_0% - 1) * 24:00), 24:00)));

%is_summer_vacation_day_at_date%(Abstime date_i) =
  let date = round_down(date_i, 24:00);
  any(leg(chain), overlap(date, date + 23:59, leg.%start_hb%, leg.%end_hb%) > 0:00)
  where (%leg_in_summer_vacation_codes%);


export %leg_in_summer_vacation_codes% =
    leg.%in_summer_vacation_codes%;

export %duty_is_LOA100% =
    crew.%crew_contract_part_time_factor_at_date%(duty.%start_day%) = 100
    and %duty_is_LOA%;


export %duty_is_LOA% =
   first(leg(duty), leg.%is_loa%);


/************************************************
* This table is used for FD VG part time crew,
* to identify the number of VA and LA days
* which qualifies as summer vacation in 
* connection to the rule of min number of freedays
*************************************************/

table summer_VA_and_LA_days_vg_pt_FC =
  crew.%is_ski%,
  crew.%is_fc_no%,
  crew.%is_fc_dk%,
  crew.%is_fc_se%,
  crew.%part_time_factor_wop_start% ->
    %vacation_days_vg_part_time_FC%,
    %LA_days_around_vacation_vg_pt_FC%;
  
  /* pt factor -> VA days, LA days */
  /* SKI */
  true, false, false, false, 75 -> 13, 4;
  /* SKN */
  false, true, false, false, 83 -> 14, 4;
  false, true, false, false, 75 -> 14, 4;
  false, true, false, false, 50 -> 9, 9;
  /* SKD */
  false, false, true, false, 75 -> 13, 4;
  false, false, true, false, 50 -> 9, 8;
  /* SKS */
  false, false, false, true, 75 -> 13, 4;
  false, false, false, true, 50 -> 9, 8;
  -, -, -, -, - -> 17, 0;
end

%summer_start_CC% = add_months(%year_start%, 5);
%summer_end_CC% = %15_sep_this_year%;
%15_sep_this_year% = add_months(%year_start%, 8) + 14*24:00;
%year_start% = round_down_year(wop.%start_utc%);
%length_of_summer_vacation_NKF_CC% = 16;

/***************************************************************************
 * Section 10: Check in/out times around free weekend, vacation, freedays, etc.
 **************************************************************************/
/*
 * Additional variables indicating if a wop is followed or preceded by
 * vacation or 2 freedays. In these cases, the check-in/out times need 
 * to be checked.
 */
 
export %has_empty_days_before_wop% = 
  (wop.%start_utc% - prev(wop(roster), wop.%end_utc%))/24:00 > 0;
 
export %prev_not_freedays_wop_was_vacation% = 
  default(prev(wop(roster), wop.%is_vacation%)
          where (wop.%is_on_duty% or wop.%is_vacation%),
  false);

export %prev_wop_is_vacation_with_no_freedays% = 
  default(prev(wop(roster), wop.%is_vacation% and wop.%freedays% = 0),
  false);

%prev_onduty_wop_followed_by_vacation% = 
  default(prev(wop(roster),%next_not_freedays_wop_is_vacation%)
          where (wop.%is_on_duty%),
  false);
  
%prev_onduty_wop_followed_by_summer_vacation% = 
  default(prev(wop(roster),%next_not_freedays_wop_is_summer_vacation%)
          where (wop.%is_on_duty%),
  false);

export %prev_not_freedays_wop_was_summer_vacation% =
  %prev_not_freedays_wop_was_vacation% and 
  prev(wop(roster), %next_not_freedays_wop_is_summer_vacation%)
  where (wop.%is_on_duty%);

export %prev_not_freedays_wop_was_summer_vacation_skn% =
  default(prev(wop(roster), %wop_is_summer_vacation%)
          where (not %activity_is_allowed_around_summer_vacation%),
  false);

export %wop_followed_by_2_freedays% = 
  default(wop.%freedays% = 2 and 
          not %next_not_freedays_wop_is_vacation%,
  false);

/* checks if the next wop is vacation */
export %next_not_freedays_wop_is_vacation% = 
  default(next(wop(roster), wop.%is_vacation%)
          where (not (wop.%is_freeday% or wop.%is_illness%)),
  false);

/*
** For SKD CC, CMP days should be ignored when checking if next wop is VA
** so the result is TRUE if production is followed by CMP days and then VA.
*/
%next_not_freedays_wop_is_vacation_skd_cc% = 
  default(next(wop(roster), wop.%is_vacation%)
          where (not wop.%is_freeday% and
                 not (%cabin_crew% and crew.%is_skd% and
                      wop.%is_compensation_day%)),
  false);

export %wop_after_2_freedays% =
  default(prev(wop(roster), wop.%freedays% = 2)
          where (not wop.%is_freeday%), 
  false);
  
export %wop_after_4_freedays% = 
  default(prev(wop(roster), wop.%freedays% >= 4)
          where (not wop.%is_freeday%) and
          prev(wop(chain), wop.%end_day% + 24:00) = wop.%start_day%, 
  false);
  
export %vacation_days% = 
  prev(wop(roster),wop.%days%) 
  where (wop.%is_vacation% and wop.%start_hb% >= %freeday_block_start%); 
  
%freeday_block_start% = 
  default(prev(wop(roster), next(wop(roster), wop.%start_hb%)) 
          where (not (wop.%is_freeday% or wop.%is_vacation%)),
  wop.%start_hb%);   
  
export %following_vacation_days% = 
  next(wop(roster),wop.%days%) 
  where (wop.%is_vacation%);

/****************************************************************
 * Section 13: Free weekends
 ***************************************************************/
/* 
** Basic definitions 
*/

/* Agreement:
 *   FC 1:12, 1:18.2.5d, SKI K06 ???
 *   CAU J.1.2c, J.2.1.5
 *   SCCA H.1.4a, H.2.5
 *   NKF 8 
 *   FD: K22, SKCMS-3067
 */


/****************************************************
** Free weekend code - Main chain traversers
**
** Accumulation:
**   Find the last free weekend in the following
**   period (30 day interval). If not found then
**   find the first free weekend after that period.
**
*/


/* The 'chain_' prefix is used since
** variable is an attribute of a chain.
*/
export %chain_last_free_weekend_in_period%(Abstime start_period, Abstime end_period) =
    if %chain_last_free_weekend_before_date%(end_period) < start_period then
        void_abstime
    else
        %chain_last_free_weekend_before_date%(end_period);

export %chain_first_free_weekend_after_date%(Abstime date) =
    if %base_case_first_weekend_after_date_is_free%(date) then
        %base_case_first_weekend_after_date%(date)
    else
        default(first(trip(chain), %start_of_following_free_weekend_after_date%(date))
                      where(not trip.%is_allowed_on_free_weekend% and
                            %trip_is_followed_by_free_weekend_after_date%(date)),
                %pp_end% + 999:00);

/* NB: Finding a free weekend starts with searching backwards in
** time from a specific point, i.e., finding the last
** free weekend before a date. Therefore this function needs
** to deal with the 'base case'.
*/
export %chain_last_free_weekend_before_date%(Abstime date) =
  if %base_case_last_weekend_before_date_is_free%(date) then
    nmax(%start_of_free_weekend_after_last_wop%,
         %last_weekend_before_date_start%(date))
  else
    default(last(trip(chain), %start_of_preceding_free_weekend_before_date%(date))
            where(not trip.%is_allowed_on_free_weekend% and
                  %trip_is_preceded_by_free_weekend_before_date%(date)),
            01Jan1986);

%last_weekend_before_date_start%(AbsTime date) =
    let weekend = min(times(%free_we_interval_max_number_of_types%),
        (round_down_week(date) + last(wop(chain), %free_we_start_tow%(%times_index_0%)) where(not wop.%is_allowed_on_free_weekend%)));
    if weekend < date then
        weekend
    else
        weekend - 7 * 24:00;


/**************************************************************
** Free weekend code - Main chain traversers (base case)
**
** This sub-section deals with the initial search
** done by the main chain traversers. If there exist
** a free weekend before (after) the given date and after (before) 
** the last (first) 'valid' wop, then this code will catch it.
** A valid wop is a wop that is not allowed on a free weekend.
*/

%base_case_first_weekend_after_date_is_free_corrected%(Abstime date) =
    let weekend_start_time = %base_case_first_weekend_after_date%(date);
    %first_regular_weekend_end_time_after_date%(date) <
    default(first(trip(chain), %start_hb_free_we%)
            where(trip.%end_hb% > weekend_start_time
                  and (not trip.%is_allowed_on_free_weekend%) ),
            %pp_end% + 999:00);

/* a thorough test should be made: maybe
 base_case_first_weekend_after_date_is_free_corrected should be used instead */
%base_case_first_weekend_after_date_is_free%(Abstime date) =
    %first_regular_weekend_end_time_after_date%(date) <
    default(first(trip(chain), %start_hb_free_we%)
            where(not trip.%is_allowed_on_free_weekend%),
            %pp_end% + 999:00);

%base_case_last_weekend_before_date_is_free%(Abstime date) =
    %start_of_free_weekend_after_last_wop% < date;

export %base_case_first_weekend_after_date%(Abstime date) =
    round_up_week(date - %free_we_start_tow_regularly% + 0:01)
    + %free_we_start_tow_regularly%;

export %base_case_last_weekend_start_date%(Abstime date) =
    if %week_of_start_of_free_weekend_after_last_wop% =
       %week_of_last_regular_weekend_start_time_before_date%(date)
    then
        %start_of_free_weekend_after_last_wop%
    else
        %last_regular_weekend_start_time_before_date%(date);
    
%week_of_start_of_free_weekend_after_last_wop% =
    round_down_week(%start_of_free_weekend_after_last_wop%);

%week_of_last_regular_weekend_start_time_before_date%(Abstime date) =
    round_down_week(%last_regular_weekend_start_time_before_date%(date));

%start_of_free_weekend_after_last_wop% =
    default(last(trip(chain), %next_possible_free_weekend_start%)
            where(not trip.%is_allowed_on_free_weekend%),
            01Jan1986);

/* Subtract 0:01 because we seek a weekend BEFORE the given date */
%last_regular_weekend_start_time_before_date%(Abstime date) =
    round_down_week(date - %free_we_start_tow_regularly% - 0:01)
    + %free_we_start_tow_regularly%;

%first_regular_weekend_end_time_after_date%(Abstime date) =
    round_up_week(date - %free_we_start_tow_regularly% + 0:01)
    + %week_hours% 
    + %free_we_end_tow_regularly%;

/************************************
** Free weekend code - Final search
*/

export %start_of_following_free_weekend_after_date%(Abstime date) =
    first(times(10), %next_possible_free_weekend_start% + %times_next_week%)
       where(date <= %next_possible_free_weekend_start% + %times_next_week%);

%start_of_preceding_free_weekend_before_date%(Abstime date) =
    first(times(10), %prev_possible_free_weekend_start% - %times_next_week%)
        where(date > %prev_possible_free_weekend_start% - %times_next_week%);

%times_next_week% = 
    (%times_index_0% - 1) * %week_hours%;

/***************************************************************
** Free weekend code - Search for free weekends after (before)
**                     the previous (next) wop.
**
** If there exists many free weekends from a wop to
** the next wop, then the first (last) free weekend in-between
** is referred to as the next (last) free weekend.
*/

export %trip_is_followed_by_free_weekend% =
    %trip_is_followed_by_free_weekend_after_date%(01Jan1986);

%trip_is_followed_by_free_weekend_after_date%(Abstime date) = 
    %last_possible_free_weekend_before_next_trip_is_free_and_after_date%(date);

%trip_is_preceded_by_free_weekend_before_date%(Abstime date) =
    %first_possible_free_weekend_after_prev_wop_is_free_and_before_date%(date);

%last_possible_free_weekend_before_next_trip_is_free_and_after_date%(Abstime date) =
    default(next(trip(chain), date <= %prev_possible_free_weekend_start% and
                             %prev_trip_end_hb_free_we% <= %prev_possible_free_weekend_start% and
                             /* Greenland special case check */
                             %prev_possible_free_weekend_end% <= %start_hb_free_we%)
                 where(not trip.%is_allowed_on_free_weekend%),
            true);

%first_possible_free_weekend_after_prev_wop_is_free_and_before_date%(Abstime date) =
    default(prev(trip(chain), %next_possible_free_weekend_start% < date and
                             %next_possible_free_weekend_end% <= %next_trip_start_hb_free_we%)
                 where(not trip.%is_allowed_on_free_weekend%),
            true);

/* For e.g. SKN_CC and all FD SK blank day BL should not be part of the free weekend.
** Controlled in %is_allowed_on_free_weekend% variable
** Only for crew that do not have 3 whole calendar days defined as free weekend
** it is possible to have blank day BL in start and end day of free weekend */
%prev_trip_end_hb_free_we% =
    default(prev(trip(chain), %end_hb_free_we%)
                 where(not trip.%is_allowed_on_free_weekend% or ((crew.%has_agmt_group_sks_cc% or crew.%has_agmt_group_skd_cc%) and trip.%is_blank_day%)),
            01Jan1986);

%next_trip_start_hb_free_we% = 
    default(next(trip(chain), %start_hb_free_we%)
                 where(not trip.%is_allowed_on_free_weekend% or ((crew.%has_agmt_group_sks_cc% or crew.%has_agmt_group_skd_cc%) and trip.%is_blank_day%)),
            %pp_end% + 999:00);


/****************************************************
**  The last free weekend in prev month
**  The first free weekend in current pp
*/

export %last_fwe_in_prev_month% =
    accumulators.%last_free_weekend%(%pp_start%);

export %first_fwe_in_current_pp% =
    let
    calendar_1_we = %base_case_first_weekend_after_date%(%pp_start%),
    calendar_2_we = %base_case_first_weekend_after_date%(calendar_1_we),
    calendar_3_we = %base_case_first_weekend_after_date%(calendar_2_we),
    calendar_4_we = %base_case_first_weekend_after_date%(calendar_3_we),
    calendar_5_we = %base_case_first_weekend_after_date%(calendar_4_we);

    if %base_case_first_weekend_after_date_is_free_corrected%(%pp_start%) and calendar_1_we < %pp_end% then
        calendar_1_we
    else if %base_case_first_weekend_after_date_is_free_corrected%(calendar_1_we) and calendar_2_we < %pp_end% then
        calendar_2_we
    else if %base_case_first_weekend_after_date_is_free_corrected%(calendar_2_we) and calendar_3_we < %pp_end% then
        calendar_3_we
    else if %base_case_first_weekend_after_date_is_free_corrected%(calendar_3_we) and calendar_4_we < %pp_end% then
        calendar_4_we
    else if %base_case_first_weekend_after_date_is_free_corrected%(calendar_4_we) and calendar_5_we < %pp_end% then
        calendar_5_we
    else
        void_abstime;

/****************************************************
**  Free weekend code - Greenland special case
**
**  A free weekend may start/end at different times
**  if the preceding wop has touched Greenland.
**
**  If a weekend is not special it is considered
**  'regular'.
*/

%prev_possible_free_weekend_start% =
  default(%_prev_possible_free_weekend_start%,
               %prev_possible_free_weekend_start_regularly%);

%prev_possible_free_weekend_end% =
    default(%_prev_possible_free_weekend_end%,
                %prev_possible_free_weekend_end_regularly%);

%_prev_possible_free_weekend_start% =
    if %exactly_one_free_weekend_backwards% then
        %prev_trip_next_possible_free_weekend_start%
    else
        %prev_possible_free_weekend_start_regularly%;

%_prev_possible_free_weekend_end% =
    if %exactly_one_free_weekend_backwards% then
        %prev_trip_next_possible_free_weekend_end%
    else
        %prev_possible_free_weekend_end_regularly%;

%exactly_one_free_weekend_backwards% =
    %week_of_prev_possible_weekend_start% = %week_of_prev_trip_next_possible_weekend_start%;

%week_of_prev_possible_weekend_start% =
    round_down_week(%prev_trip_next_possible_free_weekend_start%); 

%week_of_prev_trip_next_possible_weekend_start% =
    round_down_week(%prev_possible_free_weekend_start_regularly%);

%prev_trip_next_possible_free_weekend_start% =
    prev(trip(chain), %next_possible_free_weekend_start%)
    where(not trip.%is_allowed_on_free_weekend%);

%prev_trip_next_possible_free_weekend_end% =
    prev(trip(chain), %next_possible_free_weekend_end%)
    where(not trip.%is_allowed_on_free_weekend%);

%free_we_start_tow_regularly% =
    min(times(%free_we_interval_max_number_of_types%),
        first(wop(chain), %free_we_start_tow%(%times_index_0%))
        where(not (%wop_has_single_day_greenland% or
            %wop_has_double_day_greenland%)));

%free_we_end_tow_regularly% =
    min(times(%free_we_interval_max_number_of_types%),
        first(wop(chain), %free_we_end_tow%(%times_index_0%))
        where(not (%wop_has_single_day_greenland% or
            %wop_has_double_day_greenland%)));

/*******************************************************
** Free weekend code - next/prev possible free weekends
*/

export %next_possible_free_weekend_start% =
    min(times(%free_we_interval_max_number_of_types%),
            round_up_week(%end_hb_free_we% - %free_we_start_tow%(%times_index_0%))
            + %free_we_start_tow%(%times_index_0%)
    );

%next_possible_free_weekend_end% =
        %next_possible_free_weekend_start% + %free_we_length%;

%prev_possible_free_weekend_start_regularly% =
    round_down_week(%start_hb_free_we% - %free_we_end_tow_regularly% - %week_hours%)
    + %free_we_start_tow_regularly%;

%prev_possible_free_weekend_end_regularly% =
    round_down_week(%start_hb_free_we% - %free_we_end_tow_regularly%)
    + %free_we_end_tow_regularly%;


/****************************************************
** Free weekend code - Wop end/start home base time
**
** Special care is taken to wops that start or begin
** with blank days, bought days or other trips that
** are allowed on free weekends.
*/

/* For e.g. both SKN_CC and all FD SK blank day BL should not be part of the free weekend.
** Controlled in %is_allowed_on_free_weekend% variable.
** Only for SAS crew that do not have 3 whole calendar days defined as free weekend
** it is possible to have blank day BL in start and end day of free weekend */

%start_hb_free_we% =
  if ((crew.%has_agmt_group_sks_cc% or crew.%has_agmt_group_skd_cc%) and trip.%is_blank_day%) or trip.%is_allowed_on_free_weekend% or
  default(trip.%is_F36% and fundamental.%day_of_week%(trip.%start_hb%) = 1, false) then
      trip.%start_hb% + %free_we_earliest_end%
  else if (crew.%k4exng_cc_sp5_1_valid%(pp.%start_month%) or
           %flight_crew%) and trip.%is_freeday% then
      %free_we_earliest_end% + first(duty(trip),duty.%start_hb%) where (not duty.%is_bought%)
  else
      first(duty(trip),duty.%start_hb%) where (not duty.%is_bought%);

%end_hb_free_we% =
    if ((crew.%has_agmt_group_sks_cc% or crew.%has_agmt_group_skd_cc%) and trip.%is_blank_day%) or trip.%is_allowed_on_free_weekend% then
        trip.%end_scheduled_hb% - 24:00 + %free_we_latest_start%
    else if (crew.%k4exng_cc_sp5_1_valid%(pp.%start_month%) or
             %flight_crew%) and trip.%is_freeday% then
        %free_we_latest_start% - 24:00 +
        last(duty(trip), duty.%end_scheduled_hb%) where (not duty.%is_bought%)
    else
        last(duty(trip), duty.%end_scheduled_hb%) where (not duty.%is_bought%);

/***********************************************/

/* Wrapper until crew.region is defined as SKI */
%crew_region% =
  if %flight_crew% and crew.%is_long_haul_pp_start% then "SKI" else crew.%region%;

/*table free_we_fundamentals =
  %flight_crew% ->
    export %free_we_period_is_month%,
    export %free_we_period_start%,
    export %free_we_period_end%;
  / * Flight crew * /
  true   -> true, %_free_we_period_start%(7), %_free_we_period_end%(7);
  / * Cabin crew * /
  false  -> true, %_free_we_period_start%(7), %_free_we_period_end%(7);
end
*/

export %free_weekend_max_days% = 30; /* SAS QA FD only */

/*
%_free_we_period_start_rolling% =
    %next_possible_free_weekend_start% - %free_weekend_max_days% * 24:00;
*/

/* Weekday is the day of the weekend that should be included for a free weekend
** If weekday is in PP we return Thursday before %pp_start% otherwise 
** Thursday after %pp_start% 
**
** NB! Since Tracking is not setting %pp_start% to start of month
** we need to round_it_down before use */

%_free_we_period_start_by_date%(Int weekday, Abstime d) =
  if base_calendar.%wd_from_abs%(d) <= weekday then
    round_down_week(d) + 3 * 24:00
  else
    round_up_week(d) + 3 * 24:00;

/* old functionality, using pp_start and fundamental */
%_free_we_period_start%(Int weekday) =
  %_free_we_period_start_by_date%(weekday, fundamental.%publ_period_start%);

/* new functionality, using trip start and calendar_base  */
/*%_free_we_period_start_by_trip%(Int weekday) =
  %_free_we_period_start_by_date%(weekday, trip.%start_month_start%);*/

/* Weekday is the day of the weekend that should be included for a free weekend 
** If weekend is included in month we return following Thursday
** otherwise previous Thursday */
/*
** Clarification: This variable is to return the last day before the beginning of
** the first weekend not in the free weekend period.
** If this weekend is an ordinary weekend we return the Thursday before, but if it
** is a special weekend (only available as an option for weekend period month) then
** we return the day before the special weekend.
*/
%_free_we_period_end_by_date%(Int weekday, Abstime d) =
  let x_month_end = round_up_month(d + 0:01),
      last_ordinary_we =
        if base_calendar.%wd_from_abs%(x_month_end) <= weekday then
          round_down_week(x_month_end) + 4 * 24:00
        else
          round_up_week(x_month_end) + 4 * 24:00;
  last_ordinary_we;

%_free_we_period_end%(Int weekday) =
  %_free_we_period_end_by_date%(weekday, fundamental.%publ_period_start%);


/*
*   This function consider belonging weeks based on Saturdays in the month.
*   This function checks all days in month for an activity; so this is good to use for activities that are specific for
*   weekend free like F4. F4 only happen in weekend so this function does not check the days of week.
*/
export %is_activity_on_month%(abstime activity_start, string activity_type_string) =
    let this_month_start = %free_weekend_month_start_sk%(activity_start),
        this_month_end = %free_weekend_month_end_sk%(activity_start);
    any(times((this_month_end - this_month_start) / 24:00), /* Calculate number of days in month to iterate over */
        roster.%activities_in_period%((this_month_start + ((%times_index_0% - 1) * 24:00)),(this_month_start + 24:01 + ((%times_index_0% - 1) * 24:00)), activity_type_string)>0);


/*
*   These function consider belonging weeks based on Saturdays in the month.
*   Only for SAS crew that have Saturdays and Sundays as weekend free
*   =======================================================================
*/

export %free_fs_weekend_month_start_skn_nkf%(Abstime leg_start)=
   let this_month_start = round_down_month(leg_start),
       day_of_week_leg = fundamental.%day_of_week%(this_month_start);
  if day_of_week_leg = 7 then
    this_month_start - 24:00
  else
    this_month_start;

export %free_fs_weekend_month_end_skn_nkf%(abstime leg_end) =
    let this_month_end = round_up_month(leg_end)-0:01;
    if fundamental.%day_of_week%(this_month_end)=6 then
       this_month_end - 24:00    
    else
        this_month_end;
  
export %free_weekend_month_start_sk%(abstime leg_start) =
    let this_month_start = round_down_month(leg_start),
        day_of_week_leg = fundamental.%day_of_week%(leg_start);
    if day_of_week_leg = 6 and round_up_month(leg_start) - leg_start <= 24:00 then
        round_up_month(leg_start) - 24:00
    else if day_of_week_leg = 7 and leg_start - this_month_start <= 24:00 then
        this_month_start - 24:00
    else if fundamental.%day_of_week%(this_month_start) = 7 then
        this_month_start - 24:00
    else
        this_month_start;

export %free_weekend_month_end_sk%(abstime leg_end) =
    let this_month_end = round_up_month(leg_end);
    if fundamental.%day_of_week%(leg_end) = 6 and this_month_end - leg_end <= 24:00 then
        round_up_month(leg_end + 24:01)
    else if fundamental.%day_of_week%(this_month_end) = 7 then
        this_month_end - 24:00
    else
        this_month_end;

%_free_weekend_month_first_weekend_start_sk%(abstime leg_start) =
    let this_month_start = %free_weekend_month_start_sk%(leg_start);
    (this_month_start - time_of_week(this_month_start)) + 120:00;
/*
*   =======================================================================
*/


/*
*   =======================================================================
*   =======================================================================
*   This function count number of weekend frees that have an acceptable activity on that free weekend
*   Note: Empty roster would NOT be considered here as weekend free with activity
*         (Empty roster on weekend can be a free weekend but they are not counted here!!!)
*         Only for SK crew who have saturday and sunday as free weekend.
*   These functions are very specific to FW Interbids requests.( used in: rules_indust_ccr.ind_fw_can_be_granted_SK_FD)
*/
export %num_free_weekend_with_activities_monthly_sk%(abstime activity_start) =
    %num_free_weekend_with_activity_monthly_sk%(activity_start, "", false);

export %num_free_weekend_with_activity_monthly_sk%(abstime activity_start, string activity, bool activity_group) =
    let first_weekend = %_free_weekend_month_first_weekend_start_sk%(activity_start-0:01),
        this_month_end = %free_weekend_month_end_sk%(activity_start-0:01);
    sum(times(5),1) /* Max number of weekend in a month */
        where((%_free_weekend_specific_activity_in_period%(first_weekend + ((%times_index_0% - 1)*168:00) - 24:00 + %free_we_latest_start%
                ,first_weekend + 48:00 + ((%times_index_0% - 1)*168:00) + %free_we_earliest_end% , activity, activity_group))
            and this_month_end >= first_weekend + 48:00 + ((%times_index_0% - 1)*168:00));

%_free_weekend_specific_activity_in_period%(Abstime a1, Abstime a2, string activity, bool activity_group) =
    (   roster.%trip_code_at_date%(round_up(a1, 24:00)) = "FW" or
        %_free_weekend_VAC_LOA_in_two_days%(a1, activity) or
        %_free_weekend_specific_activity_in_period_no_empty_gap%(a1, a2)    ) and
    (all(trip(roster), all(leg(trip), %_free_weekend_specific_activity_in_period_filter%(activity, activity_group)))
    where ( trip.%time_in_period%(a1, a2) > 0:00));

%_free_weekend_VAC_LOA_in_two_days%(Abstime a1, string activity) =
    if activity = "VAC" or activity = "LOA" then
        task.%group%(roster.%trip_code_at_date%(round_up(a1, 24:00))) = activity and
        task.%group%(roster.%trip_code_at_date%(round_up(a1 + 24:00, 24:00))) = activity
    else
        false;

%_free_weekend_specific_activity_in_period_no_empty_gap%(Abstime a1, Abstime a2) =
    roster.%trip_code_at_date%(round_down(a1, 24:00)) <> "open" and
    roster.%trip_code_at_date%(round_up(a1, 24:00)) <> "open" and
    roster.%trip_code_at_date%(round_down(a2, 24:00) - 24:00) <> "open" and
    roster.%trip_code_at_date%(round_down(a2, 24:00)) <> "open";

%_free_weekend_specific_activity_in_period_filter%(string activity, bool activity_group) =
    if activity_group then
        task.%group%(leg.%code%) = activity
    else if activity = "" then
        task.%is_allowed_on_free_weekend%(leg.%code%)
    else
        leg.%code% = activity;

/*
*   =======================================================================
*   =======================================================================
*/


/*
 *         Free weekend intervals
 *
 */

/* Weekend_type is depend on the agreement group
 * for example all FD SK and SKN CC have multiple definition of weekend
 * like FRI-SAT-SUN=type_1 and SAT-SUN-MON=type_2 and so on
 */
table free_we_interval =
    %flight_crew%,
    crew.%agmt_group_id%,
    crew.%has_agmt_group_sk_cc% and
    not crew.%has_agmt_group_skn_cc%,
    crew.%has_agmt_group_sk_fd%
    ->
        export %free_we_latest_start%,
        export %free_we_earliest_end%,
        export %free_we_length%;


    /* FC */
    true , -          , -     , true  -> 24:00, 24:00, 72:00; /*SK FD new def: Fri 00:00 - Sun 24:00 OR Sat 00:00 - Mon 24:00 */
    true , -          , -     , false -> 24:00, 24:00, 72:00; /* Link/Connect FD Fri 00:00 - Sun 24:00 OR Sat 00:00 - Mon 24:00 */

    /* CC */
    false, -          , true  , -     -> 18:00, 6:00, 60:00;  /* SKS+SKD CC Default Fri 18:00 - Mon 06:00        */
    false, -          , false , -     -> 24:00, 24:00, 72:00; /* SKN CC + Link/Connect 00:00 - Sun 24:00 OR Sat 00:00 - Mon 24:00 */
/* commented out as of now in case other crew groups appear in the future that this is needed for
&
    true , -    , -            ,true   -> %free_we_latest_start_fc%,
                                           %free_we_earliest_end_fc%,
                                           %free_we_length_fc%; /*other SK FD crew*/
    -    , -    , -            , -     -> 24:00, 24:00, 96:00; /* Default: Fri 00:00 - Mon 24:00 */
end


table free_we_interval_tow(int weekend_types) =
    weekend_types,
    %flight_crew%,
    crew.%agmt_group_id%,
    crew.%has_agmt_group_sk_cc% and
    not crew.%has_agmt_group_skn_cc%,
    crew.%has_agmt_group_sk_fd%
    ->
        %_free_we_interval_max_number_of_types%,
        export %free_we_start_tow%,
        export %free_we_end_tow%;

    /* FC */
    1, true , -            , -     , true  -> 2, 96:00, 0:00;   /* SK FD new def: Fri 00:00 - Sun 24:00 */
    2, true , -            , -     , true  -> 2, 120:00, 24:00; /* SK FD new def: Sat 00:00 - Mon 24:00 */
    1, true , -            , -     , false -> 2, 96:00, 0:00;   /* Link/Connect FD Fri 00:00 - Sun 24:00 */
    2, true , -            , -     , false -> 2, 120:00, 24:00; /* Link/Connect FD Sat 00:00 - Mon 24:00 */

    /* CC */
    1, false, -            , true  ,   -   -> 1, 114:00, 6:00;  /* SKS+SKD CC Default  Fri 18:00 - Mon 06:00 */
    1, false, -            , false ,   -   -> 2, 96:00, 0:00;   /* SKN CC + Link/Connect CC Fri 00:00 - Sun 24:00 */
    2, false, -            , false ,   -   -> 2, 120:00, 24:00; /* SKN CC + Link/Connect CC Sat 00:00 - Mon 24:00 */
/*commented out as of now in case other crew groups appear in the future that this is needed for
  &
    1, true , -            , -     , true  -> 1, %free_we_start_tow_fc%, %free_we_end_tow_fc%;*/
    -, -    , -            , -     ,   -   -> 1, 96:00, 24:00;  /* Default: Fri 00:00 - Mon 24:00 */
end

export %free_we_interval_max_number_of_types% = %_free_we_interval_max_number_of_types%(1);

/*
 *         Free weekend intervals - other FC groups
 *
 */

table free_we_interval_fc =
  crew.%is_fdrc%(%pp_start%),
  %crew_region% ->
    %free_we_latest_start_fc%,
    %free_we_earliest_end_fc%,
    %free_we_start_tow_fc%,
    %free_we_end_tow_fc%,
    %free_we_length_fc%;
    
  true , <> "SKI" -> 16:00, 6:30, 112:00, 6:30, 62:30;   /* Fri 16:00 - Mon 06:30 K11 RC   */
    -  ,    -     -> 24:00, 24:00, 96:00, 24:00, 96:00;  /* Default: Fri 00:00 - Mon 24:00 */
end


%trip_is_single_day_greenland% =
  is_first(trip(wop)) and is_last(trip(wop)) and
  trip.%is_one_day_greenland_return%;
  
%wop_has_single_day_greenland% =
  any(trip(wop),%trip_is_single_day_greenland%);

%trip_is_double_day_greenland% =
  is_last(trip(wop)) and trip.%is_one_day_greenland_return% and
  default(prev(trip(wop), 
               is_first(trip(wop)) and trip.%is_one_day_greenland_return%), false);
  
%wop_has_double_day_greenland% =
  any(trip(wop),%trip_is_double_day_greenland%);

export %trip_is_last_not_free_we_in_month% =
  not trip.%is_allowed_on_free_weekend% and
  default(next(trip(roster),  trip.%end_month_start%)
               where (not trip.%is_allowed_on_free_weekend%)
          > trip.%start_month_start%, true);

/*
** there once was a rolling condition also, and some code remains from that, should it reoccur. But the code is not
** active, as it causes bad dependencies
*/
export %free_we_period_is_month% = True; /* once was dependent on agreement */

export %free_we_period_start% = %_free_we_period_start%(base_calendar.%sunday%);
export %free_we_period_end% = %_free_we_period_end%(base_calendar.%sunday%);
export %free_we_period_start_by_date%(Abstime d) = %_free_we_period_start_by_date%(base_calendar.%sunday%, d);
export %free_we_period_end_by_date%(Abstime d)  = %_free_we_period_end_by_date%(base_calendar.%sunday%, d);



export %has_free_weekend_in_period% =
  %has_free_weekend_monthly_by_date%(fundamental.%publ_period_start%);

export %has_free_weekend_in_period_by_date%(Abstime d) =
  %has_free_weekend_monthly_by_date%(d);

export %has_free_weekend_in_period_by_trip% =
  %has_free_weekend_monthly_by_date%(trip.%start_month_start%);

%has_free_weekend_monthly_by_date%(Abstime d) =
    default(accumulators.%last_free_weekend%(freedays.%free_we_period_end_by_date%(d))
            >= %free_we_period_start_by_date%(d) + 24:00, false);

/*%has_free_weekend_rolling% =
    default(accumulators.%last_free_weekend%(%free_we_period_start% +
                                             %free_weekend_max_days% * 24:00)
            >= %free_we_period_start%, false);
*/


%prev_special_weekend_start% =
  %prev_special_weekend_startdate% + %free_we_latest_start% - 24:00;

%prev_special_weekend_end% =
  %prev_special_weekend_enddate% + %free_we_earliest_end%;

%special_weekend_startdate% =
    calendar.%special_weekend_startdate%(%end_hb_free_we%,
                                         %next_trip_start_hb_free_we%,
                                         crew.%country_at_date%(wop.%start_hb%));

%special_weekend_enddate% =
    calendar.%special_weekend_enddate%(%end_hb_free_we%,
                                       %next_trip_start_hb_free_we%,
                                       crew.%country_at_date%(wop.%start_hb%));

%prev_special_weekend_startdate% =
    calendar.%special_weekend_startdate%(%prev_trip_end_hb_free_we%,
                                         %start_hb_free_we%,
                                         crew.%country_at_date%(wop.%start_hb%));

%prev_special_weekend_enddate% =
    calendar.%special_weekend_enddate%(%start_hb_free_we%,
                                       %prev_trip_end_hb_free_we%,
                                       crew.%country_at_date%(wop.%start_hb%));

export %special_weekend_start_date% =
    calendar.%special_weekend_startdate%(round_down(%end_hb_free_we%,24:00),
                                         %next_trip_start_hb_free_we%,
                                         crew.%country_at_date%(wop.%start_hb%));


/* This table is for f4 assignment on empty rosters where wops are unavailable */
table free_we_interval_wop_indep =
  crew.%k4exng_cc_sp5_1_valid%(pp.%start_month%),
  %flight_crew%,
  %crew_region% ->
    %f4_start_tow%,
    %f4_length%;
    
  true,    - ,    -    -> 114:00, 60:00;   /* 4ExNG Fri 18:00 - Mon 06:00 */

  false, true,    -    -> %f4_start_tow_fc%, %f4_length_fc%;   
  false, false, "SKD"  -> 112:00, 62:00;   /* Fri 16:00 - Mon 06:00 */
  false, false, "SKN"  -> %f4_start_tow_cc_skn%, %f4_length_cc_skn%; 
  false, false, "SKS"  -> 114:00, 60:00;   /* Fri 18:00 - Mon 06:00 */

    -  ,    -,   -     ->  96:00, 96:00;   /* Default: Fri 00:00 - Mon 24:00 */
end

table free_we_interval_wop_indep_fc =
  crew.%is_fdrc%(%pp_start%),
  %crew_region% ->
    %f4_start_tow_fc%,
    %f4_length_fc%;
    
  true ,   -    -> 112:00, 62:30;   /* Fri 16:00 - Mon 06:30 K11 RC   */
  false,   -    -> 112:00, 64:00;   /* Fri 16:00 - Mon 08:00 K11 Main */

    -  ,   -    -> 96:00,  96:00;   /* Default: Fri 00:00 - Mon 24:00 */
end

table free_we_interval_wop_indep_cc_skn =
  parameters.%k11_skn_cc_sp10_7_valid%(%pp_start%),
  crew.%is_long_haul%(%pp_start%) ->
    %f4_start_tow_cc_skn%,
    %f4_length_cc_skn%;
    
  true, true    ->  96:00, 78:00;   /* Fri 00:00 - Mon 06:00 K11 LH */
    - ,   -     -> 112:00, 62:00;   /* Fri 16:00 - Mon 06:00 */
end

/*
 * For use in free weekend rudob and F4 assignment
 */
%1st_required_free_weekend% =
  let free_we_start = accumulators.%last_free_weekend%(%pp_start%);
  if free_we_start + %free_we_length% > %pp_start% then
    free_we_start
  else
    accumulators.%last_free_weekend%(free_we_start + %free_weekend_max_days% * 24:00);

%2nd_required_free_weekend% =
  accumulators.%last_free_weekend%(
    %1st_required_free_weekend%
    + %free_weekend_max_days% * 24:00);

export %required_free_weekend% =
  if %free_we_period_is_month% then
    accumulators.%last_free_weekend%(%free_we_period_end%)
  else if %free_we_period_end% > %pp_start% then
    %2nd_required_free_weekend%
  else
    %1st_required_free_weekend%;

/* Start of the next possible free weekend, i.e. last legal free weekend
 * closest to %free_weekend_max_days% from the previous free weekend
 * or from month end (depending on agreement). */
export %next_last_free_weekend% =
  accumulators.%last_free_weekend%(%latest_possible_free_weekend%);

/* We need to do magic since latest_possible_free_weekend returns
** 00:00 of the saturday or sunday that the free weekend should be included in */
export %start_of_latest_possible_free_weekend% =
  let close_week = round_down_week(%latest_possible_free_weekend%) +
                   max(times(%free_we_interval_max_number_of_types%), %free_we_start_tow%(%times_index_0%));
  if close_week > %latest_possible_free_weekend% then
    close_week - %week_hours%
  else close_week;

%end_of_latest_possible_free_weekend% =
  %start_of_latest_possible_free_weekend% + %free_we_length%;
  
%week_hours% = 7 * 24:00;

export %latest_possible_rudob_start% =
    if %free_we_interval_max_number_of_types% = 1 then
        %_latest_possible_rudob_start_weekend_type_one%
    else
        %_latest_possible_rudob_start_weekend_types%;

%_latest_possible_rudob_start_weekend_type_one% =
  let times_loop = if %free_we_period_is_month% then
                     max(times(5), %times_index_0%)
                     where(%start_of_latest_possible_free_weekend% -
                           ((%times_index_0% - 1) * %week_hours%) >= %free_we_period_start%)
                   else 4;
  max(times(times_loop), %start_of_latest_possible_free_weekend% - ((%times_index_0% - 1) * %week_hours%)) where
      (not(any(trip(roster), overlap(%start_hb_free_we%, %end_hb_free_we%,
                               %start_of_latest_possible_free_weekend% - ((%times_index_0% - 1) * %week_hours%),
                               %end_of_latest_possible_free_weekend% - ((%times_index_0% - 1) * %week_hours%)) > 0:00 and
                             not trip.%is_allowed_on_free_weekend%) where (trip.%in_pp%)));

%_latest_possible_rudob_start_weekend_types% =
    let last_free_weekend = accumulators.%last_free_weekend%(freedays.%free_we_period_end%);
    /* Rudob should be shown in planning period minus length of a weekend */
    if last_free_weekend >= fundamental.%pp_start% - 72:00 then
          last_free_weekend
    else
        void_abstime;

export %latest_possible_free_weekend% =
  if %free_we_period_is_month% then
    %free_we_period_end%
  else
    %last_free_weekend_pp_start% + %free_weekend_interval%;

/* Add multiples of whole weeks of max days, HenrikA 25may2007 */
%free_weekend_interval% =
  %free_weekend_max_days%/7 * %week_hours%;

/* End of last free weekend at pp start */
%last_free_weekend_pp_start% = 
  accumulators.%last_free_weekend%(%pp_start%) + %free_we_length%;



/* Start of the next last possible free weekend counting from pp start 
export %next_next_last_free_weekend% =
  accumulators.%last_free_weekend%(%next_last_free_weekend% + %free_we_length% + 
                                   %free_weekend_interval%);

/* Used for assigning F4 */
export %trip_should_have_f4_assigned_after% =
  %trip_is_followed_by_free_weekend% and
  crew.%in_variable_group%(%next_possible_free_weekend_start%);

export %f4_should_follow_trip% = 
  %next_last_free_weekend% >= trip.%start_hb% and
  %next_last_free_weekend% < default(next(trip(roster), trip.%start_hb%), %pp_end%);

/*
** During the last planning period there might have been accumulated a
** free weekend that overlaps this planning period. This function checks
** if such a free weekend also overlaps production.
*/
export %production_overlaps_latest_accumulated_free_weekend%(Abstime last_free_we_start) =
    not wop.%is_allowed_on_free_weekend% and
    %start_hb_free_we% < %latest_accumulated_free_we_end%(last_free_we_start);

/*
** Wop before last free weekend start might be a greenland trip,
** meaning that the free weekend lasts longer.
*/
export %latest_accumulated_free_we_end%(Abstime last_free_we_start) =
    if %free_weekend_limits_can_be_found_at_wop_before_free_weekend%(last_free_we_start)
    then
        %last_wop_before_pp_start_next_possible_free_we_end%
    else
        round_up_week(last_free_we_start) + %free_we_end_tow_regularly%;

/*
** If the wop before the free weekend is a Greenland trip
** then the start/end of the free weekend is different.
** If the plan contains the wop before the latest accumulated 
** free weekend then we can ask that wop for the end of the
** free weekend. Otherwise, we use the end time that is
** regularly used.
*/
%free_weekend_limits_can_be_found_at_wop_before_free_weekend%(Abstime last_free_we_start) =
    default(round_down_week(%last_wop_before_pp_start_next_possible_free_we_start%) =
            round_down_week(last_free_we_start),
            false);

%last_wop_before_pp_start_next_possible_free_we_start% =
    last(trip(chain), %next_possible_free_weekend_start%)
        where (not trip.%is_allowed_on_free_weekend% and
               trip.%end_scheduled_hb% < %pp_start%);

%last_wop_before_pp_start_next_possible_free_we_end% =
    last(trip(chain), %next_possible_free_weekend_end%)
        where (not trip.%is_allowed_on_free_weekend% and
               trip.%end_scheduled_hb% < %pp_start%);

/****************************************************************
 * Section 14: FS days on weekends  
 ***************************************************************/
%previous_fs_leg_is_saturday% =
    let first_leg_start = round_down(leg.%start_hb%,24:00);
    not void (prev(leg(chain),leg.%is_fs%) 
         where ( leg.%is_fs% and
                %leg_is_saturday%(leg.%start_hb%) and
                (leg.%start_hb% >= first_leg_start - 24:00)));
  
%previous_VA_is_saturday% =
    let first_leg_start = round_down(leg.%start_hb%,24:00);
    not void (prev(leg(chain),leg.%is_LAx%) 
         where ( task.%is_vacation%(leg.%code%) and
                %leg_is_saturday%(leg.%start_hb%) and
                (leg.%start_hb% >= first_leg_start - 24:00)));
    
%previous_loa_is_saturday% =
    let first_leg_start = round_down(leg.%start_hb%,24:00);
    not void (prev(leg(chain),leg.%is_loa%) 
         where ( leg.%is_loa% and
                %leg_is_saturday%(leg.%start_hb%) and
                (leg.%start_hb% >= first_leg_start - 24:00)));

%leg_is_saturday%(abstime t) =
    base_calendar.%wd_from_abs%(t)=6;

%leg_is_friday% (abstime t) =
  base_calendar.%wd_from_abs%(t)=5;
  
 %leg_is_monday%(abstime t) =
    base_calendar.%wd_from_abs%(t)=1;
    
%free_weekend_start_time%(Abstime t) =
      if base_calendar.%wd_from_abs%(round_down_month(t))=
      base_calendar.%sunday% then
           round_down_month(t) - 24:00
      else
           round_down_month(t);

%free_weekend_end_time%(Abstime t) =
        if base_calendar.%wd_from_abs%(round_up_month(t))=
        base_calendar.%saturday% then
          round_up_month(t) - 24:00
        else
          round_up_month(t);

/*
* Table "account_entry" is used to determine the number of granted FS weekends that have been granted to a crew and
*is used to evaluate the max FS in month rule  sso that it doe's not fail incorrectly.
* see SKAM-820 Max FS in month rule fails wrongly
*/

%request_table_name% = "account_entry";

/* determines the number of entries in the table that match criteria
*Crew.id, account = "FS" and source = "Granted daysoff" 
*/
table no_of_entries_in_table =
  crew.%id%, "FS", "Granted daysoff", round_down_month(leg.%start_hb%) - 24:00, round_up_month(leg.%start_hb% + 0:01) ->
    export Int %number_of_fs_days_in_month%;
  external %request_table_name%;
  crew, account, source, <=tim, >tim  -> count(row_number);
end

/* saves the entries from the table that match criteria
*Crew.id, account = "FS" and source = "Granted daysoff" and are within planning month
*/
table list_of_entries (Int ix) =
  ix, crew.%id%, "FS", "Granted daysoff", round_down_month(leg.%start_hb%) - 24:00, round_up_month(leg.%start_hb% + 0:01) ->
    export Abstime %fs_requests%;
  external %request_table_name%; /*account_entry*/
  match_number, crew, account, source, <=tim, >tim ->  tim;
end

/*Check specific day if it's a FS day off*/
table fs_request_lookup (Abstime date) =
  crew.%id%, "FS", "Granted daysoff", date, date + 24:00 ->
    export Abstime %fs_request%;
  external %request_table_name%; /*account_entry*/
  crew, account, source, <=tim, >tim -> tim;
  -,-,-,-,- -> void_abstime;
end

%has_fs_request%(Abstime date) = not void(%fs_request%(date));

/*Counts the number of times a full FS weekend occurs in a month, first checking Sunday*/
export %no_of_fs_weekends_in_month% =
    count(times(%number_of_fs_days_in_month%))
       where ((string_to_int(format_time(%fs_requests%(times_index(0)),"%w")) = 7)and
             ( %has_fs_request%(%fs_requests%(times_index(0))-24:00)));

%weekend_day%(AbsTime start_day_limit, AbsTime end_day_limit) =
  let sunday_morning=default(base_calendar.%covered_midnight_by_wd%(base_calendar.%sunday%, nmax(start_day_limit, duty.%start_hb%), nmin(end_day_limit, duty.%end_hb%)),base_utils.%abstimemin%);
/**
   sunday_morning=default(base_calendar.%covered_midnight_by_wd%(base_calendar.%sunday%, duty.%start_hb%, duty.%end_hb%),base_utils.%abstimemin%);
*/
  not (sunday_morning=base_utils.%abstimemin%)
  and  (duty.%consec_duty_selection_covers_interval%(duty.%duty_sel_is_fs_disallow%,
                                               sunday_morning-24:00,
                                               sunday_morning+24:00));



export %any_free_weekend_in_month%(Abstime bid_day) =
   let start_time = %free_weekend_start_time%(bid_day),
       end_time   = %free_weekend_end_time%(bid_day);
   default(any(duty(roster),%weekend_day%(start_time, end_time)) where (
      duty.%end_hb% >start_time
      and duty.%start_hb% < end_time
      and duty.%duty_selected%(duty.%duty_sel_is_fs_disallow%,duty.%end_hb%)),false);
 

export %no_of_fs_days_in_month%(Abstime leg_start) =
count(leg(chain)
      where (leg.%is_fs% and
      leg.%start_hb% >=%free_fs_weekend_month_start_skn_nkf%(leg_start) and
      leg.%end_hb% < %free_fs_weekend_month_end_skn_nkf%(leg_start)));   
  
/****************************************************************
 * Section 15: Freeday assign script variables
 
 A period of FG inside publ-pp is not supported.
 A period of VG inside publ-pp is only supported for group change freedays.
 
 ***************************************************************/

export %freeday_assigner_task_code% =
  parameter "FN"
  remark "Fill with specific freeday code: code to use",
  planner "This parameter defines which freeday code which is to be assigned by the script 'Fill with specific freeday code', e.g. FN (SKCMS-56)";

export %freeday_assigner_assign_24_hour_blocks% = 
  parameter true
  remark "Fill with specific freeday code: fill with 24 hour blocks",
  planner "This parameter defines if the freedays in the script 'Fill with specific freeday code' are assigned in 24 hour blocks or in larger blocks (SKCMS-56";

export %freeday_assigner_task_code_valid% =
  task.%is_freeday%(%freeday_assigner_task_code%);
 
%_required_pt_freedays_in_month_wop_indep% =
  nmax(%required_pt_freedays_1_month_wop_indep%,
       %required_pt_freedays_2_month_in_month_wop_indep%);

%required_pt_freedays_1_month% =
  if %r_valid_pt_freedays% then
    %min_required_pt_freedays_1_month%
  else
    0;
    
/* ONLY FC SH VG relevant */
export %min_required_pt_freedays_1_month% =
  %min_required_pt_freedays_1_month_by_dates%(wop.%start_month_start%, wop.%start_month_end%);
  
export %min_required_pt_freedays_1_month_pp% = %min_required_pt_freedays_1_month_wop_indep%;
  
export %min_required_pt_freedays_1_month_wop_indep% =
  %min_required_pt_freedays_1_month_by_dates%(%pp_start%, %publ_period_end%);


/*
**  Number of part-time LA-days required in a month
**
** K11: The normal requirement is reduced only in proportion to the number of
**      part-time days in the month, when there is a change of part-time percent
**      in the month. It is not reduced by non-qualifying days (eg. VA etc.), 
**      except for FD SKD for which VA/VA1 reduces part-time days in month (SKCMS-2641)
*/

export %min_required_pt_freedays_1_month_by_dates%(abstime start_t, abstime end_t) =
  let period_days = (end_t - start_t) / 24:00,
      base_at_date = crew.%base_at_date%(start_t);
  if crew.%part_time_change_in_period%(start_t,end_t) then
    %ind_req_pt_freedays_with_month_as_two_intervals_by_dates%(start_t, end_t)
  else if period_days > 0 then
    if %flight_crew% and base_at_date = "CPH" then
      (%_min_pt_freedays_1_month%(start_t,true) * (period_days - %freedays_reducing_days_vacation%(start_t,end_t))) / period_days
    else
      %_min_pt_freedays_1_month%(start_t,true)
  else 0;
    
%ind_req_pt_freedays_with_month_as_two_intervals_by_dates%(abstime start_t, abstime end_t) =
  let   part_time_change_date = crew.%part_time_change_date_in_period%(start_t, end_t),
        month_days = (end_t-start_t)/24:00;
  if %flight_crew% and parameters.%k11_fc_sp10_9_valid%(start_t) then
    (%min_req_pt_freedays_in_month_interval%(start_t,part_time_change_date,month_days) +
     %min_req_pt_freedays_in_month_interval%(part_time_change_date,end_t,month_days) + 5) /10
  else
    (10 *
     (%target_pt_freedays_in_period_1_month%(start_t, part_time_change_date) +
      %target_pt_freedays_in_period_1_month%(part_time_change_date, end_t)) /month_days + 5) / 10;

%min_req_pt_freedays_in_month_interval%(abstime i_start, abstime i_end, int month_days) =
  let i_days = (i_end - i_start) / 24:00;

  10 * ((i_days * %_min_pt_freedays_1_month%(i_start,true)) / month_days);

export %required_pt_freedays_1_month_pp% = 
  %required_pt_freedays_1_month_wop_indep%; /*clarify the this is pp controlled */
  
%required_pt_freedays_1_month_wop_indep% =
  if %r_valid_pt_freedays_wop_indep% then
    %min_required_pt_freedays_1_month_wop_indep%
  else
    0;
%required_pt_freedays_2_month_in_month% =
  if %r_valid_pt_freedays% then
    %min_required_pt_freedays_2_months% -
    accumulators.%qual_pt_freedays_in_period%(%prev_month_start%, wop.%start_month_start%)
  else
    0;
    
export %min_required_pt_freedays_2_months% =
    %min_required_pt_freedays_2_months_by_dates%(%prev_month_start%, wop.%start_month_end%);
    
export %min_required_pt_freedays_2_months_by_dates%(abstime start_t, abstime end_t) = 
  (accumulators.%min_required_pt_freedays_2_months%(start_t, end_t)) / 10;

%required_pt_freedays_2_month_in_month_wop_indep% =
  let start_t = round_down_month(%pp_start%-00:01),
      end_t = %pp_start%;

  if %r_valid_pt_freedays_wop_indep%  then
    %min_required_pt_freedays_2_months_wop_indep% -
    accumulators.%qual_pt_freedays_in_period%(start_t, end_t)
  else
    0;
    
export %min_required_pt_freedays_2_months_wop_indep% =
  %min_required_pt_freedays_2_months_by_dates%(round_down_month(%pp_start%-00:01), 
                                               round_up_month(%pp_start%+00:01));

%r_valid_pt_freedays_wop_indep% =
  %r_valid_pt_freedays_by_dates%(round_down_month(%pp_start%),
                                 round_up_month(%pp_start%+00:01)) ; 
%r_valid_pt_freedays% =
  %r_valid_pt_freedays_by_dates%(wop.%start_month_start%,
                                 wop.%start_month_end%) ; 
  
%r_valid_pt_freedays_by_dates%(abstime start_t, abstime end_t) =
  (crew.%is_short_haul%(start_t) or 
   (%flight_crew% and crew.%is_ski_at_date%(start_t))) and
  crew.%has_some_variable_group_in_period%(start_t,end_t)  and
  (crew.%part_time_factor_at_date%(start_t) <> 100 or 
   crew.%part_time_factor_at_date%(end_t - 0:01) <> 100 );
   
  
export %nr_extra_F_days_in_calendar_month% =
  if crew.%part_time_factor_wop_start% = 80 then
    freedays.%nr_qualifying_in_2_months%
  else
    freedays.%nr_qualifying_in_3_months%;
    
export %nr_qualifying_in_3_months% =
  accumulators.%qual_freedays_in_period%(%prev_prev_month_start%, wop.%start_month_end%);
  
export %nr_qualifying_in_3_months_fulltime_fc_sh% =
  accumulators.%nr_freedays_in_period_fulltime_fc_sh%(%prev_prev_month_start%,
                                                      wop.%start_month_end%);
  
export %nr_qualifying_in_6_months_fulltime_fc_sh% =
  accumulators.%nr_freedays_in_period_fulltime_fc_sh%(add_months(wop.%start_month_end%, -6),
                                                      wop.%start_month_end%);
  
export %prev_prev_month_start% = round_down_month(wop.%start_month_start% - 35*24:00);

export %r_valid_freedays_in_2_months_by_month_start%(abstime month_start_hbt) =
  (crew.%is_SKD_at_date%(month_start_hbt) or
   (crew.%is_SKN_at_date%(month_start_hbt) and not 
    crew.%is_fulltime_temp_SKN_at_date%(month_start_hbt))) and
  fundamental.%even_month_by_month_start%(month_start_hbt);
  
%required_freedays_3_month_in_month% = 
  if crew.%is_fdrc_wop_start% and
     fundamental.%last_month_in_quarter% then
    %ind_req_3_months_1_month_part%(calendar.%month_start%, calendar.%month_end%)
  else
    0;
 
/* 
 * Pre-op freedays (fixed)
 */
export %assign_fixed_freedays% = 
  crew.%in_fixed_group_pp_start_or_pp_end%;
  
/* A carry-out window is used to support group-change freedays in the next pp.
   We also check att publ-end,
   but we only need to worry about changes from VG to FG. */
export %group_change_date% =
  if crew.%in_fixed_group%(%pp_end% + 48:00) or
     crew.%in_fixed_group_pp_end% then
     crew.%change_to_fg_in_period_date%(%pp_start%, %pp_end% + 48:00)
  else
    1jan1986;

/* 
 * Post-op freedays. 
 */
/* Postop freedays should only be assigned when crew is in variable group.
   The following variables might misbehave when crew changes multiple times in
   publ period. /EKG 090920 */
%vg_start% = default(%_vg_start%, 31dec2035);
%vg_end% = default(%_vg_end%, 1jan1986);

%_vg_start% = 
    if crew.%has_some_variable_group_in_publ% then
        if crew.%in_variable_group_pp_start% then %pp_start%
        else crew.%first_group_change_date_pp_start%
    else void_abstime;

%_vg_end% = 
    if crew.%has_some_variable_group_in_publ% then
        if crew.%in_variable_group%(%publ_period_end%) then add_months(%publ_period_end%, 1)
        else crew.%change_to_fg_in_period_date%(%pp_start%, %publ_period_end%)
    else void_abstime;
    
export %assign_flex_freedays% =
  crew.%has_some_5_4_flex_group_in_pp%;
  
/* Only one parttime change is allowed in one month. 
   Since the requirement is per month we only check 
   publ-pp. */
export %assign_parttime_freedays% = 
  crew.%part_time_factor_pp_start% < 100 or
  crew.%part_time_factor_publ_end% < 100;

export %assign_parttime_freedays_midnight% =
  crew.%part_time_factor_pp_start% < 100 or
  crew.%part_time_factor_at_date%(%pp_end%-0:01) < 100;
  
/* VG freedays are F4 on free weekend, and carry-out freedays to support
   pre-rostering in next pp. */
export %assign_vg_freedays% =
  crew.%in_variable_group_pp_start_or_pp_end%;


/*
**  Maximum accumulated freedays and parttime freedays requirement
**  in one month.  (FC: F + LA8, CC: F + F88).
*/
export %required_freedays_in_month% = 
  if %cabin_crew% then
    nmax(%required_freedays_1_month%,
         %required_freedays_2_months_in_month%)
  else
    nmax(%required_freedays_1_month%,
         %required_freedays_2_months_in_month%,
         %required_freedays_3_month_in_month%);    

/* common FC / CC support variable */
%required_freedays_1_month% =
  if %r_valid_freedays_in_1_month% then
    %min_required_in_1_month%
  else
    0;

/*
**  Maximum parttime freedays requirement
**  in one month.
*/
export %parttime_code%(abstime date) = 
    crew.%contract_parttime_code%(date);
  
/* WPCCR 315 Changed from utc to hb */
export %parttime_code_wop_start% =
    %parttime_code%(wop.%start_hb%);

export %parttime_code_pp_start% =
    %parttime_code%(%pp_start%);
    
%first_parttime_code_in_pp% =
  default(%parttime_code_pp_start%,
          %parttime_code%(crew.%agreement_pp_start_valid_to%));

export %required_pt_freedays_in_month% = 
  if %cabin_crew% then
    default(
            first(wop(chain), %_required_pt_freedays_in_month%)
            where (wop.%starts_in_pp%), 0)
  else
    default(
            first(wop(chain), %_required_pt_freedays_in_month%)
            where (wop.%starts_in_pp%), 
            %_required_pt_freedays_in_month_wop_indep%);


%_required_pt_freedays_in_month% =
  if crew.%is_crew_monthly_parttime_at_date%(calendar.%month_start%) then 0
  else if crew.%k4exng_cc_sp5_1_valid%(calendar.%month_start%) then
    %req_pt_freedays_in_period_1_month%(calendar.%month_start%, calendar.%month_end%) / month.%pp_days% + 1
  else if %cabin_crew% then
    if crew.%part_time_change_in_month% then
      %required_pt_freedays_with_month_as_two_intervals%
    else
      (10 *
       %req_pt_freedays_in_period_1_month%(calendar.%month_start%, calendar.%month_end%) / month.%pp_days% + 5) / 10
  else
    nmax(%required_pt_freedays_1_month%,
         %required_pt_freedays_2_month_in_month%);

/*
** F88 days requirement are calculated as:
**  The total freedays demand for the parttime crew (F + F88) subtracted by
**  the corresponding demand for a fulltime crew reduced by the parttimefactor.
**
** The algorithm only utilizes 1 month limits, and the assumption is that we
** have no fixed F88 requirements. 
*/

%req_pt_freedays_in_period_1_month%(Abstime start, Abstime stop) =
  /* potential parttime f demand in a period */
    %_min_pt_freedays_in_month%(start, false) * %qual_days_in_period%(start, stop) - 1;

%required_pt_freedays_with_month_as_two_intervals% =
  /*
  ** Required parttime freedays in 1 month based on  
  ** requirements for relevant parttime factor
  */
  let part_time_change_date = crew.%part_time_change_date_in_period%(calendar.%month_start%, calendar.%month_end%);

  (10 *
  (%req_pt_freedays_in_period_1_month%(calendar.%month_start%, part_time_change_date) +
   %req_pt_freedays_in_period_1_month%(part_time_change_date, calendar.%month_end%)) / month.%pp_days% + 5) / 10;

/* Variable names are not good, but flight crew have specific PT need. 
   Cabin on the other hand doesn't, but should get F88 to fill up the total
   F-need after required freedays after wop has been assigned. */
export %parttime_freedays_left_to_assign% = 
    if crew.%is_pilot% then
        nmax(0, %required_pt_freedays_in_month% - %variable_parttime_freedays_in_month%)
    else
        nmax(0, %required_pt_freedays_in_month% - %nr_pt_freedays_in_publ_period%);
  
/* WPCCR 315 Freedays and vacations starting 1<month><year> 00:00 will be missed as
             well as if they start in previous month. Wee need to check the overlap
             in same time base. 2008-05-29 Janne C
             One extra hour to work with daylight saving shift.
             This will work since 25:00/24:00 = 1 day
*/
%days_in_publ_period% =
    let pp_daylight_save_hour =  
        %period_daylight_save_hour%(%publ_period_start_utc%,
                                    %publ_period_end_utc%),
        trip_daylight_save_hour =  
        %period_daylight_save_hour%(trip.%start_utc%,
                                    trip.%end_utc%);
  overlap(%publ_period_start_utc%, %publ_period_end_utc%+pp_daylight_save_hour,
          trip.%start_utc%, trip.%end_utc%+trip_daylight_save_hour) / 24:00;
  
/* WPCCR 315 Some VG crew doesn't have a parttime code (Eija is checking into this)
             %default_parttime_code% solves this until solved.
             This can be used for assigning needed ptf days checking assigned days via its group_code. */
%default_parttime_code% = 
  if %cabin_crew% and crew.%is_sks% then 
    "F88"
  else
    "LA8";

/* WPCCR 315 It seems to be common that crew are assigned with LA codes other than their own parttime code.
             Check also group_code if no match on code. 2008-06-03 Janne C*/
%variable_parttime_freedays_in_month% =                    
  sum(trip(roster), %days_in_publ_period%)
  where (trip.%is_group_valid_pt_freeday%
          and 
          crew.%part_timer_and_not_fixed_at_date%(trip.%start_hb%) and
          trip.%start_utc% < %publ_period_end_utc%);
/*  sum(trip(roster), trip.%days%)
  where (trip.%starts_in_pp% and 
         trip.%code% = %parttime_code_wop_start% and 
         trip.%start_UTC% >= %pp_start% and
         trip.%start_UTC% < %publ_period_end%);*/

/*
** Crew validity for freeday relevancy - accessed from rules as well
*/
/* Changes due to SKI K06, HenrikA 12dec2006 */ 
export %r_valid_freedays_in_1_month% =
  crew.%is_short_haul_wop_start% or
  /* No rule check for LH crew if less than 10 available days */
  freedays.%qual_days_in_month% >= 10;

export %r_valid_freedays_in_2_months% = 
  if %cabin_crew% then
    (crew.%is_SKD% or
     (crew.%is_SKN% and not 
      crew.%is_fulltime_temp_SKN%)) and
    fundamental.%even_month%
  else
    crew.%is_short_haul_wop_start% and
    not crew.%is_fdrc_wop_start%;

/*
**  Less than optimum performance accepted since variables is for script usage
*/ 

/* Note: F7S CAU handling needed here */
/*export %possible_pt_freeday_at_date%(abstime date) =
  not any(wop(roster), overlap(wop.%start_day%, wop.%end_day%, date, date + 23:59) > 0:00) 
      where(not wop.%is_pt_freeday%) and
  any(wop(roster), %possible_pt_freedays_after_wop_at_date%(date))
  where(wop.%is_on_duty% and
        wop.%end_day% < date);*/
  
 
export %possible_pt_freeday_at_date%(abstime date) =
  not %overlaps_non_pt%(date) and
  crew.%part_timer_and_not_fixed_at_date%(date) and
  %valid_pt_date%(date);

%overlaps_non_pt%(abstime date) =
  any(wop(roster), overlap(wop.%start_day%, wop.%end_day%, date, date + 23:59) > 0:00) 
  where(not wop.%is_pt_freeday%);
 /*is_vacation is a best guess from freedays_fc.%possible_pt_freedays_in_period% 
  and WP CCR 315*/

%valid_pt_date%(abstime date) =
  any(wop(roster), %possible_pt_freedays_after_wop_at_date%(date))
  where(%wop_valid_for_pt%(date) and
        wop.%end_day% < date and
        wop.%end_day% >= %publ_period_start%-24:00);

%wop_valid_for_pt%(abstime date) = 
   wop.%is_on_duty% or 
   wop.%is_vacation% or 
   wop.%is_freeday%;

  /*Two freedays after production before PT-days */
%possible_pt_freedays_after_wop_at_date%(Abstime date) = 
    let min_after_wop = last(duty(wop), %min_required_freedays_after_duty%),
        duty_is_offduty = last(duty(wop), duty.%is_off_duty%),
        limit = if duty_is_offduty
                then nmin(min_after_wop,2)
                else min_after_wop;
                    
  %possible_wop_pt_freedays_in_period%(%pp_start%, %pp_end%) > 0 and
  ((date > (wop.%end_day% + limit * 24:00) and not wop.%is_freeday%) or
   (wop.%is_freeday% and wop.%days% >= 1)) and /*Two freedays in row can have pt-days immediately after. Changed to 1 SKCMS-1458 in accordance with SASs */
  date < default(next(wop(roster), wop.%start_day%) where (wop.%is_on_duty%), 01Jan2036);

%possible_pt_freeday_at_date_ix% =
  if crew.%has_some_part_time_in_pp% and 
     %possible_pt_freeday_at_date%(%date_index%)
  then
    %parttime_code%(%date_index%)
  else
    void_string;

%trip_code_at_date_ix% =
  if crew.%has_some_part_time_in_pp%
  then
     roster.%trip_code_at_date%(%date_index%)
  else
    void_string;
    
/*
** IL8 parttime days demands in a month are relevant for crew that have a
** temporary parttime period (typically illness), implemented via special schedule.
** In this case a number of 'freedays' are given as IL8 to signal
** parttime ill.
** The monthly IL8 demand is given as the difference between the, normal (original)  
** parttime related freeday demand (sum of freedays an pt_freedays) 
** This IL8 logic assumes that the original (contract parttime factor) is the same 
** throughout the whole month.
*/
export %required_IL8_as_pt_freedays_in_month% = 
  if crew.%is_parttime_ill% then
    first(wop(chain),
          %required_freedays_in_1_month_temp_parttime% -
          %required_freedays_in_1_month_contract_parttime%)
    where (wop.%starts_in_pp%)
  else 
    0;

export %IL8_left_to_assign% = 
  nmax(0, %required_IL8_as_pt_freedays_in_month% - %IL8_in_month%);
  
%IL8_in_month% =
  sum(trip(roster), trip.%days%)
  where (trip.%starts_in_pp% and 
         trip.%code% = "IL8" and 
         trip.%start_hb% >= %pp_start% and
         trip.%start_hb% < %publ_period_end%);

/*
**  Required freedays in 1 month based on relevant contract parttime factor
*/
%required_freedays_in_1_month_contract_parttime% = 
  ((10 * 
    %target_days_in_period_1_month_contract%(calendar.%month_start%, calendar.%month_end%) / wop.%month_days%) + 5) / 10;

/*
**  Required freedays in 1 month based on relevant temp (parttime IL) parttime factor
*/
%required_freedays_in_1_month_temp_parttime% = 
  ((10 * 
    %target_days_in_period_1_month%(calendar.%month_start%, calendar.%month_end%) / wop.%month_days%) + 5) / 10;

/* Blankday assignment 
  We assign until roster becomes illegal, but since assigning one day
  could be illegal while the next is legal, we have to try all days in 
  publ. If we have already maxed out the roster this will create a lot
  of uneccessary work. */
  /*Redone with times-loop, not very fast 
  * but only calculated assign blank days 
  */
export %max_blankdays_to_assign% =
  count(times((%publ_period_end%-%pp_start%)/24:00)) where  
        (roster.%trip_code_at_date%(%pp_start%+(%times_index_0%-1)*24:00) = "open"); 

export %balance% = 
  %freedays_in_month% 
    - (%req_freedays_in_month%
       + (if crew.%k4exng_cc_sp5_1_valid%(fundamental.%pp_start%) then %required_pt_freedays_in_month% else 0));
  
export %freedays_in_month% =
  default(%nr_qualifying_in_publ_period%, pp.%days_in_published%);
  
export %req_freedays_in_month% = %req_freedays_in_month_incl_prev_month%;

export %req_freedays_in_month_incl_prev_month% = 
       nmax(%min_required_in_1_month_wop_indep%,
            %required_freedays_2_months_in_month_wop_indep%)
       - (if crew.%k4exng_cc_sp5_1_valid%(fundamental.%pp_start%) then %required_pt_freedays_in_month% else 0);

export %req_freedays_in_month_incl_prev_by_month_start%(abstime month_start, bool incl_non_qual_days) = 
    let start_t = round_down_month(month_start),
        end_t = round_up_month(start_t + 0:01);
    nmax(%required_freedays_2_months_in_month_by_month_start%(month_start),
         %min_required_in_1_month_by_month_startdate%(crew.%variable_group_start%(start_t,end_t),
                                                      crew.%variable_group_end%(start_t,end_t)) +
         (if incl_non_qual_days then %req_lh_freedays_in_month_skd%(start_t, end_t) else 0));
      
/*
** Two months requirement validity - also used from rule 
*/
export %required_freedays_2_months_in_month% = 
  if %cabin_crew% then
    if %r_valid_freedays_in_2_months% then
      %min_required_in_2_months% -
      accumulators.%qual_freedays_in_period%(%prev_month_start%, wop.%start_month_start%)
    else
      0
  else
    if %r_valid_freedays_in_2_months% then
      %min_required_in_2_months% -
      accumulators.%qual_freedays_in_period%(%prev_month_start%, wop.%start_month_start%)
    else
     0;
     
export %required_freedays_2_months_in_month_wop_indep% = 
  if %cabin_crew% then
    if %r_valid_freedays_in_2_months_wop_indep% then
      %min_required_in_2_months_wop_indep% -
      accumulators.%qual_freedays_in_period%(round_down_month(%pp_start%-00:01), %pp_start%)
    else
      0
  else
    if %r_valid_freedays_in_2_months_wop_indep% then
      %min_required_in_2_months_wop_indep% -
      accumulators.%qual_freedays_in_period%(round_down_month(%pp_start%-00:01), %pp_start%)
    else
      0;

export %r_valid_freedays_in_2_months_wop_indep% =
  %r_valid_freedays_in_2_months_by_date%(%pp_start%);
  
export %r_valid_freedays_in_2_months_by_date%(abstime date_hbt) =
  if %cabin_crew% then
    (crew.%is_SKD% or
     (crew.%is_skn% and not crew.%is_fulltime_temp_SKN%)) and
    fundamental.%even_month%
  else
    crew.%is_short_haul%(date_hbt) and
    not crew.%is_fdrc%(date_hbt);

export %required_freedays_2_months_in_month_by_month_start%(abstime month_start_hbt) = 
  if %cabin_crew% then
    if %r_valid_freedays_in_2_months_by_month_start%(month_start_hbt) then
         %min_required_in_2_months_by_month_start%(month_start_hbt) -
         accumulators.%qual_freedays_in_period%(round_down_month(month_start_hbt-00:01), month_start_hbt)
    else
      0
  else
    if %r_valid_freedays_in_2_months_by_date%(month_start_hbt) then
      %min_required_in_2_months_by_month_start%(month_start_hbt) -
      accumulators.%qual_freedays_in_period%(round_down_month(month_start_hbt-00:01), month_start_hbt)
    else
      0;

export %nr_freedays_in_publ_period% =
    sum(trip(chain), trip.%days_in_period%(%pp_start%, %publ_period_end%))
    where (trip.%is_freeday% and
           trip.%in_publ_period%);/*
            overlap(leg.%start_hb%, leg.%end_hb%,%pp_start%, %publ_period_end%)/24:00)
        where
        ( task.%is_freeday%(leg.%code%)/*(leg.%code% = "F" or leg.%code% = "F4")*/ /*and
         overlap(leg.%start_hb%, leg.%end_hb%,%pp_start%, %publ_period_end%) > 00:00
        );*/

export %nr_pt_freedays_in_publ_period% =
  sum(trip(chain), trip.%days_in_period%(%pp_start%, %publ_period_end%))
  where(trip.%is_pt_freeday% and
        trip.%in_publ_period%);
        
/* Free weekend assignment */
%first_weekend_in_pp% = round_down_week(%pp_start%) + %f4_start_tow%;

%weekends_in_pp% =
  (round_up_week(%pp_end%) - round_down_week(%pp_start%))/(7*24:00) -
  %border_correction%;

%border_correction% =
  if fundamental.%day_of_week%(%pp_end%) < 7 then 1
  else 0;

%weekend_ix% =
  %first_weekend_in_pp% + (%py_index%-1)*7*24:00;
  
%saturday_ix% =
  round_up_week(%weekend_ix%) - 48:00;
  
%f4_ok_on_weekend_ix% =
  if crew.%has_agmt_group_ski_fd% then
    %f4_ok_on_weekend%(%weekend_ix%) and not %prior_f4_ok_on_weekend%(%weekend_ix%)
  else False;

%_prior_f4_ok%(Abstime d) =
  if d<%pp_start% then False
  else %f4_ok_on_weekend%(d);

%prior_f4_ok_on_weekend%(Abstime d) =
  %_prior_f4_ok%(d-7*24:00) or
  %_prior_f4_ok%(d-14*24:00) or
  %_prior_f4_ok%(d-21*24:00) or
  %_prior_f4_ok%(d-28*24:00);

%f4_ok_x%(Int ix) =
   %f4_ok_on_weekend%(%first_weekend_in_pp% + (ix-1) * 7*24:00);
%f4_ok_1% = %f4_ok_x%(1);
%f4_ok_2% = %f4_ok_x%(2);
%f4_ok_3% = %f4_ok_x%(3);
%f4_ok_4% = %f4_ok_x%(4);
%f4_ok_5% = %f4_ok_x%(5);


%we_repr%(Abstime d) = 
  round_down_week(d) + %f4_start_tow%;
 
export %f4_ok_on_duty% =
  %f4_ok_on_weekend%(%we_repr%(duty.%start_hb%));
 
/* If Saturday is last in month, we might need to assign F4 outside
*  PP since it is Saturday (for FC SKD only) that decides which month
*  free weekend belongs to. 
*  If crew has free weekend earlier in month, no carry out is needed 
* 
*  NB! first(wop(chain)) is used to get a chain dependant variable */
%f4_carry_out_needed% =
  %free_we_period_is_month% and %free_we_period_end% >= %pp_end% and
  not default(accumulators.%last_free_weekend%(freedays.%free_we_period_end% - 7 * 24:00)
              >= first(trip(chain), %free_we_period_start%), false);

/* The supplied date should be the weekend start (typically friday),
   but F4 should be assigned on saturday, so group affiliation is 
   checked on saturday */
%f4_ok_on_weekend%(Abstime weekendstart) =
  crew.%in_variable_group%(round_up(weekendstart, 24:00)) and
  not %non_available_weekend%(weekendstart) and
  not recency.%all_quals_unrecent_at_date%(weekendstart);
  
%non_available_weekend%(Abstime weekendstart) =
  default(first(trip(roster), true)
          where (trip.%start_hb% < weekendstart + %free_we_length% and
                 trip.%end_hb% > weekendstart and
                 %trip_overlaps_weekend%(weekendstart) and
                 trip.%is_on_duty%),
          false);
  
%trip_overlaps_weekend%(Abstime weekendstart) =
  let saturday = round_up(weekendstart, 24:00);
  if trip.%is_allowed_on_free_weekend% then
    overlap(trip.%start_hb%, trip.%end_hb%, saturday, saturday + 48:00) <> 0:00
  else 
    if trip.%is_blank_day% then
      false
    else
      overlap(trip.%start_hb%, trip.%end_hb%, weekendstart, weekendstart + %f4_length%) <> 0:00;
      
/* new implementation per 2016-02-23 in base_calendar, filters on country in first step,
   which actually makes spec_weekend_ok_ix useless.
   Currently the code is not used; it was used by post op assignment script, but not any more
 */
%crew_country% = 
  crew.%country_at_date%(%pp_start%);


/********************
*** Super Freedays **
********************/

export %FS_days_are_scheduled_correct% =
  %FS_days_in_sequence% or
  %nr_freedays_around_FS% >= %min_freedays_in_cnx_with_FS%;

%FS_days_in_sequence% =
  trip.%days% >= 2 or
  (default(prev(trip(roster), trip.%is_fs%), false) and 
   trip.%no_days_btw_trips_bwd%) or 
  (default(next(trip(roster), trip.%is_fs%), false) and 
   trip.%no_days_btw_trips_bwd%); 

%nr_freedays_around_FS% = 
  prev(trip(roster), %freedays_FS%) 
  where (not trip.%is_off_duty% or trip.%is_FS%) +
  %freedays_FS%; 

export %freedays_FS% = 
  (%freedays_end_day% - trip.%rest_start_day%) / 24:00;
%freedays_end_day% =
  next(trip(roster), trip.%rest_end_day_before%)
  where (not trip.%is_off_duty% or trip.%is_FS%);

%min_freedays_in_cnx_with_FS% = 1;

export %super_freedays_in_period%(Abstime start, Abstime stop) =
  sum(wop(chain), wop.%super_freedays_in_period%(start, stop));
  
export %super_freedays_in_period_from_account%(Abstime start, Abstime stop) =
  abs(compdays.%balance_at_date%("FS", stop) -
  compdays.%balance_at_date%("FS", start)) / 100;

%min_required_freedays_after_wop% =
  if wop.%end_hb% + 24:00 <= %publ_period_end% or
     wop.%should_have_carry_out_freedays%
  then
    default(last(duty(wop), %min_required_freedays_after_duty%) where (not duty.%is_off_duty_cmp%), 0)
  else
    0;
  
export %min_required_freedays_after_duty_total% =
    %min_required_freedays_after_duty% +
    %min_required_pt_freedays_after_duty%;
    
export %number_of_days_until_next_on_duty_wop% =
  if %_wop_is_on_duty% then
    (default(next(wop(chain) where(%_wop_is_on_duty%), %_wop_start_on_duty_hb%), 
             31Dec2035) - %_wop_end_on_duty_hb%) / 24:00
  else
    0;

%_wop_is_on_duty% = wop.%is_on_duty% and any(duty(wop), not duty.%is_off_duty_cmp%);

%_wop_start_on_duty_hb% = 
  if %_wop_is_on_duty% then
    first(duty(wop), duty.%start_hb%) where(not duty.%is_off_duty_cmp%)
  else
    void(abstime);

%_wop_end_on_duty_hb% =
  if %_wop_is_on_duty% then
    last(duty(wop), duty.%end_hb%) where(not duty.%is_off_duty_cmp%)
  else
    void(abstime);

/*
** Single freeday is allowed:
** In case qa, always, if only oma16 rules fulfilled (2 local nights)
** In caes sk or skn_cc:
**  1. for sk_fd sh ( cc se for some time, now withdrawn), 
**  2. on saturday, or on red letter days (but not non holiday sundays)
**  3. Total time off is >= 40 h, for skn_cc is atleast 38 h
**  4. duty before and and after should be each max 4 days, and together max 6 days
*/
%sunday_skn%(abstime f_day) = ((calendar.%wd_from_abs%(f_day) = calendar.%sunday%) and crew.%has_agmt_group_skn_cc%);

%_is_qualifying_single_freeday_sk% =
  let  work_period_days_before = (duty.%end_day% - wop.%start_day%) / 24:00 + 1,
    rest_start = duty.%end_hb%,
    f_day = duty.%end_day% + 24:00;
  if not crew.%has_agmt_group_svs%  /* SVS can have single freeday on any day */
     and not ((calendar.%wd_from_abs%(f_day) = calendar.%saturday%)
              or %sunday_skn%(f_day)
              or %is_single_freeday_holiday%(f_day)) then
      "NO" /*"Single freeday not on saturday or holiday" */
  else if crew.%spec_sched_unbid_single_f%(f_day) then
      "Crew has bidded avoid single freeday (spec sched)"
  else next(duty(chain), %is_next_next_qualifying_single_freeday%(work_period_days_before, rest_start))
       where (duty.%is_on_duty%);

%is_qualifying_single_freeday% =
  let tm = duty.%end_hb_selection_possible_after%(duty.%duty_sel_freeday%) - round_up(duty.%end_hb%, 24:00);
  if crew.%has_agmt_group_svs% and %freedays_after_duty% > 1 then "NO" /* SVS: catch >1 assigned freeday */
  else if not duty.%arrives_at_homebase% or prev(duty(roster), duty.%is_long_haul%) then "NO"
  else if duty.%is_ac_employer_qa% then /* qa: two local nights required, not two days */
      if tm>=30:00 and tm<48:00 then "OK" /* <30 = no local night, > 47:59: not single */
      else "NO"
  else if not crew.%has_agmt_group_sk_sh_fd%
       and not (crew.%has_agmt_group_skn_cc% and system_db_parameters.%cba16_nov_valid%(wop.%start_day%))
       and not crew.%has_agmt_group_svs% then
       "NO" /*"Agreement does not allow single freeday"*/
  else if tm<24:00 or (not crew.%has_agmt_group_svs% and tm>=48:00) then
       "NO" /* If the gap is too short or too long then not single day off.
               SVS: gap can be long */
  else %_is_qualifying_single_freeday_sk%;

/* this calculates limits after single, according to SAS agreements: max 4 days after, max 6 days in total.
   it does not check if it's the right conditions for single f in any way, and not that sas rules are appleid */
%_pre_pre_on_duty%(Abstime start_f) =
  default(
    prev(wop(chain), wop.%end_day% + 24:00 = start_f and wop.%is_on_duty%),
    false);
 
%_pre_is_single_f%(Abstime start_prod) =
  default(
    prev(wop(chain),
      wop.%end_hb% = start_prod and wop.%days% = 1 and wop.%is_freeday% and %_pre_pre_on_duty%(wop.%start_hb%)),
    false);


export %max_days_after_singlef% =
  /*if default(prev(wop(chain), wop.%days%=1 and wop.%is_freeday%),False) then*/
  if %_pre_is_single_f%(wop.%start_day%) then
      nmin(4,6 - %_pre_pre_prod_days%)
  else
      99; /* no limit */

%_pre_pre_prod_days% =
  default(
    prev(wop(chain),
      prev(wop(chain),
        if wop.%has_production% or wop.%has_ground_duty% then wop.%days% else 0
      )
    )
  ,
    0
  );

%is_single_freeday_holiday%(AbsTime date) =
  base_calendar.%is_holiday_cat%(date, crew.%country_at_date%(date), base_calendar.%hol_cat_single_freedays%);

/* for counting freedays in holes in wops that are allowed as freedays should also be counted */
export %wop_possible_single_freedays%(Abstime start, Abstime stop) =
  count(duty(wop))
  where (not is_last(duty(wop)) and  duty.%is_on_duty% and (duty.%end_day%+24:00>= start) and (duty.%end_day%+24:00< stop ) and (%is_qualifying_single_freeday%="OK") ); 

/* check if duty is followed by a single day gap, and next duty is on duty */
%has_single_day_gap%(Abstime cur_end_day) =
  next(duty(chain), duty.%is_on_duty% and duty.%start_day% = cur_end_day + 48:00);

/* counting single day gaps not qualifying as freedays */
export %single_day_gaps_not_freedays%(Abstime s, Abstime e) =
  count(duty(chain))
  where (duty.%is_on_duty% and (duty.%end_day% + 24:00 >= s) and (duty.%end_day% + 24:00 < e) and %has_single_day_gap%(duty.%end_day%)
    and not (%is_qualifying_single_freeday%="OK")); 

/*check if duty is followed by gap bigger than 2 days, and that the next duty is in same trip*/
%has_two_day_gap%(Abstime cur_end_day) =
  default(next(duty(trip), duty.%is_on_duty% and duty.%start_day% >= cur_end_day + 72:00), false);

/* counting two day gaps not qualifying as freedays, e.g. SFO */
export %two_day_gaps_not_freedays%(Abstime s, Abstime e) =
  sum(duty(chain), %two_day_gaps_not_freedays_value%(s, e))
    where (duty.%is_on_duty% and %has_two_day_gap%(duty.%end_day%) and not (%is_qualifying_single_freeday%="OK")); 

/*first if-statement is for trips with 2 day gaps over the turn of the month where 1 F-day is placed in month 1 and the other in month 2*/
export %two_day_gaps_not_freedays_value%(Abstime s, Abstime e) =
  if (duty.%end_day% + 48:00 = e) or (duty.%end_day% + 48:00 = s) 
    then 1
       else if (duty.%end_day% + 24:00 >= s) and (duty.%end_day% + 24:00 < e) 
       then 2
 else 0;

%wop_singlef_hole_allowed%(Abstime start, Abstime stop) =
  min(duty(wop), duty.%end_day% + 24:00)
  where (not is_last(duty(wop)) and  duty.%is_on_duty% and (duty.%end_day%+24:00>= start) and (duty.%end_day%+24:00< stop ) and (%is_qualifying_single_freeday%="OK") );       

export %wop_singlef_hole1_allowed_pp% =
  default(
    %wop_singlef_hole_allowed%(%pp_start%,%pp_end%),
    base_utils.%abstimemin%);

export %wop_singlef_hole2_allowed_pp% =
  default(
    %wop_singlef_hole_allowed%( /* get second hole */
      %wop_singlef_hole_allowed%(%pp_start%,%pp_end%)+24:00, /* get end of first hole */
      %pp_end%),
    base_utils.%abstimemin%);
 
%_wop_work_before_single_f%(Abstime start, Abstime stop) =
  let s = nmax(start, wop.%start_day%);
  max(duty(wop), (duty.%end_day%+24:00 - s)/24:00)
  where (duty.%is_on_duty% and (duty.%end_day%>= start) and (duty.%end_day%< stop - 24:00) and (%is_qualifying_single_freeday%="OK") ); 
      
export %wop_max_work_with_single_f%(Abstime start, Abstime stop) =
  let ret = default( %_wop_work_before_single_f%(start, stop), -1); 
  nmax(ret, %wop_work_days%-ret-1) ;

  

/* note: it could be that the duty should be checked for category, but it seems not necessary. 
** if single f is followed by vacation etc, the general rule is fulfilled anyway so it seems not important if this is fully correct
*/
%min_time_off_single_f% =
    if crew.%has_agmt_group_skn_cc% then
        38:00
    else if crew.%has_agmt_group_svs% then
        36:00
    else
        40:00;


/* SVS freeday does not worry about work period length */
%is_next_next_qualifying_single_freeday%(int prev_work_period_days, Abstime rest_start) =
  let work_period_days = (wop.%end_day% - duty.%start_day%) / 24:00 + 1;
  if (not duty.%is_blank_day% and not %prev_duty_is_fs1% and duty.%start_hb% - rest_start < %min_time_off_single_f%) then
    rules.%failtext_rel%("Min rest when single freeday",duty.%start_hb% - rest_start, %min_time_off_single_f%)
  else if not crew.%has_agmt_group_svs% and prev_work_period_days>4 then
    rules.%failtext_int%("Workdays before single freeday",prev_work_period_days,4)
  else if not crew.%has_agmt_group_svs% and work_period_days>4 then
    rules.%failtext_int%("Workdays after single freeday",work_period_days,4)  
  else if not crew.%has_agmt_group_svs% and (prev_work_period_days+work_period_days)>6 then
    rules.%failtext_int%("Workdays around single freeday",prev_work_period_days+work_period_days,6)
  else "OK"; /* Qualifying */

%prev_duty_is_fs1% = default(prev(duty(chain), duty.%is_fs1%), false);

export %min_required_freedays_after_duty% =
  if duty.%is_on_duty% then
    if duty.%is_off_duty_cmp% then
      0
    /*
    ** FD VG do not need F days before LA days if wop < 5 days*/
    else if %_min_required_freedays_replaced_by_LA_days% then
      0
    /* if it is a single freeday after, and that is allowed, "1" is set */
    else if %is_qualifying_single_freeday%="OK" then
      1
    /* CC has a requirement of only 2 freedays after
    ** certain ground-duties */
    else if %non_qualifying_ground_duty_period% then
      2
    else if %flight_crew% and crew.%is_ski% then
       %min_required_freedays_after_duty_ski%
    /* 4ExNG: all CC require 2 F-days after a standby line.
    ** Before 4ExNG: 100% crew should only have 2 freedays after SB lines,
    ** others should have 3 freedays */
    else if wop.%is_standby_line% then
      if crew.%k4exng_cc_sp5_1_valid%(wop.%start_day%) or
         crew.%part_time_factor% = 100 then
    	2
      else
        3
    /* SVS wop length does not matter, but if not a qualifying single
       freeday (handled above) it should be at least a 2 day 60:00 block */
    else if crew.%has_agmt_group_svs% then
        2
    else
      if crew.%k4exng_cc_sp5_1_valid%(wop.%start_day%) then
        %min_required_freedays_after_duty_all%
      else
        %_min_required_freedays_after_duty%
  else
  	0;

export %min_required_freedays_after_duty_failtext%(Int value, Int limit) =
  let single_ft = %is_qualifying_single_freeday%;
  if single_ft="OK" or single_ft="NO" then
    rules.%failtext_int%("Coll: F-days after prod(duty)", value, limit)
  else concat("Coll: ",single_ft);





%standby_or_bl_ccr% =
  any(duty(wop),duty.%is_standby% or duty.%is_blank_day%); 

table min_required_after_duty_4exng =
  crew.%main_func%,
  %wop_days%,
  %wop_is_short_haul%,              
  %wop_is_long_haul%,
  %standby_or_bl_ccr%,
  %any_offduty_may_replace_one_freeday%
                     -> export %min_required_freedays_after_duty_all%;

  "C", <5  , true , false,   -  ,   -    -> 2; /* SH 1-4 P-days */
  "C",  5  , true , false,   -  , true   -> 2; /* SH 5 P-days, 3 time-off days */
  "C",  5  , true , false,   -  , false  -> 3; /* SH 5 P-days, 2 time-off days */
  "C",  -  , false, true ,   -  , true   -> 2; /* LH */
  "C",  -  , false, true ,   -  , false  -> 3; /* LH */
  "C", <5  , false, false, true ,   -    -> 2; /* 1-4P incl. sby or BL */
  "C",  5  , false, false, true , true   -> 2; /* 5P incl. sby or BL, 3 time-off days */
  "C",  5  , false, false, true , false  -> 3; /* 5P incl. sby or BL, 2 time-off days */
  "C",  -  , false, false, false,   -    -> 2; /* ground duty days */

  "F",  -  ,   -  ,   -  ,   -  ,   -    -> %_min_required_freedays_after_duty%;  

   - ,  -  ,   -  ,   -  ,   -  ,   -    -> 99;  
end  


/* count freedays following last duty in wop. In ccr gaps are allowed to be filled in later */
export %count_mixed_freedays_following_last_duty_in_wop% =
  duty.%days_selection_possible_after%(duty.%duty_sel_freedays_mix%, %abstimemax%);

export %count_freedays_following_last_duty_in_wop% =
  duty.%days_selection_possible_after%(duty.%duty_sel_freeday%, %abstimemax%);

export %count_cau1412_662_regarded_as_freedays% =
  %count_mixed_freedays_following_last_duty_in_wop%;

/* number of required freedays if conditions met */
export %min_freedays_cau1412_662% = 4;

/* the wop conditions for cay 2014-12 6.6.2 */
export %is_last_duty_in_wop_cau1412_662% =
  is_last(duty(wop)) AND /* rule is checked for last duty in wop only. */
  wop.%is_long_haul% AND
  wop.%start_days_sh_possible% = 2;

%_min_required_freedays_replaced_by_LA_days% =
  let duty_end_day = duty.%end_day%;
  %flight_crew% and
    default(crew.%days_in_period%(duty.%end_day%, next(duty(chain), duty.%start_day%) where
                                  (not duty.%is_LA%)) > %_min_required_free_or_LA_or_open_days%, false) and
    crew.%in_variable_group_ppstart% and (wop.%days% < 5 or crew.%is_long_haul%(duty.%end_hb%)) and
    not default((next(duty(chain), duty.%is_vacation%) where
         (not duty.%is_freeday% and not duty.%is_LA%) while
         (crew.%days_in_period%(duty_end_day, duty.%start_day%) < 20)), false);

%_min_required_free_or_LA_or_open_days% =
    if crew.%is_ski% then
      %min_required_freedays_after_duty_ski%
    else
      %_min_required_freedays_after_duty%;

%min_required_freedays_after_duty_ski% = 
    /* Below code is also implemented in report_common, as
     * variable %req_freedays_after_trip%. If change, please apple this to report_common too.
     */
    if wop.%has_active_long_haul% then
        if crew.%is_skj% then
            4
        else
            3
    else
        2
    ;


/** 
*** Used for soft rule and assign script.
*** Since the min limit is parameterized we don't want to affect 
*** original ind_rules.
**/
%min_required_freedays_after_wop_soft% =
  if wop.%end_hb% + 24:00 <= %publ_period_end% or
     wop.%should_have_carry_out_freedays%
  then
    default(last(duty(wop), %min_required_freedays_after_duty_soft%) where (not duty.%is_off_duty_cmp%), 0)
  else
    0;

export %min_required_freedays_after_duty_total_soft% =
  if crew.%part_time_factor% = 100 then
    %min_required_freedays_after_duty_soft%
  else
    %min_required_pt_freedays_after_duty_soft%;

export %min_required_freedays_after_duty_soft% =
  if wop.%is_standby_line% then
    if crew.%part_time_factor% = 100 then
      %required_freedays_after_standby_line%
    else
      %required_freedays_after_standby_line_pt%
  else if crew.%is_ski% then
    %min_required_freedays_after_duty_ski%
  else
    %min_required_freedays_after_duty%;

%min_required_pt_freedays_after_duty_soft% =
  if wop.%is_standby_line% then
    %required_freedays_after_standby_line_pt%
  else if duty.%is_on_duty% then
    %_min_required_pt_freedays_after_duty%
  else
    0;

%required_freedays_after_standby_line% =
  if crew.%is_cabin% or crew.%is_ski% then
    %required_freedays_after_standby_line_p%
  else 
    2;

%required_freedays_after_standby_line_pt% =
  if crew.%is_cabin% or crew.%is_ski% then
    %required_freedays_after_standby_line_pt_p%
  else 
    3;

%required_freedays_after_standby_line_p% =
  parameter 2
  remark "Minimum required freedays after Standby Line (SKI and CC)";

%required_freedays_after_standby_line_pt_p% =
  parameter 3
  remark "Minimum required freedays for parttime after Standby Line (SKI and CC)";

%prev_wop_has_2_pilots_and_2_freedays% =
    default(prev(wop(roster),wop.%has_2_pilot_long_haul% and
            last(duty(wop),freedays.%freedays_after_duty%) = 2) 
            where (wop.%is_on_duty%),
			false);

%destination_has_freeday_exception% = 
    any(leg(wop), leg.%arrival_airport_name% in freeday_exception_destination_set);
    
set freeday_exception_destination_set =
  parameter "BKK", "NRT", "SEA"
  remark "Destinations that require 3 freedays for all production(SKI) - NB! Not used after K11";

%destination_has_2_pilot_freeday_exception% = 
    wop.%has_2_pilot_long_haul% and
    any(leg(wop), leg.%arrival_airport_name% in freeday_exception_destination_2_pilot_set);
    
set freeday_exception_destination_2_pilot_set =
  parameter "EWR", "IAD", "ORD"
  remark "Destinations that require 3 freedays for 2-pilot production(SKI) - NB! Not used after K11";

export %east_to_west_or_west_to_east% =
    default(%east_to_west% or 
            %west_to_east%, 
            false);

%east_to_west% =
    wop.%is_east_bound% and 
        next(wop(roster),
             first(trip(wop), trip.%is_west_bound%)) where (wop.%is_on_duty%);
                
%west_to_east% = 
    wop.%is_west_bound% and
        next(wop(roster),
             first(trip(wop), trip.%is_east_bound%)) where (wop.%is_on_duty%);
/*
 * Some variables to assist AssignPostOpFreedays with the correct assignment of 
 * F4 on weekends and special weekends when they occur within the required freedays
 * after production.
 *
 * Find the first day of the next weekend or special weekend which occurs in the 
 * required freedays after production. If there is no possible F4 days within the 
 * time-frame we should return void to further assist the python script.
 */
%required_freedays_after_wop_contains_possible_f4_saturday% = 
    last(duty(wop), %required_freedays_after_duty_contains_possible_f4_saturday%);

%required_freedays_after_duty_contains_possible_f4_saturday% = 
  let saturday = round_up_week(duty.%end_hb%) - 48:00,
      we_end = saturday + (if duty.%is_last_on_duty_in_month% then 48:00 else 24:00);
  if duty.%end_hb% <= saturday - 24:00 + %free_we_latest_start% and
     default(next(duty(chain), duty.%start_hb% > saturday + 48:00 + %free_we_earliest_end%) where(not task.%is_allowed_on_free_weekend%(duty.%code%)), true) and
     duty.%end_day% + (%min_required_freedays_after_duty_soft% + 1) * 24:00 >= we_end
  then
    saturday
  else 
    void_abstime;


export %non_qualifying_ground_duty_period% =
  %cabin_crew% and 
  (wop.%is_only_ground_duty% and not wop.%is_blank_day%) and
  (%wop_is_not_qualifying_for_freedays_common% or
   %wop_is_not_qualifying_for_freedays%);

table non_qualifying_for_freedays =
  crew.%region_at_date%(wop.%start_hb%) -> %wop_is_not_qualifying_for_freedays%;
  "SKS" -> %wop_is_not_qualifying_for_freedays_sks%;
  "SKN" -> %wop_is_not_qualifying_for_freedays_skn%;
  "SKD" -> %wop_is_not_qualifying_for_freedays_skd%;
     -  -> false;
end

%wop_is_not_qualifying_for_freedays_common% =
  all(duty(wop), duty.%code% in gd_not_qualifying_freeday_set)
  where(not duty.%is_bought%);

%wop_is_not_qualifying_for_freedays_skd% =
  wop.%is_ground_duty% or
  all(duty(wop), duty.%is_ground_duty%)
  where(not duty.%is_bought%);
  
%wop_is_not_qualifying_for_freedays_skn% =
  all(duty(wop), duty.%code% = "MT12")
  where(not duty.%is_bought%);
  
%wop_is_not_qualifying_for_freedays_sks% =
  wop.%days% >= 5 and
  all(duty(wop), duty.%group_code% in freeday_exception_set)
  where(not duty.%is_bought%);
  
set gd_not_qualifying_freeday_set = "KD", "GD";  
set freeday_exception_set = "COD","OFD","REC","SGD","MET";

%min_required_pt_freedays_after_duty% =
  if not crew.%k4exng_cc_sp5_1_valid%(duty.%start_day%) and
     duty.%is_on_duty% and
     not duty.%is_off_duty_cmp% then
    %_min_required_pt_freedays_after_duty%
  else
    0;

/*
 * SKS/SKN SH FC should normally have 3 F-days after 5 production days. but
 * 2 F-days plus any other off-duty activity (e.g. VA, F7 etc.) is allowed.
 */

export %any_offduty_may_replace_one_freeday% =
  %freedays_after_duty% = 2 and
  default(next(wop(roster),wop.%is_off_duty%)
            where (not wop.%is_freeday%),
          false);
 
table min_required_after_duty =
  crew.%main_func%,
  wop.%start_hb%,
  crew.%region%,
  %wop_days%,
  %wop_is_short_haul%,              /* Any trip is short haul but no trip is long haul */
  %wop_is_long_haul%,               /* Any trip is long haul */
  %wop_has_ground_duty%,            /* Any trip is ground duty */
  %next_duty_is_isolated_FS%,       /* Production followed by super freeday */
  %wop_has_standby%,                /* Any trip is standby */
  %wop_has_short_standby_block% or wop.%is_blank_day%, /* Any trip is short standby */
  training.%wop_is_in_school_period_min_7x24%,  /* Is part of course > 7 days duration */
  %any_offduty_may_replace_one_freeday% ->  /* 5P=3F - any offduty may replace 1 F-day */
    export %_min_required_freedays_after_duty%,
    export %_min_required_pt_freedays_after_duty%;
  /* FC SKD SH should always have 2F after 5 production days. */
  /* but from 01jun11, they must have 3F                      */
  "F", < 01jun11,  "SKD", >4, -    , -    , -    , -    , -    , - , false, -      -> 2, 0;
  /* FC on course > 7 days duration should always have 2F after 5 production days. */
  "F",      -    ,   -  , >4, -    , -    , -    , -    , -    , - , true, -       -> 2, 0;
 &
  "F",  -    , <> "SKI", - ,   -  , -    , -    , true ,   -  ,   -  , -, -   -> 1, 0; /* FC SH followed by isolated FS */
 &
 /* FC 1.11 G */
  "F",  -    ,   -  , >4, false, false, -    , false, false, - , -, true      -> 2, 0;
  "F",  -    ,   -  , >4, false, false, -    , false, false, - , -, false     -> 3, 0;
 /* FC SH (except SKD before 01jun11) should have 3F after 5 days production or standby */
  "F",  -    ,   -  , >4, -    , -    , -    , -    , true , - , -, true      -> 2, 0;
  "F",  -    ,   -  , >4, -    , -    , -    , -    , true , - , -, false     -> 3, 0;
  "F",  -    ,   -  , >4, true , -    , -    , false, false, - , -, true      -> 2, 0;
  "F",  -    ,   -  , >4, true , -    , -    , false, false, - , -, false     -> 3, 0;

  "F",  -    ,   -  , <5, true , -    , -    , false, -    , false, -, -  -> 2, 0;
  "F",  -    ,   -  , - , false, true , -    , -    , false, false, -, -  -> 3, 0;
 
  /* CAU J, L and P */
  "C", -, "SKD", -,  true,     -,    -,   -, -,       -, -, -   -> %cc_sh_freedays_skd_duty%, %cc_sh_pt_freedays_skd_duty%;
  "C", -, "SKD", -, false,  true,    -,   -, -,       -, -, -   -> %cc_lh_freedays_skd_duty%, 0;
  "C", -, "SKD", -, false, false,    -,   -, -,    true, -, -   -> %cc_sh_freedays_skd_duty%, %cc_sh_pt_freedays_skd_duty%;
  
  /* NKF/SBK 2.4.3.4 */
  "C", -, "SKN", >=5,  true,     -, false,    -, -,     -, -, true  -> %skn_cc_k11_freedays%, 0;
  "C", -, "SKN", >=5,  true,     -, false,    -, -,     -, -, false -> 3, 0;
  "C", -, "SKN", >=5, false, false, false,    -, -,  true, -, true  -> %skn_cc_k11_freedays%, 0;
  "C", -, "SKN", >=5, false, false, false,    -, -,  true, -, false -> 3, 0;
  "C", -, "SKN", >=5, true,    -,   true,  -, -,   false, -, true   -> %skn_cc_k11_freedays%, 0; /* Mix of ground duty and short haul */
  "C", -, "SKN", >=5, true,  false, true,  -, -,   false, -, false  -> 3, 0; /* Mix of ground duty and SH */
  "C", -, "SKN", >=5, false, false, true,  -, true, true, -, false  -> 3, 0; /* Mix of ground duty and SH standby block*/
  "C", -, "SKN", >=5, false, false, true,  -, true, false, -, false -> 3, 0; /* Mix of ground duty and SH standby */
  "C", -, "SKN", <5, true,    -,   false, -, -,   false, -, -   -> 2, 0;
  "C", -, "SKN", <5,  true,    -,   true,  -, -,   false, -, -   -> 2, 0; /* Mix of ground duty and short haul */
  "C", -, "SKN", -,  false, true,    -,   -, -,   false, -, -   -> %cc_lh_freedays_skn_duty%, 0;
  
  /* SCCA H and N.3a */
  "C", -, "SKS", >4,    -,    -,     -,   -, -,   -, -, -       -> 3, 0;
  &
  "C", -, "SKS", -,  true,    -,     -,   -, -,       -, -, -   -> 2, 0;
  "C", -, "SKS", -,  false, true,    -,   -, -,       -, -, -   -> 3, 0; /* SCCA K06 5.2 */
  
  /* Japanese CC 3.9 */
  "C", -, "SKJ", -,  false, true,    -,   -, -,       -, -, -   -> %cc_lh_freedays_skj_duty%,
                                                                   %cc_lh_pt_freedays_skj_duty%;
  /* Chines CC */
  "C", -, "SKK", -,  false, true,    -,   -, -,       -, -, -   -> %cc_lh_freedays_skk_duty%, 0;
  
  /* Only ground duty btw freedays */
   -,  -,   -,   -,  false, false, true,  -, -,   false, -, -   -> 2, 0;
  
  -, -, -, -, -, -, -, -, -, -, -, - -> 2, 0;
end


/* Only CC SKD has a part time dependency */
table cc_sh_freedays_skd_duty =
  crew.%part_time_factor_duty_start%,
  %wop_days%,
  %wop_is_ground_duty%,
  %next_duty_is_F_followed_by_SFJ% ->
    %cc_sh_freedays_skd_duty%,
    %cc_sh_pt_freedays_skd_duty%;
  
  -, 1, false, true    -> 1, 0;
  
  50, -,  true, false  -> 2, 0;

  100, 5,   -, false   -> 3, 0;
  100, <5,  -, false   -> 2, 0;
  
   89, 5,   -, false   -> 3, 1;
   89, <5,  -, false   -> 2, 0;
  
   80, 5,   -, false   -> 3, 1;
   80, 4,   -, false   -> 2, 1;
   80, <4,  -, false   -> 2, 0;
  
   50, 5, false, false -> 3, 7;
   50, 4, false, false -> 2, 5;
   50, 3, false, false -> 2, 2;
   50, 2, false, false -> 2, 2;
   50, 1, false, false -> 2, 0;
  
   -,  -,  -, -  -> 0, 0;
end

table cc_min_required_after_lh_skd_duty =

  %wop_has_long_haul_charter_duty%,
  crew.%part_time_factor_duty_start% ->
    export %cc_lh_freedays_skd_duty%;

  true,   -    -> %cc_lh_charter_freedays_skd_duty%;
  false,  80   -> %cc_parttime_80_lh_freedays_skd_duty%;

    -  ,  -    -> %cc_fulltime_lh_freedays_skd_duty%;
end

/* Required F-days after production for Japanese CC*/

%cc_lh_freedays_skj_duty% = 4;

/* Required F-days after production for Chinese CC*/

%cc_lh_freedays_skk_duty% = 3;

/*
** Required part-time F88 days after production for Japanese CC
**
** 50% = Flight duty days + normal F-days
**
** 75% = (Flight duty days + normal F-days) / 2 rounded up.
*/

%cc_lh_pt_freedays_skj_duty% =
  if crew.%part_time_factor_duty_start% = 50 then
    %flight_duty_days_in_wop% + %cc_lh_freedays_skj_duty%
  else
    if crew.%part_time_factor_duty_start% = 75 then
      ((10 * (%flight_duty_days_in_wop% + %cc_lh_freedays_skj_duty%) / 2) + 5)/ 10 
    else
      0;

%flight_duty_days_in_wop% =
  (last(trip(wop),trip.%end_day% + 24:00)
     where (trip.%has_flight_duty% and not trip.%is_standby%) -
   first(trip(wop),trip.%start_day%)
     where (trip.%has_flight_duty% and not trip.%is_standby%)) / 24:00;

/* Agreement: NKF K11 */
%skn_cc_k11_freedays% =
  if parameters.%k11_skn_cc_valid%(%pp_start%) and
     default(next(wop(roster), wop.%is_off_duty% and (wop.%end_UTC% - wop.%start_UTC%) / 24:00 > 1)
             where (not wop.%is_freeday%), false)
  then 2
  else 3;

/* Agreement: CAU J.5. */
%cc_fulltime_lh_freedays_skd_duty% =
  if %wop_is_east_bound% then
    %cc_lh_freedays_skd_east_duty%
  else
    %cc_lh_freedays_skd_west_duty%;
    
/* Agreement: CAU J.5.a. Max of three alternatives. */
%cc_lh_freedays_skd_east_duty% =
  let A = if max(trip(wop), trip.%block_time%) from (current) backwards while(not trip.%is_bought%)
          <= 20:00 then 3 else 4,
      B = %roundup_div%(%wop_days%, 2),
      C = if %wop_is_non_stop_105_longitude_duty% then 4 else 3;
  nmax(A, B, C);
  
%wop_is_non_stop_105_longitude_duty% =
  any(duty(wop) from (current) backwards while(not duty.%is_bought%), 
      any(leg(duty), abs(leg.%leg_start_longitude% - 
      leg.%leg_end_longitude%) > 6300));
  
/* Agreement: CAU J.5.b */
%cc_lh_freedays_skd_west_duty% = nmax(3, %roundup_div%(%wop_days%, 2));

/* Agreement: CAU P.3.4
**
** Demand for 80% parttime is fulltime demand multiplied by 1.5
** if half freeday rest and outstanding half freeday from history
** or earlier in chain round up demand 1 day, else
** save the half freeday in 'half freeday' bank.
*/
%cc_parttime_80_lh_freedays_skd_duty% =
  if %cc_parttime_80_lh_is_half_freeday_wop% and
     not %cc_parttime_80_lh_half_freeday_round_down_is_valid% then
    (%cc_parttime_80_lh_freedays_basic_skd_duty% + 5) / 10
  else
    %cc_parttime_80_lh_freedays_basic_skd_duty% / 10;

/* Wop yields half freeday rest */
%cc_parttime_80_lh_is_half_freeday_wop% =
  crew.%is_skd% and
  crew.%part_time_factor_wop_start% = 80 and
  wop.%is_long_haul% and
  last(duty(wop), %cc_fulltime_lh_freedays_skd_duty% mod 2 = 1);

%cc_parttime_80_lh_freedays_basic_skd_duty% =
  %cc_fulltime_lh_freedays_skd_duty% * 15;
  
/* End date for rounded up freeday period after half free day wop */
%cc_parttime_80_lh_wop_freeday_period_end% =
  last(duty(wop), duty.%end_day% +
    24:00 * (1 + (%cc_parttime_80_lh_freedays_basic_skd_duty% + 5)/10));

/* 
** It is valid to round down number of freedays only if previous time was rounded up. 
** If no previous "half freeday" wop with freeday period overlapping planning period
** check instead for outstanding half freeday in history.
*/
%cc_parttime_80_lh_half_freeday_round_down_is_valid% =
  default(prev(wop(roster), last(duty(wop),
            %cc_parttime_80_lh_freedays_basic_skd_duty% < %freedays_after_wop% * 10))
          where (%cc_parttime_80_lh_is_half_freeday_wop% and
                 %cc_parttime_80_lh_wop_freeday_period_end% > %pp_start%),
          not %half_freeday_in_history%(%pp_start%));

/*
** Check for outstanding half freeday in history.
** True: Outstanding half freeday. False: No outstanding half freeday.
*/

%half_freeday_in_history%(Abstime date) = default(%half_freeday_lookup%(date), false);

%half_freeday_carry_over_p% =  parameter "half_freeday_carry_over"
  remark "ETAB: Half freeday carry over table";

table half_freeday_carry_over_tab(Abstime date) =
  crew.%id%, date -> bool %half_freeday_lookup%;
  external %half_freeday_carry_over_p%;
  crew, >= tim -> last(carry_over);
end

/*
 * Variables used by the script (roster publish) that updates
 * the tabel half_freeday_carry_over.
 */

export %half_freeday_carry_over_is_valid% =
  crew.%region% = "SKD" and
  %cabin_crew% and
  crew.%part_time_factor_pp_start% = 80;

export %half_freeday_carry_over%(Abstime a1, Abstime a2) =
  last(wop(roster), last(duty(wop),
       %cc_parttime_80_lh_freedays_basic_skd_duty% > %freedays_after_wop% * 10))   
  where (%cc_parttime_80_lh_is_half_freeday_wop% and
         %cc_parttime_80_lh_wop_freeday_period_end% <= a2 and
         wop.%end_day% > a1);

/*
 *Agreement: CAU K06 L.1, L.2.c
 *
 * Freedays after LH charter
 */
table cc_min_required_after_lh_charter_skd_duty =

  %two_consec_lh_charter_duties_night_stop_not_homebase%,
  crew.%part_time_factor_duty_start% ->
    %cc_lh_charter_freedays_skd_duty%;

  false,  100   -> 2;
  false,   80   -> 3;
  false,   50   -> 5;
  true,   100   -> 3;
  true,    80   -> 4;
  true,    50   -> 8;

    - ,    -    -> 99;
end

export %wop_has_long_haul_charter_duty% =
  any(duty(wop) from (current) backwards while(not duty.%is_bought%), 
      duty.%is_long_haul_charter_skd%);
  
/*
 *  True if there are 2 consecutive charter duty periods,
 *  where at least one is LH and the night stop between them
 *  is not at home base.
 */
 
%two_consec_lh_charter_duties_night_stop_not_homebase% =
   %num_charter_duties_duty% > 1 and
   any(duty(wop) from (current) backwards while (not duty.%is_bought%) 
   where (duty.%is_long_haul_charter_skd%),
     not duty.%arrives_at_homebase%);
    
%num_charter_duties_duty% =
  count(duty(wop)) from (current) backwards while (not duty.%is_bought%)
    where (duty.%is_charter% and
           duty.%is_active_flight%);
  
 
/* Agreement: NKF K11 2.4.5 */
/* Slingfreedays are also regulated by Subpart Q rules */
export %cc_lh_freedays_skn_duty% =
  nmax(if %wop_lh_east_followed_by_west_or_vv% then
         4
       else
         3,
       %roundup_div%(%wop_days%, 2));
    
%wop_is_east_bound% =
  any(duty(wop),duty.%is_east_bound%);
 
%wop_start_day% = 
  if is_first(duty(wop)) then
    duty.%start_day%
  else
    default(prev(duty(wop) where(duty.%is_bought%), next(duty(wop), duty.%start_day%)),
            wop.%start_day%);

export %wop_days% =
  wop.%days% -
  %f31_days_in_wop%  -
  %nr_off_duty_cmp_first_in_wop% -
  %nr_off_duty_cmp_last_in_wop%;
  
/* F31 is not included in wop-days */
%f31_days_in_wop% =
  sum(trip(wop), trip.%days%) where (trip.%code% = "F31");  
  
export %nr_off_duty_cmp_first_in_wop% = 
  default((first(duty(wop), duty.%start_day%)
             where(not duty.%is_off_duty_cmp%) - wop.%start_day%) / 24:00,
          0);
  
export %nr_off_duty_cmp_last_in_wop% =
  default((wop.%end_day% - last(duty(wop), duty.%end_day%)
             where(not duty.%is_off_duty_cmp%)) / 24:00,
          0);
  
%wop_is_short_haul% =
  wop.%is_short_haul%;
/*  
**  SFJ- trip is followed by single F-day and SFJ trip
*/
%next_duty_is_F_followed_by_SFJ% =
  default(wop.%days% = 1 and 
          all(trip(wop), trip.%is_one_day_greenland_return%) and
          next(wop(roster), wop.%is_freeday% and wop.%days% = 1 and 
          next(wop(roster), first(trip(wop), trip.%is_one_day_greenland_return%))),
         false);
  
%wop_is_long_haul% =
  wop.%is_long_haul%;
  
%next_duty_is_isolated_FS% =
  let fs_date = default(next(wop(roster), wop.%start_day%), 01jan1986),
      wop_end = wop.%end_day% + 24:00;
  crew.%is_skd% and
  default(next(wop(roster), wop.%is_FS% and wop.%start_day% = wop_end and
                            wop.%days% = 1 and
               next(wop(roster), wop.%start_day% = fs_date + 24:00)), false);
  
%wop_has_ground_duty% =
  wop.%has_ground_duty%; 

%wop_is_ground_duty% =
  wop.%is_ground_duty%;

%wop_has_short_standby_block% =
  wop.%has_short_standby_block%;

%wop_has_standby% = 
  wop.%has_standby%;

/* Will be redefined in Tracking and for Request Bidding */  
export %valid_freedays_after_duty% = %_valid_freedays_after_duty%;

%_valid_freedays_after_duty% =
  is_last(duty(wop)) where(not duty.%is_off_duty_cmp%) and
  (duty.%in_pp_extended% or
   duty.%is_last_on_duty_before_pp%) and
  duty.%is_on_duty% and
   any(trip(wop), trip.%is_on_duty% and not trip.%is_off_duty_cmp%);


  
/* Freeday agreement validity */
export %gm_agreement_valid%(Abstime date) =
  %agreement_valid%("gm_freedays", date);

/*
 * Free weekends in two (2) months fixed. (i.e.: Jan-Feb; Mar-Apr; ... ).
 */
 
export %has_3_free_we_2_months% = 
      not void(%free_we_2_months_1%) and
      not void(%free_we_2_months_2%) and
      not void(%free_we_2_months_3%);
  
%free_we_2_months_1% = accumulators.%last_free_weekend%(%free_we_2_months_fixed_end%);
%free_we_2_months_2% = accumulators.%last_free_weekend%(%free_we_2_months_1%);
%free_we_2_months_3% = 
  if accumulators.%last_free_weekend%(%free_we_2_months_2%) < %free_we_2_months_fixed_start% then
     void_abstime
  else accumulators.%last_free_weekend%(%free_we_2_months_2%);

%free_we_period_ref% = 
    nmin(trip.%start_month_end% - 00:01, %pp_end%);
export %free_we_2_months_fixed_end% = nmin(%_free_we_period_end%(7), %free_we_period_ref%);
export %free_we_2_months_fixed_start% = round_down_month(round_down_month(%free_we_2_months_fixed_end%) - 24:00);

/*
 * Free weekends in 3 months fixed, i.e.: Jan-Mar, Apr-Jun, Jul-Sep, Oct-Dec.
 */

/* The rule "Free weekend in three months" now uses the Sunday as the 
   starting point of the free weekend, SASCMS-3989 */

%round_up_sunday%(Abstime date) = round_up_week(date) - 24:00;

%season%(String main_cat) = 
    concat(main_cat, " AUTUMN");

%year%(Abstime year) = 
    (round_down_year(year) - 01jan1986) / (24:00*365) + 1986;

%nbr_of_xmas_freedays%(Abstime date) = 
    %_nbr_of_xmas_freedays%(date, crew.%id%, crew.%region%, %season%(fundamental.%main_cat%), %year%(%pp_start%));    

%activity_type%(Abstime date) = 
    %_activity_type%(date, crew.%id%, crew.%region%, %season%(fundamental.%main_cat%), %year%(%pp_start%)); 

export %xmas_group% = 
    %_xmas_group%(crew.%id%, %season%(fundamental.%main_cat%), %year%(%pp_start%));     

export %is_in_xmas_group%(String xmas_group) =
    %xmas_group% = xmas_group;
    
table christmas_freedays(Abstime date, String crewid, String crewregion, String season, Int year) =
  season,
  year,
  %_xmas_group%(crewid, season, year),
  crewregion,
  date -> 
    Int %_nbr_of_xmas_freedays%,
    String %_activity_type%;
  external %christmas_freedays_table%;
  "lseason_season",
  "lseason_planyear", 
  "rotation",
  "region", 
  "startdate" -> 
    "nooffreedays",
    "activity";
  -,
  -,
  -,
  -,
  - -> 
    void_int,
    void_string;
end

%christmas_freedays_table% =
  "christmas_freedays";

table christmas_freedays_start(String crewid, String crewregion, String season, Int year, Int match) =
  season,
  year,
  %_xmas_group%(crewid, season, year),
  crewregion,
  match -> 
    Abstime %_start_xmas_date%;
  external %christmas_freedays_table%;
  "lseason_season",
  "lseason_planyear", 
  "rotation",
  "region", 
  "match_number"-> 
    "startdate";
  -,
  -,
  -,
  -,
  - -> 
    void_abstime;
end  

table crew_rotation_table(String crewid, String season, Int year) = 
  crewid,
  season,
  year,
  "christmas" -> 
    String %_xmas_group%;
  external %leave_actual_rotation_table%;
  "crew", 
  "lseason_season",
  "lseason_planyear", 
  "rotationtype" -> 
    "rotation";
  -,
  -, 
  -, 
  - -> 
    "";
end

%leave_actual_rotation_table% = 
    "leave_actual_rotation";
    
table leave_season_table(String season, Int year) = 
  season,
  year -> 
    Abstime %_season_start_date%, 
    Abstime %_season_end_date%;
  external %leave_season_table%;
  "season",
  "planyear" -> 
    "startdate",
    "enddate";
  -, 
  - -> 
    void_abstime,
    void_abstime;
end 

%leave_season_table% = 
    "leave_season";
 
/* refactored to report_common_ccr */
export %r_xmas_group%(String crewid, String season, Abstime year) = 
    %_xmas_group%(crewid, %season%(season), %year%(year));

export %r_season_start_date%(String season, Abstime year) =  
	%_season_start_date%(%season%(season), %year%(year));

export %r_season_end_date%(String season, Abstime year) =  
	%_season_end_date%(%season%(season), %year%(year));
    
export %r_start_xmas_date%(String crewid, String crewregion, String season, Abstime year, Int match) = 
    %_start_xmas_date%(crewid, crewregion, %season%(season), %year%(year), match);    

export %r_nbr_of_xmas_freedays%(Abstime date, String crewid, String crewregion, String season, Abstime year) = 
    %_nbr_of_xmas_freedays%(date, crewid, crewregion, %season%(season), %year%(year));
    
export %r_activity_type%(Abstime date, String crewid, String crewregion, String season, Abstime year) = 
    %_activity_type%(date, crewid, crewregion, %season%(season), %year%(year));

/*
 * Variables to support temporary 2012 vacation rule
 */

table required_number_of_freedays_temp_2012_ft(Abstime start_t, Abstime end_t) =
  start_t,
  crew.%is_fdrc%(start_t), 
  %has_reduced_freeday_requirement_in_month_fc_sh%(start_t) -> int %minimum_number_of_freedays_ft%;
  
  01Feb2012, true,  -     -> 12;
  01Apr2012, true,  -     -> 12;
  &
  -,         -,     true  -> %min_required_in_1_month_by_month_startdate%(start_t, end_t) + 1;
  -,         -,     false -> 13;

end

%minimum_number_of_freedays_pt%(Abstime start_t, Abstime end_t) =
  if (start_t = 01Jan2012) then 
    %min_required_in_1_month_by_month_startdate%(start_t, end_t) + 1
  else 
    %min_required_in_1_month_by_month_startdate%(start_t, end_t);  

table required_number_of_freedays_temp_2012(Abstime start_t, Abstime end_t) =
    start_t,
	crew.%homebase%, 
    crew.%is_part_time_at_date%(start_t) -> int %_minimum_number_of_freedays_2012%;
    
    01May2011, "STO", false -> %minimum_number_of_freedays_ft%(start_t, end_t);
    01May2011, "STO", true  -> %minimum_number_of_freedays_pt%(start_t, end_t);
    &
    01May2011, -,     -     -> 0;
    &
    -,         -,     false -> %minimum_number_of_freedays_ft%(start_t, end_t);
    -,         -,     true  -> %minimum_number_of_freedays_pt%(start_t, end_t);
end

export %minimum_number_of_freedays_2012%(Abstime month_start) =
  let start_t = round_down_month(month_start),
      end_t = round_up_month(start_t + 0:01);

  if %flight_crew% and
     (crew.%homebase% = "CPH" or crew.%homebase% = "STO") and
     %rule_min_freedays_before_2012_holiday_season_fc_cph_sto_on% then
       default(%_minimum_number_of_freedays_2012%(crew.%variable_group_start%(start_t, end_t),
                                                  crew.%variable_group_end%(start_t, end_t)),
               0)
  else
    0;
    
export %rule_min_freedays_before_2012_holiday_season_fc_cph_sto_on% = 
  parameter true
  remark "Use rule min_freedays_before_2012_holiday_season_fc_cph_sto:";

/***************************************************************************
 * F36 entitlement
 ***************************************************************************/

table f36_days(String fgvg, Int factor, String agmt_group) =
    fgvg, factor, agmt_group -> export %entitled_f36_days%;
    -,    60,       -           -> 700;
    -,    75,       -           -> 1000;
    -,    (80, 89), -           -> 1000;
    "VG", 50,       -           -> 500;
    "FG", 50,       -           -> 600;
    "VG", 100,      -           -> 1100;
    "FG", 100,      -           -> 1200;
    "VG", 90,       "SKD_CC_AG"  -> 1100;
    -, -, - -> 0;
end

table crew_agreement_set_table(String agreement) =
  agreement ->
    export Int %crew_agreement_part_time_factor%,
    export String %agreement_desc_short%,
    Int %agreement_freedays_in_month%;
  external model_crew.%crew_contract_set_table%;
   id -> dutypercent, descshort, nooffreedays;
   -  -> void_int, void_string, void_int;
end

table crew_agreement_table(AbsTime lookupfrom, AbsTime lookupto, Int ix) =
  crew.%id%, lookupfrom, lookupto, ix ->
    export String %agreement_ix%,
    export Abstime %agreement_valid_from_ix%,
    export Abstime %agreement_valid_to_ix%;
  external model_crew.%crew_contract_table%;
  crew, <validto, >validfrom, match_number -> contract, validfrom, validto;
   -  ,        -,          -, - -> void_string, void_abstime, void_abstime;
end

export %factored_entitled_f36_days%(AbsTime lookup, Int ix) =
    let lookupfrom = nmax(1mar2013, round_down_year(lookup)),
        lookupto = round_up_year(lookupfrom+0:01),
        agmt_group = crew.%agmt_group_id_at_date%(lookup),
        agreement = %agreement_ix%(lookupfrom, lookupto, ix),
        validfrom = %agreement_valid_from_ix%(lookupfrom, lookupto, ix),
        validto = %agreement_valid_to_ix%(lookupfrom, lookupto, ix),
        contract = crew.%agreement_at_date%(validfrom),
        factor = %agreement_factor_non_summer%(agreement),
        days = (nmin(lookupto, validto) - nmax(validfrom, lookupfrom))/24:00,
        totdays = (lookupto - lookupfrom) / 24:00;

    if not crew.%is_temporary_at_date%(validto-24:00)
       and not(system_db_parameters.%f36_entitlemnts_skd_cc_inshape%(validfrom)
       and (contract ="F00660" or contract ="F00661"))  then
	    if crew.%in_fixed_group%(validto-24:00)  then
	       %entitled_f36_days%("FG", factor, agmt_group) * days / totdays
	    else
	       %entitled_f36_days%("VG", factor, agmt_group) * days / totdays
	else
	  0;

%agreement_factor_non_summer%(String agreement) =
    if substr(%agreement_desc_short%(agreement),1,10) = "100%Summer" then
        %crew_agreement_part_time_factor%(substr(agreement,
                                                 1,length(agreement)-2))
    else
        %crew_agreement_part_time_factor%(agreement);

/* The entitled f36 days are calulated on the assumption that no crew has
 * more than 5 agreements*/
export %entitled_f36_days_of_lookup_year%(AbsTime lookup) =
    sum(times(5), default(%factored_entitled_f36_days%(lookup, %times_index_0%),0));


%entitled_f36_days_of_lookup_year_2013_mod%(AbsTime lookup) =
    if lookup >= 01Jan2013 and lookup < 01Jan2014 then
        (10*%entitled_f36_days_of_lookup_year%(lookup) + 5 )* 5 /(6*10) /* correct rounding */
    else
        %entitled_f36_days_of_lookup_year%(lookup);

export %entitled_f36_days_corr%(AbsTime date) =
    %entitled_f36_days_of_lookup_year_2013_mod%(date) -
    (%f36_table_sum_in_period%(date, "Entitled F36 days") +
     %f36_table_sum_in_period%(date, "Entitled F36 days CORR"));

/***************************************************************************
 * F36 reductions
 ***************************************************************************/

%f36_reductions_days_in_period_2013_mod%(AbsTime ivalstart, Abstime ivalend) =
    %f36_reductions_days_in_period%(nmax(ivalstart, 01Mar2013),ivalend);

%f36_reductions_days_in_period%(AbsTime ivalstart, Abstime ivalend) =
    count(times((ivalend - ivalstart) / 24:00))
    where(%day_has_f36_reduction%(ivalstart + (24:00 * (%times_index_0% - 1))));

%day_has_f36_reduction%(AbsTime day) =
    let validfrom = round_down(day,24:00),
        validto = validfrom + 24:00;
    any(leg(roster), %leg_is_f36_reduction% and leg.%in_period%(validfrom,validto));

export %leg_is_f36_reduction% =
    leg.%is_illness% or
    leg.%is_loa% or
    duty.%is_military% or
    (training.%leg_is_valid_school_activity% and
     training.%leg_is_in_school_period_min_7x24%);

/* The amount which should be reducted from the F36 account.
 * The calculations look like this to get correct rounding of integers.*/
%f36_reduction_amount_in_period%(AbsTime ivalstart, Abstime ivalend) =
    -(%entitled_f36_days_of_lookup_year_2013_mod%(ivalstart) *
    %f36_reductions_days_in_period_2013_mod%(ivalstart, ivalend) *100 /
    %days_in_year_2013_mod%(ivalstart, ivalend) +50) /100;

%days_in_year_2013_mod%(AbsTime ivalstart, Abstime ivalend) =
    (add_years(round_down_year(ivalstart),1) - 
     nmax(round_down_year(ivalstart), 01Mar2013)) / 24:00;

table leave_account_entry_sum_table(Abstime date, String src) =
  crew.%id%, "F36",
  round_down_year(date),
  add_years(round_down_year(date),1),
  src ->
    export Int %f36_table_sum_in_period%;
  external compdays.%leave_account_entry_table%;
  crew, account, <=tim, >tim, source -> sum(amount);
end

%reduction_source%(AbsTime date) =
    format_time(date,"F36 Reductions[%d%b]");

export %f36_reduction_corr_diff%(AbsTime ivalstart, AbsTime ivalend) =
    %f36_reduction_amount_in_period%(ivalstart, ivalend) -
    %f36_table_sum_in_period%(ivalstart, %reduction_source%(ivalstart));

/*
** calculation free day control as in K15 
*/

%chain_has_ac_employer_qa% =
  any(wop(chain), wop.%has_ac_employer_qa%);

export %freedays_reducing_days%(Abstime s, Abstime e) =
  duty.%days_with_selection%(duty.%duty_sel_freedays_disqual%,s,e);

export %freedays_reducing_days_vacation%(Abstime s, Abstime e) =
  duty.%days_with_selection%(duty.%duty_sel_freedays_disqual_vacation%, s, e);

export %freedays_reducing_days_other%(Abstime s, Abstime e) =
  duty.%days_with_selection%(duty.%duty_sel_freedays_disqual_not_vacation%, s, e);
  
/* Number of days from start of freeday year to end of month */
%days_of_year_to_end_of_fdc_month%(abstime s, int month_nr) =
    (add_months(model_freedays.%fdc_start_year_date%(crew.%id%, s), month_nr) 
        -  model_freedays.%fdc_start_year_date%(crew.%id%, s))/24:00;

/* calulcation of year entitlement, month contribution, considering reduction due to VAC etcs
   TODO: remove  */ 
%fdc15_year_entitled_2%(Abstime s, Abstime e, Int year_basic) =
  let ps = round_down_month(s), /* period (month) start */
      pe = round_up_month(e),   /* period (month) end exclusive */
      pl = (pe-ps)/24:00,       /* period (month)length in days */
      m = model_freedays.%fdc_month_nr%(crew.%id%, s),      /* 1-of "fdc year", may be calendar year, vacation year or other */
      days_of_year = %days_of_year_to_end_of_fdc_month%(s, 12); /* get number of days including the leap day*/
  if crew.%is_pilot% and not system_db_parameters.%freedays_fd_cph_vacation_law_valid%(s, crew.%base_at_date%(s)) then 
    /* For FD groups, freedays are calculated with a time factor of 100% for vacation and part time factor for other reducing days*/
       %div_rounds%(((%div_rounds%(year_basic * %days_of_year_to_end_of_fdc_month%(s, m), days_of_year))
                      - %div_rounds%(year_basic * %days_of_year_to_end_of_fdc_month%(s, m-1), days_of_year))
            * (e-s)/24:00, pl)
        - %div_rounds%(model_freedays.%year_ft_entitled_basic%(crew.%id%, s, e) * freedays.%freedays_reducing_days_vacation%(s,e)
                       + year_basic * freedays.%freedays_reducing_days_other%(s,e),
                days_of_year)
  else /* For other groups, part time factor is used in the reduction (e.g 75%) */
       %div_rounds%( ((%div_rounds%(year_basic * %days_of_year_to_end_of_fdc_month%(s, m), days_of_year))
                        - %div_rounds%(year_basic * %days_of_year_to_end_of_fdc_month%(s, m-1), days_of_year))
                     * ((e-s)/24:00 - %freedays_reducing_days%(s,e)), pl);

%fdc15_year_entitled_3%(Abstime s, Abstime e) =
  %_fdc15_year_entitled%(round_down_month(s), round_up_month(e), s, e,
    model_freedays.%year_entitled_basic%(crew.%id%, s, e),
    model_freedays.%fdc_month_nr%(crew.%id%, s));

/* calculation of year entitlement, month contribution, considering reduction etc, and 
   modified by parameter affecting full time freedays entitlement for this month */
export %fdc15_year_target%(Abstime s, Abstime e) =
  let ps = round_down_month(s), /* period (month) start */
      pe = round_up_month(e),   /* period (month) end exclusive */
      m = model_freedays.%fdc_month_nr%(crew.%id%, s);       /* 1-of "fdc year", may be calendar year, vacation year or other */
  %_fdc15_year_entitled%(ps, pe, s, e, model_freedays.%year_entitled_basic%(crew.%id%, s, e), m) * parameters.%fdc15_modif_target%(crew.%rank%)
  /*+ %_fdc15_year_entitled%(ps, pe, s, e, model_freedays.%year_pt_entitled_basic%(crew.%id%, s, e), m) * 100*/;   

/* This function might be changed in the future, freedays ar calculated using parttimed factor, if full time factor should be used? call fdc15_year_entitled instead (it is already calculated there) */
%_fdc15_year_entitled%(Abstime ps, Abstime pe, Abstime s, Abstime e, Int year_basic, Int m) =
 let  pl = (pe-ps)/24:00,       /* period (month)length in days */
      days_of_year = %days_of_year_to_end_of_fdc_month%(s, 12); /* get number of days including the leap day*/
  if crew.%is_pilot% and not system_db_parameters.%freedays_fd_cph_vacation_law_valid%(s, crew.%base_at_date%(s)) then
        /* For FD groups, freedays are calculated with a time factor of 100% for vacation and part time factor for other reducing days*/
      %div_rounds%( ((%div_rounds%(year_basic * %days_of_year_to_end_of_fdc_month%(s, m), days_of_year))
                      - %div_rounds%(year_basic * %days_of_year_to_end_of_fdc_month%(s, m-1), days_of_year))
            * (e-s)/24:00, pl)
        - %div_rounds%(model_freedays.%year_ft_entitled_basic%(crew.%id%, s, e) * freedays.%freedays_reducing_days_vacation%(s,e)
                + year_basic * freedays.%freedays_reducing_days_other%(s,e),
            days_of_year)
   else /* For other groups, part time factor is used in the reduction (e.g 75%) */
       %div_rounds%( ((%div_rounds%(year_basic * %days_of_year_to_end_of_fdc_month%(s, m), days_of_year))
                        - %div_rounds%(year_basic * %days_of_year_to_end_of_fdc_month%(s, m-1), days_of_year))
                     * ((e-s)/24:00 - %freedays_reducing_days%(s,e)), pl);


/* calulcation of 2 month target, month contribution, considering reduction due to VAC etc */
%fdc15_twin_months_entitled%(Abstime s, Abstime e, Int twin_month_basic) =
  let ps = round_down_month(s), /* period (month) start */
      pe = round_up_month(e),   /* period (month) end exclusive */
      pl = (pe-ps)/24:00,       /* period (month)length in days */
      m = model_freedays.%fdc_month_nr%(crew.%id%, s);        /* 1-12, of "fdc year", may be calendar year, vacation year or other */
      ((twin_month_basic + m mod 2)/2 * ((e-s)/24:00-duty.%days_with_selection%(duty.%duty_sel_freedays_disqual%,s,e)) + pl/2) / pl;

/* calculation of min month value considering reduction due to VAC etc */
export %fdc15_month_entitled%(Abstime s, Abstime e, Int month_basic) =
  let ps = round_down_month(s),
      pe = round_up_month(e),
      pl = (pe-ps)/24:00;
      (month_basic * ((e-s)/24:00-duty.%days_with_selection%(duty.%duty_sel_freedays_disqual%,s,e)) + pl/2) / pl;

/* main table to decide type of calculations due to agreement */
table crew_entitled(Abstime s, Abstime e) =
	model_crew.%group_at_date%(crew.%id%, s), crew.%is_cabin%, crew.%flying_qa_ac_employer%(s),
        crew.%agmt_group_inv_enum%(s), crew.%is_temporary_at_date%(s) ->
	  %_crew_fdc15_month_entitled%, 
	  %_crew_fdc15_2_months_entitled%,
          %_crew_fdc15_year_entitled%,
	  %_crew_fdc15_possibly_scheduled%;
	"V", False,  False,   3, - -> /* fd not flying cimber, SH DK */
                                      %fdc15_month_entitled%(s, e, model_freedays.%month_entitled_basic%(crew.%id%, s, e)),
                                      void_int,
	                              %fdc15_year_entitled_2%(s, e, model_freedays.%year_entitled_basic%(crew.%id%, s, e)), 
	                              %days_freedays_possible%(s, e);
        "V", False,  False,  15, - ->  /* fd not flying cimber, LH DK */
                                      %fdc15_month_entitled%(s, e, model_freedays.%month_entitled_basic%(crew.%id%, s, e)),
                                      void_int,
	                              %fdc15_year_entitled_2%(s, e, model_freedays.%year_entitled_basic%(crew.%id%, s, e)), 
	                              %days_freedays_possible%(s, e);
	"V", False,  False,   5, - ->  /* fd not flying cimber, SH SE */
                                      %fdc15_month_entitled%(s, e, model_freedays.%month_entitled_basic%(crew.%id%, s, e)), 
                                      void_int,
	                              %fdc15_year_entitled_2%(s, e, model_freedays.%year_entitled_basic%(crew.%id%, s, e)), 
	                              %days_freedays_possible%(s, e);
	"V", False,  False,  16, - ->  /* fd not flying cimber, LH SE */
                                      %fdc15_month_entitled%(s, e, model_freedays.%month_entitled_basic%(crew.%id%, s, e)), 
                                      void_int,
	                              %fdc15_year_entitled_2%(s, e, model_freedays.%year_entitled_basic%(crew.%id%, s, e)), 
	                              %days_freedays_possible%(s, e);
	"V", False,  False,   7, - ->  /* fd not flying cimber, SH NO */
                                      %fdc15_month_entitled%(s, e, model_freedays.%month_entitled_basic%(crew.%id%, s, e)), 
                                      void_int,
	                              %fdc15_year_entitled_2%(s, e, model_freedays.%year_entitled_basic%(crew.%id%, s, e)), 
	                              %days_freedays_possible%(s, e);
	"V", False,  False,  17, - ->  /* fd not flying cimber, LH NO */
                                      %fdc15_month_entitled%(s, e, model_freedays.%month_entitled_basic%(crew.%id%, s, e)), 
                                      void_int,
	                              %fdc15_year_entitled_2%(s, e, model_freedays.%year_entitled_basic%(crew.%id%, s, e)), 
	                              %days_freedays_possible%(s, e);
	"V", False,  True,    -, - ->  /* fd flying cimber */
                                      %fdc15_month_entitled%(s, e, model_freedays.%month_entitled_basic%(crew.%id%, s, e)), 
                                      %fdc15_twin_months_entitled%(s, e, model_freedays.%fdc15_twin_entitled_basic_qa_by_crew% (crew.%id%, s)), 
	                              %fdc15_year_entitled_2%(s, e, model_freedays.%year_entitled_basic%(crew.%id%, s, e)), 
	                              %days_freedays_possible%(s, e);
	"V", True,   -,   2, False ->  /* cc QA */
                                      %fdc15_month_entitled%(s, e, model_freedays.%month_entitled_basic%(crew.%id%, s, e)), 
                                      %fdc15_twin_months_entitled%(s, e, model_freedays.%fdc15_twin_entitled_basic_qa_by_crew% (crew.%id%, s)),
	                              %fdc15_year_entitled_2%(s, e, model_freedays.%year_entitled_basic%(crew.%id%, s, e)), 
	                              %days_freedays_possible%(s, e);
	"V", True,   -,  11, False ->  /* cc SNK */
                                      %fdc15_month_entitled%(s, e, model_freedays.%month_entitled_basic%(crew.%id%, s, e)), 
                                      void_int,
	                              %fdc15_year_entitled_2%(s, e, model_freedays.%year_entitled_basic%(crew.%id%, s, e)), 
	                              %days_freedays_possible%(s, e);
	"V", True,   -,  10, False ->  /* cc NKF */
                                      %fdc15_month_entitled%(s, e, model_freedays.%month_entitled_basic%(crew.%id%, s, e)), 
                                      void_int,
	                              %fdc15_year_entitled_2%(s, e, model_freedays.%year_entitled_basic%(crew.%id%, s, e)), 
	                              %days_freedays_possible%(s, e);
                                  
	-,   -,      -,       -, - -> 0, void_int, 0, 0;
end


/* scheduled month freeday entitlement, based on part time, and disqualifying activities (illness...) in fdc scope */ 
/* it currently allows for up to 10 contract changes per month */
export %crew_month_possibly_scheduled%(Abstime per_s, Abstime per_e) =
  if model_freedays.%fdc_valid%(crew.%id%, per_s, per_e) then 
    sum(times(model_crew.%crew_chg_agm_max_index%), %_crew_fdc15_possibly_scheduled%(model_crew.%crew_chg_agreement_from%(crew.%id%, %times_index_0%, per_s, per_e),model_crew.%crew_chg_agreement_to%(crew.%id%, %times_index_0%, per_s, per_e))) 
    where (not void(model_crew.%crew_chg_agreement_from%(crew.%id%,%times_index_0%, per_s, per_e)))
  else 0; 

/* minimum month freeday entitlement, based on part time, and disqualifying activities (illness...) in fdc scope */ 
/* it currently allows for up to 10 contract changes per month */
export %crew_month_entitled%(Abstime per_s, Abstime per_e) = 
  if model_freedays.%fdc_valid%(crew.%id%, per_s, per_e) then
    sum(times(model_crew.%crew_chg_agm_max_index%), %_crew_fdc15_month_entitled%(model_crew.%crew_chg_agreement_from%(crew.%id%, %times_index_0%, per_s, per_e),model_crew.%crew_chg_agreement_to%(crew.%id%, %times_index_0%, per_s, per_e))) 
    where (not void(model_crew.%crew_chg_agreement_from%(crew.%id%, %times_index_0%, per_s, per_e)))
  else 0; 

export %crew_month_fdc_days%(Abstime per_s, Abstime per_e) =
  sum(times(model_crew.%crew_chg_agm_max_index%), (model_crew.%crew_chg_agreement_to%(crew.%id%, %times_index_0%, per_s, per_e)-model_crew.%crew_chg_agreement_from%(crew.%id%, %times_index_0%, per_s, per_e))/24:00) 
    where (not void(model_freedays.%crew_fdc15_rule%(crew.%id%,
      model_crew.%crew_chg_agreement_from%(crew.%id%, %times_index_0%, per_s, per_e),
      model_crew.%crew_chg_agreement_to%(crew.%id%, %times_index_0%, per_s, per_e))));


export %crew_month_reducing_fdc_days%(Abstime per_s, Abstime per_e) =
  default(
    sum(times(model_crew.%crew_chg_agm_max_index%), %freedays_reducing_days%(
      model_crew.%crew_chg_agreement_from%(crew.%id%, %times_index_0%, per_s, per_e),
      model_crew.%crew_chg_agreement_to%(crew.%id%, %times_index_0%, per_s, per_e)))
    where (not void(model_freedays.%crew_fdc15_rule%(crew.%id%,
      model_crew.%crew_chg_agreement_from%(crew.%id%, %times_index_0%, per_s, per_e),
      model_crew.%crew_chg_agreement_to%(crew.%id%, %times_index_0%, per_s, per_e)))),
    0);

/* planning month contribution for yearly freeday entitlement, based on part time and disqualifying activitites. Called from accumulators */
export %crew_year_entitled%(Abstime per_s, Abstime per_e) = 
  if model_freedays.%fdc_valid%(crew.%id%, per_s, per_e) then
    sum(times(model_crew.%crew_chg_agm_max_index%), %_crew_fdc15_year_entitled%(model_crew.%crew_chg_agreement_from%(crew.%id%, %times_index_0%, per_s, per_e),model_crew.%crew_chg_agreement_to%(crew.%id%, %times_index_0%, per_s, per_e))) 
    where (not void(model_crew.%crew_chg_agreement_from%(crew.%id%, %times_index_0%, per_s, per_e)))
  else 0; 

export %crew_year_target%(Abstime per_s, Abstime per_e) = 
  if model_freedays.%fdc_valid%(crew.%id%, per_s, per_e) then
    sum(times(model_crew.%crew_chg_agm_max_index%), %fdc15_year_target%(
      model_crew.%crew_chg_agreement_from%(crew.%id%, %times_index_0%, per_s, per_e),
      model_crew.%crew_chg_agreement_to%(crew.%id%, %times_index_0%, per_s, per_e)))
    where (not void(model_crew.%crew_chg_agreement_from%(crew.%id%, %times_index_0%, per_s, per_e)))
  else 0;

 
/* planning month contribution for yearly freeday entitlement for Cimber, based on part time and disqualifying activitites. Called from accumulators */
export %crew_2_months_entitled%(Abstime per_s, Abstime per_e) = 
  if model_freedays.%fdc_valid%(crew.%id%, per_s, per_e) then
    sum(times(model_crew.%crew_chg_agm_max_index%), %_crew_fdc15_2_months_entitled%(model_crew.%crew_chg_agreement_from%(crew.%id%, %times_index_0%, per_s, per_e),model_crew.%crew_chg_agreement_to%(crew.%id%, %times_index_0%, per_s, per_e))) 
    where (not void(model_crew.%crew_chg_agreement_from%(crew.%id%, %times_index_0%, per_s, per_e)))
  else 0;
/*   TODO: remove */
export %acc_fdc15_year_target_per_month%(Abstime month_start) =
  accumulators.%fdc15_nr_acc_entitled_freedays%(month_start); 
  
/* entitlement of fdc15 freedays from years start until end of current month */
export %acc_fdc15_year_entitled_per_month%(Abstime month_start) =
  accumulators.%fdc15_nr_acc_entitled_freedays%(month_start);
 
/* main function, calculated number of fdc15 freedays scheduled or possible to schedule (empty), from year start until end of current month */
export %acc_fdc15_possibly_scheduled%(Abstime month_start) =
  accumulators.%fdc15_nr_acc_possibly_scheduled_freedays%(month_start);

export %acc_fdc15_balance%(Abstime month_start) =
  %acc_fdc15_year_entitled_per_month%(month_start) - %acc_fdc15_possibly_scheduled%(month_start);

export %fdc15_month_margin%(Abstime month_start, Int balance) = 
  model_freedays.%fdc15_months_remaining%(crew.%id%, month_start) * parameters.%fdc15_endyear_margin%;

/*
export %is_last_twin_month%(Abstime month_start) =
  model_freedays.%fdc_month_nr%(month_start) mod 2 = 0;
*/

export %twin_month_fdc15_entitled%(Abstime month_start) =
  if model_freedays.%is_last_twin_month%(month_start) then 
    accumulators.%fdc15_nr_acc_entitled_freedays_qa_2_months%(add_months(month_start,-1), round_up_month(month_start+0:01))
  else 
    accumulators.%fdc15_nr_acc_entitled_freedays_qa_2_months%(month_start,round_up_month(month_start+0:01) );

export %twin_month_fdc15_scheduled%(Abstime month_start) =
  if model_freedays.%is_last_twin_month%(month_start) then
    accumulators.%fdc15_nr_twin_possibly_scheduled_freedays%(add_months(month_start,-1),round_up_month(month_start+0:01))
  else
    accumulators.%fdc15_nr_twin_possibly_scheduled_freedays%(month_start, round_up_month(month_start+0:01));


%_fdc15_sbl_contribution%(Abstime per_s, Abstime per_e) =
  let s = wop.%start_day%,
      e = nmin(per_e, wop.%end_day% + 24:00), /* ignore days in next period */
      ret = (e-s + 24:00)/168:00 + (e-s)/168:00; /* 168 = 7 days. first term 1 for each 6 day, sec for 7 day */
  if s>=per_s then
    ret
  else
    ret - (per_s-s + 24:00)/168:00 - (per_s-s)/168:00; /* subtract contribution before period */

%fdc15_sbl_contribution%(Abstime per_s, Abstime per_e) =
  sum(wop(chain), %_fdc15_sbl_contribution%(per_s, per_e))
  where (wop.%is_standby_line% and wop.%start_day%< per_e and wop.%end_day%>= per_s);

/*export %lw_sbl% =
  %fdc15_sbl_contribution%(round_down_month(leg.%start_hb%),round_up_month(leg.%start_hb%+0:01));
*/

/*** ROTATION VACATION ***/

%_duty_is_or_was_rotationsferie% =
  duty.%is_rotationsferie% or
  %_duty_is_bought_rotationsferie% or
  %_duty_is_privately_traded_rotationsferie%;

%_duty_is_or_was_freeday% =
  duty.%is_freeday% or
  %_duty_is_bought_freeday% or
  %_duty_is_privately_traded_freeday%;

%_duty_is_bought_rotationsferie%  =
  duty.%is_bought% and %_duty_was_rotationsferie_before_bought%;

%_duty_is_privately_traded_rotationsferie% =
  duty.%is_privately_traded% and %_duty_was_rotationsferie_before_privately_traded%;

%_duty_is_bought_freeday% =
  duty.%is_bought% and %_duty_was_freeday_before_bought%;

%_duty_is_privately_traded_freeday% =
  duty.%is_privately_traded% and not %_duty_was_rotationsferie_before_privately_traded% and
                                 not %_duty_was_production_before_privately_traded%;

%_duty_was_rotationsferie_before_bought% =
  default(task.%is_rotationsferie%(bought_days.%type_on_day%(duty.%start_hb%)), false);

%_duty_was_freeday_before_bought% =
  default(task.%is_freeday%(bought_days.%type_on_day%(duty.%start_hb%)), false);

%_duty_was_rotationsferie_before_privately_traded% =
  default(attributes.%is_inner_rotationsferie_before_private_trade_at_date%(duty.%start_hb%), false);

%_duty_was_production_before_privately_traded% =
  default(attributes.%is_production_before_private_trade_at_date%(duty.%start_hb%), false);

%_no_consecutive_rotationsferie_days% =
  %_consecutive_rotationsferie_duties_backward% +
  %_consecutive_rotationsferie_duties_forward%;

%_consecutive_rotationsferie_duties_backward% =
  sum(duty(chain), duty.%days%)
  from (prev) backwards
  while (%_duty_is_or_was_rotationsferie%);

%_consecutive_rotationsferie_duties_forward% =
  sum(duty(chain), duty.%days%)
  from (current) forwards
  while (%_duty_is_or_was_rotationsferie%);

%_rotationsferie_block_start% =
  min(duty(chain), round_down(duty.%start_hb%, 24:00))
  from (current) backwards
  while (%_duty_is_or_was_rotationsferie%);

%_rotationsferie_block_end% =
  max(duty(chain), round_up(duty.%end_hb%, 24:00))
  from (current) forwards
  while (%_duty_is_or_was_rotationsferie%);

%_rotationsferie_start% = %_rotationsferie_block_start% - 2*24:00;
%_rotationsferie_end% = %_rotationsferie_block_end% + 2*24:00;

%_is_immediately_followed_by_min_2_freedays%(Abstime ed) =
  sum   (duty(chain), if duty.%start_day% >= ed and
                         %_duty_is_or_was_freeday% then
                        duty.%days%
                      else
                        0)
  from  (current) forwards
  while (duty.%end_day% < ed + 2*24:00) = 2;

%_is_immediately_preceded_by_min_2_freedays%(Abstime st) =
  sum   (duty(chain), if duty.%end_day% < st and
                         %_duty_is_or_was_freeday% then
                        duty.%days%
                      else
                        0)
  from  (current) backwards
  while (duty.%start_day% >= st - 2*24:00) = 2;

%_is_rotationsferie% =
  default(%_no_consecutive_rotationsferie_days% >= 10 and
          %_rotationsferie_within_main_vacation_window% and
          %_is_immediately_followed_by_min_2_freedays%(%_rotationsferie_block_end%) and
          %_is_immediately_preceded_by_min_2_freedays%(%_rotationsferie_block_start%),
          false);

%_rotationsferie_within_main_vacation_window% =
  %_rotationsferie_start% >= add_months(round_down_year(wop.%start_hb%),5) and
  %_rotationsferie_end% <= add_months(round_down_year(wop.%start_hb%),8);

export %has_rotationsferie_in_roster% = any(wop(roster), first(duty(wop), %_is_rotationsferie%));

export %rotationsferie_start%(AbsTime date, bool forward) =
  if forward
  then first(wop(roster) where (first(duty(wop), %_is_rotationsferie% and %_rotationsferie_start% >= date)),
       first(duty(wop), %_rotationsferie_start%))
  else last(wop(roster) where (first(duty(wop), %_is_rotationsferie% and %_rotationsferie_start% <= date)),
       first(duty(wop), %_rotationsferie_start%));

export %rotationsferie_end%(AbsTime date, bool forward) =
  if forward
  then first(wop(roster) where (first(duty(wop), %_is_rotationsferie% and %_rotationsferie_end% >= date)),
       first(duty(wop), %_rotationsferie_end%))
  else last(wop(roster) where (first(duty(wop), %_is_rotationsferie% and %_rotationsferie_end% <= date)),
       first(duty(wop), %_rotationsferie_end%));

  
/****************************************************
FTE Calculation based on contract, considering contract  changes
and FTE-reducing activities
 ****************************************************/

%fte_contracts_during_month% =
    model_crew.%crew_chg_agreement_count%(crew.%id%, %fte_period_start%, %fte_period_end%);


%fte_contract_start_ix%(int ix) =
    nmax(model_crew.%crew_chg_agm_from%(crew.%id%, ix,
                                        %fte_period_start%, %fte_period_end%),
         %fte_period_start%);
%fte_contract_end_ix%(int ix) =
    nmin(model_crew.%crew_chg_agm_to%(crew.%id%, ix,
                                      %fte_period_start%, %fte_period_end%),
         %fte_period_end%);
%fte_contract_days_ix%(int ix) =
    %days_touched%(%fte_contract_start_ix%(ix), %fte_contract_end_ix%(ix));

/* Contract ix part time factor */
%fte_contract_factor_ix%(int ix) =
    model_crew.%crew_contract_part_time_factor_at_date%(crew.%id%,
                                                        %fte_contract_start_ix%(ix));
%temp_crew_contract_ix% (int ix) =
   model_crew.%is_temporary_at_date%(crew.%id%, %fte_contract_start_ix%(ix));
    
/* The number of FTE reducing days of ILL, LOA and other in the period. */
%fte_contract_reduction_days_ix%(int ix) =
    %fte_reduction_days%(%fte_contract_start_ix%(ix), %fte_contract_end_ix%(ix));

%fte_reduction_days% (Abstime s, Abstime e) =
    duty.%days_with_selection%(duty.%duty_sel_fte_disqual%,s,e);
   

/* For a crew member who does not change contract at all during the month
   the FTE calculation :
        Parttime Factor * (ContractDuration - ReductionDays) / days in month.
   However, the divison with "days in month" is done later.
   Also,40% contract is done as * 40
*/
%fte_contract_calculation_ix%(int ix) =
if  not %temp_crew_contract_ix%(ix)
    then  10 * %fte_contract_factor_ix%(ix) * (%fte_contract_days_ix%(ix) - %fte_contract_reduction_days_ix%(ix))
else 0;

/* For contract changes, the following method is used where,
   the FTE contribution is a sum of each contract period:
        (ParttimeFactor_1 * (ContractDuration_1 - ReductionDays_1)) +
        (ParttimeFactor_2 * (ContractDuration_2 - ReductionDays_2)) +
                            ...
        (ParttimeFactor_n * (ContractDuration_n - ReductionDays_n)) / days in calendar month
*/

/* Resource pool crews (temp crew) FTE contribution is calculated differently
   since their  parttime factor in thecontracts does not reflect how much they work.
   The method used here is:
   Number of days on work / Max number of production days in the contract period
   Full time average of production days for temp crew is 18 days.
*/
%temp_crew_calculation_ix%(int ix) =
let max_p = 16;
if %temp_crew_contract_ix%(ix) 
    then 1000 *(%fte_contract_days_ix%(ix) - %fte_contract_reduction_days_ix%(ix)) / max_p  
else 0;

export %fte_contract_calculation_summed% =  
let days = (%fte_period_end% - %fte_period_start% )/ 24:00;

    default(
        sum(times(%fte_contracts_during_month%), %fte_contract_calculation_ix%(times_index(0))) /days
        , 0) 
        + default(
                  sum(times(%fte_contracts_during_month%), %temp_crew_calculation_ix%(times_index(0))) 
                  ,0);
                        
/* 0.75 FTE is currently expressed as 750 in order to handle decimals better and to account for them when summing up all crew.
   Should be divided by 1000 when all crew is summed */
%fte_period_start% = round_down_month(%pp_start%);
%fte_period_end% = add_months(%fte_period_start%, 1);
/* end of file */

