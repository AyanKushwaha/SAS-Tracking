#########################################
# Copyright Jeppesen Systems AB
"""
DIG handlers for publish interfaces that require reports to be generated
when certain conditions are met in the database.
Examples of such interfaces are:
   40.1 Crew Baggage Reconciliation.
   41.1 Number of Crew to Load Sheet
These two should be triggered at configurable number of minutes before
flight departure.
"""
__docformat__ = 'restructuredtext en'
__metaclass__ = type

# imports ================================================================{{{1
import datetime, time, json, os
from carmensystems.dig.framework import carmentime, utils
from carmensystems.dig.framework.handler import MessageHandlerBase, ExitResult, SpawnChildrenAndCallNextHandlerResult, TextContentType
from carmensystems.dig.framework.dave import DaveSearch, DaveConnector
from carmensystems.dig.framework import errors
from carmensystems.dig.framework import utils
from carmensystems.dig.messagehandlers import reports

# Trigger Handler classes ================================================{{{1

# FlightTimeTrigger ======================================================{{{2
class FlightTimeTrigger(MessageHandlerBase):
    """
    Search for flights in the database that are scheduled to depart/arrive
    within a configurable number of minutes. For each flight that meets the
    criteria, a new message is created containing an order to the next handler
    in the call chain to generate a report for that flight.
    The report request message is generated by a separate class specified in
    the outputClass parameter.
    The handler is typically called by a scheduler driven dig channel to
    cyclically check if trigger criteria is fulfilled.

    It stores the flight keys for reported flights as its own state in order to
    avoid sending the same request more than once. 

    Parameters

      minutesBefore
        Trigger criteria for generating report.
        Flights at least this close to departure/arrival will be reported on.
        Multiple trigger criteria may be specified by giving a comma separated
        list of values. E.g. "180,60" means that reports will be generated 180
        and 60 minutes before departure/arrival.

        Note that in some cases it could be meaningful to set a negative 
        minutesBefore. One such use case would be to catch events like
        actual arrival. Another case would be to trigger an action to 
        take place some time after e.g. scheduled departure. In the latter
        case the minutesDeparture setting must be combined with the offset
        parameter (see below).

      offset (minutes)
        This parameter can optionally be used to limit the search window in
        which flights are visible to the trigger.

         |------------------|<------------------------->|
        now               offset     search window      minutesBefore
        
        The default offset is 0 meaning the search window stretches from
        now until minutesBefore.

        A negative minutesBefore can be combined with a negative offset
        in order to e.g. trigger 'minutesBefore' minutes after scheduled
        departure as illustrated below:

                 |<---------------------->|----------------|
             offset   search window    minutesBefore       now

      isDeparture
        If 'True', then trigger 'minutesBefore' minutes before time of
        departure; if 'False', then trigger on time of arrival instead. This
        parameter is optional, the default value is True.

      destCountry
        This optional parameter allows specifying a country code, e.g. "US".
        If specified, only flights with this destination country are accounted
        for.  Note that even though both destCountry and depCountry are 
        optional, one of them must be specified.
      
      depCountry
        This optional parameter allows specifying a country code, e.g. "US".
        If specified, only flights with this departure country are accounted
        for. If both destCountry and depCountry are specified, flights
        matching destCountry OR depCountry are accounted for.

      includeDomestic
        If 'False', then flights having adep and ades in the same country
        are excluded. Default 'True'.
      
      outputClass
        Full name of a class that generates handler output, i.e input to the
        next handler in the call chain which should be a report handler.  The
        class must implement a method that generates a message based on a
        flight record:
            (content, contentType, metadata) makeReportRequest(flight)
        The outputClass parameter is optional. If ommitted, the input message
        content is used as report request.
      
      onlyOperatedBySAS
        If 'True', only flights where aco = "SK" will be included. This will affect 
        41.1   Number of Crew to Load Sheet (See SASCMS-6314 for more info)
    """

    def __init__(self, minutesBefore=None, offset="0", isDeparture="True", configFile=None,
            outputClass=None, destCountry=None, depCountry=None, includeDomestic="True", name=None, onlyOperatedBySAS="False"):
        super(FlightTimeTrigger, self).__init__(name)
        self._minutesBefore = minutesBefore
        self._offset = datetime.timedelta(seconds=float(offset) * 60)
        self._isDeparture = utils.convertToBoolean(isDeparture)
        self._destCountry = destCountry
        self._depCountry = depCountry
        self._includeDomestic = utils.convertToBoolean(includeDomestic)
        self._onlyOperatedBySAS = onlyOperatedBySAS
        if outputClass:
            try:
                self._outputClass = utils.getClass(outputClass)
            except:
                raise errors.ChannelConfigError("Cannot find class %s" % outputClass)
        else:
            self._outputClass = None

        # The default value for expiry is 4 hours but if the minutesBefore is more than
        # that there will be gap so flights will be resent even though it is not necessary.
        # Increase the expiry to include 30 minutes more than minutesBefore.
        self._reportedFlightsExpiry = datetime.timedelta(seconds=3600*4)
        
        if minutesBefore is not None:

            maxMinutesBefore = int(max(minutesBefore.split(','), key=lambda x: int(x)))

            if maxMinutesBefore > 210:
                self._reportedFlightsExpiry = datetime.timedelta(seconds=60*(maxMinutesBefore+30))
                     
                    
        self._reportedFlights = {}
        self._airportTable = {}
        self._airportToCountry = {}
        self._config = None
        if configFile:
            self._destCountry = None
            self._depCountry = None
            self._config = json.load(file(configFile))
        elif minutesBefore is None:
            raise errors.ChannelConfigError("Either configFile or minutesBefore must be set")

        #elif destCountry is None:
        #    raise errors.ChannelConfigError("Either configFile or destCountry must be set")
        self._dep_arr = ('arrival', 'departure')[bool(self._isDeparture)]

    def start(self, services):
        super(FlightTimeTrigger, self).start(services)
        # We use state to track what flights we have sent reports on.
        state = self._services.getStates()[-1]
        for key, value in state.items():
            values = value.split(',')
            key = (int(values[0]), values[1], values[2], values[3])
            dateWithoutMillisec = values[4].split('.')[0]
            self._reportedFlights[key] = utils.convertFromIsodate(dateWithoutMillisec)
        self._services.logger.debug("Loaded %d reported flights" % len(state))
        if self._config:
            self._services.logger.debug("Current config: %r" % self._config)
            
            
        self._services.logger.debug("Reported flights expiry: %s" % self._reportedFlightsExpiry)

    def handle(self, message):
        outputList = []
        destCountries = []
        if self._config:
            destCountries = self._config.keys()
        elif self._destCountry:
            destCountries = [ self._destCountry ]

        for destCountry in destCountries:
            fileName = None
            validFrom = None
            exception = None
            if self._config:
                minutesBefores = self._config[destCountry].get("minutesBefore",None)
                exception = self._config[destCountry].get("exception",None)
                if isinstance(minutesBefores, str) or isinstance(minutesBefores, unicode):
                    minutesBefores = minutesBefores.split(',')
                fileName = self._config[destCountry].get("fileName",None)

                validFrom = self._config[destCountry].get("validFrom",None)
                if validFrom:
                    validFrom = datetime.datetime.strptime(validFrom, '%d%b%Y %H:%M')
                self._services.logger.debug("UH---DEST:" + destCountry)
                self._services.logger.debug("UH---VALIDFROM:" + str(validFrom))
            else:
                minutesBefores = self._minutesBefore.split(',')
            if not minutesBefores:
                self._services.logger.debug("minutesBefore not set for %s, skipping" % destCountry)
                continue
            depCountry = None
            if destCountry and self._config and self._config[destCountry].get("departure",True):
                depCountry = destCountry
            if self._outputClass:
                outputter = self._outputClass(destCountry, self._services.logger, fileName=fileName)
            # Handle the different time windows one by one...
            self._services.logger.debug("Start search for flights to %s, %s minutes before %s" % (
                    destCountry, minutesBefores, self._dep_arr))
            if self._onlyOperatedBySAS == "True":
                self._services.logger.debug("Only search for flights operated by SAS")

            if destCountry and destCountry == "*": destCountry = None
            if depCountry and depCountry == "*": depCountry = None
            for mbd in minutesBefores:
                minutesBefore = datetime.timedelta(seconds=float(mbd) * 60)
                # Setup a Dave search in flight_leg.
                # We load all the flights, then we filter away those we have 
                # already reported, and those not matching the destination
                # country (if specified).
                now = self._services.now() 
                minuteMargin = datetime.timedelta(seconds=60)
                fromTime = now + min(self._offset, minutesBefore)
                if validFrom:
                    fromTime = max(fromTime, validFrom)
                toTime = now + max(self._offset, minutesBefore) + minuteMargin
                self._services.logger.debug("Searching interval %s - %s" % (fromTime, toTime))
    
                ctFromTime = carmentime.toCarmenTime(fromTime)
                ctToTime = carmentime.toCarmenTime(toTime)
    
                flights = self._filterFlights(self._getFlights(ctFromTime, ctToTime, destCountry), mbd, depCountry, destCountry, fromTime, toTime, exceptionHandle=exception)
                if flights:
                    self._addToReportedFlights(flights, mbd)
                    # Prepare report requests
                    for f in flights:
                        if self._outputClass:
                            outputList.append(outputter.makeReportRequest(f))
                        else:
                            outputList.append((message.content, message.contentType, None))
                        self._services.logger.info("Report requested for udor %s, fd %s, adep %s (%s minutes before %s)" % (
                            self._makeFlightKey(f, mbd) + (self._dep_arr,)))
                        if self._isDeparture:
                            if f['aobt']:
                                self._services.logger.debug("aobt=%s" % (carmentime.fromCarmenTime(f['aobt'])))
                            if f['eobt']:
                                self._services.logger.debug("eobt=%s" % (carmentime.fromCarmenTime(f['eobt'])))
                            if f['sobt']:
                                self._services.logger.debug("sobt=%s" % (carmentime.fromCarmenTime(f['sobt'])))
                        else:
                            if f['aibt']:
                                self._services.logger.debug("aibt=%s" % (carmentime.fromCarmenTime(f['aibt'])))
                            if f['eibt']:
                                self._services.logger.debug("eibt=%s" % (carmentime.fromCarmenTime(f['eibt'])))
                            if f['sibt']:
                                self._services.logger.debug("sibt=%s" % (carmentime.fromCarmenTime(f['sibt'])))

        if outputList:
            # We always write the state
            message.addState(self, self._saveState(), alwaysWrite=True)
            return SpawnChildrenAndCallNextHandlerResult(outputList)
        self._services.logger.info("No flights to report this time for %s..." % ','.join(destCountries or ""))
        return ExitResult()

    def _saveState(self):
        stateDict = {}
        now = self._services.now()
        for i, (flightKey, reportedTime) in enumerate(self._reportedFlights.items()):
            # We only save flights reported within the last 4 hours.
            # This means flights that have been delayed for more than 4 hours
            # (eobt/eibt updated since first reported), may be reported again...
            if now - reportedTime < self._reportedFlightsExpiry:
                stateDict['reportedFlight-%d' % i ] = "%s,%s,%s,%s,%s" % (flightKey + (reportedTime.isoformat(),))
        return stateDict

    def _exceptionHandler(self, destCountry, exceptionHandle, flightFromCtry, flightToCtry):
        destEqFr = destCountry == flightFromCtry
        destEqTo = destCountry == flightToCtry
        fromInHandleSplit = flightFromCtry in exceptionHandle.split(',')
        toInHandleSplit = flightToCtry in exceptionHandle.split(',')
        if (destEqFr and destEqTo) or (destEqFr and toInHandleSplit) or (destEqTo and fromInHandleSplit):
            return True
        else:
            return False

    def _filterFlights(self, flights, mbd, destCountry, depCountry, fromTime, toTime, exceptionHandle=None):
        # Remove any flights already reported for the given trigger criteria.
        # If destCountry or depCountry is specified, also remove flights with 
        # other dest/departure country.
        # if onlyOperatedBySAS is specified, also remove flights with other employer, flight_leg.aco != "SK"
        result = []
        now = self._services.now()
        skip1 = 0
        skip2 = 0
        skip3 = 0
        skip4 = 0
        skip5 = 0
        for f in flights:
            if destCountry or depCountry:
                if not self._matchesDepartureOrDestinationCountries(f, destCountry, depCountry):
                    skip1 += 1
                    continue
            # Exclude domestic flights, if configured to do so
            if not self._includeDomestic:
                if self._countryForAirport(f['adep']) == self._countryForAirport(f['ades']):
                    self._services.logger.debug("Excluded domestic flight: udor %s, fd %s, adep %s" % (f['udor'], f['fd'], f['adep']))
                    skip2 += 1
                    continue
            if self._reportedFlightsContains(f, mbd):
                self._services.logger.debug("Already reported flight: udor %s, fd %s, adep %s (%s minutes before %s)" % (
                    self._makeFlightKey(f,mbd) + (self._dep_arr,)))
                skip3 += 1
                continue
            if self._onlyOperatedBySAS == "True":
                if ((not f['aco'] == "SK") and (not f['aco'] == "SVS")):
                    self._services.logger.debug("Excluded flight not operated by SAS: aco %s, fd %sss, adep %s" % (f['aco'], f['fd'], f['adep']))
                    skip4 += 1
                    continue
            if exceptionHandle:
                fr_ctry = self._countryForAirport(f['adep'])
                to_ctry = self._countryForAirport(f['ades'])
                if self._exceptionHandler(destCountry, exceptionHandle, fr_ctry, to_ctry):
                    self._services.logger.debug("Excluded flight DK<->Schengen: aco %s, fd %sss, adep %s" % (f['aco'], f['fd'], f['adep']))
                    skip5 += 1
                    continue

            result.append(f)
        self._services.logger.info("Count %d, skip1(%s,%s) = %d, skip2 = %d, skip3 = %d, skip4 = %d skip5 = %d" % (len(result), destCountry, depCountry, skip1, skip2, skip3, skip4, skip5))
        return result

    def _getFlights(self, fromTime, toTime, destCountry=None):
        """Search primarily for estimated time (ETD), if not available use
        scheduled time (STD)."""
        # Use off-block time if departure, in-block time if arrival.
        est_time = ('eibt', 'eobt')[bool(self._isDeparture)]
        sched_time = ('sibt', 'sobt')[bool(self._isDeparture)]

        eSearch = DaveSearch('flight_leg', [
                (est_time, '>', '%d' % fromTime),
                (est_time, '<', '%d' % toTime),
                ('statcode', '!=', 'C'), # SKCMS-1869: We are not interested in Cancelled flight
            ])
        flights = self._services.getDaveConnector().runSearch(eSearch)

        sSearch = DaveSearch('flight_leg', [
                (sched_time, '>', '%d' % fromTime),
                (sched_time, '<', '%d' % toTime),
                "%s is null" % est_time,
                ('statcode', '!=', 'C'), # SKCMS-1869: We are not interested in Cancelled flight
            ])
        flights.extend(self._services.getDaveConnector().runSearch(sSearch))
        return flights

    def _matchesDepartureOrDestinationCountries(self, flight, destCountry, depCountry):
        for country, airportAttr in ((str(destCountry), 'ades'), (str(depCountry), 'adep')):
            if country and country == self._countryForAirport( flight[airportAttr] ):
                return True
        return False

    def _countryForAirport(self, airport):
        return self._airportTable.setdefault(airport, self._lookupAirportCountry(airport))

    def _reportedFlightsContains(self, flight, mbd):
        return self._makeFlightKey(flight, mbd) in self._reportedFlights

    def _addToReportedFlights(self, flights, mbd):
        # We save the flight key and the time we reported it
        now = self._services.now()
        self._reportedFlights.update(dict([(self._makeFlightKey(f,mbd), now) for f in flights]))

    def _makeFlightKey(self, flight, mbd):
        # Construct a flight key from scheduled departure date of origin, flight designator,
        # airport of departure and the trigger criteria (minutes before departure/arrival).
        return (flight['udor'], flight['fd'], flight['adep'], mbd)
 
    def _lookupAirportCountry(self, airport):
        if not self._airportToCountry:
            self._airportToCountry = self._loadAirportToCountry()
        country = self._airportToCountry.get(airport, None)
        if not country:
            self._services.logger.error("Could not find airport '%s' in airport table." % airport)
        return country

    def _loadAirportToCountry(self):
        search = DaveSearch('airport', {})
        searchResult = self._services.getDaveConnector().runSearch(search)
        return dict(((ap['id'], ap['country']) for ap in searchResult))


# FlightDepartureTrigger ================================================={{{2
class FlightDepartureTrigger(FlightTimeTrigger):
    """Trigger n minutes before departure."""
    pass


# FlightArrivalTrigger ==================================================={{{2
class FlightArrivalTrigger(FlightTimeTrigger):
    """Trigger n minutes before arrival."""
    def __init__(self, minutesBefore=None, offset="0", outputClass=None, configFile=None,
            destCountry=None, depCountry=None, name=None):
        super(FlightArrivalTrigger, self).__init__(minutesBefore,
                offset, isDeparture="False", outputClass=outputClass, configFile=configFile,
                destCountry=destCountry, depCountry=depCountry, name=name)


# FlightScheduledTimeTrigger ============================================={{{2
class FlightScheduledTimeTrigger(FlightTimeTrigger):
    """Trigger n minutes before scheduled departure."""
    def _getFlights(self, fromTime, toTime, destCountry=None):
        """Use scheduled time (STD)."""
        # Use off-block time if departure, in-block time if arrival.
        sched_time = ('sibt', 'sobt')[bool(self._isDeparture)]
        sSearch = DaveSearch('flight_leg', [
                (sched_time, '>', '%d' % fromTime),
                (sched_time, '<', '%d' % toTime),
            ])
        return self._services.getDaveConnector().runSearch(sSearch)


# FlightActualTimeTrigger ================================================{{{2
class FlightActualTimeTrigger(FlightTimeTrigger):
    """Trigger at actual departure. Note cannot use minutes before here."""
    def __init__(self, minutesBefore=None, offset="0", isDeparture="True", configFile=None,
            outputClass=None, destCountry=None, depCountry=None, name=None):
        if minutesBefore:
            for mbd in minutesBefore.split(','):
                if float(mbd) > 0:
                    raise errors.ChannelConfigError("Configuration error. Can't look into the future.")
        super(self.__class__, self).__init__(minutesBefore, offset, configFile=configFile,
                isDeparture=isDeparture, outputClass=outputClass,
                destCountry=destCountry, depCountry=depCountry, name=name)

    def _getFlights(self, fromTime, toTime, destCountry=None):
        """Use actual time (ATD)."""
        # Use off-block time if departure, in-block time if arrival.
        act_time = ('aibt', 'aobt')[bool(self._isDeparture)]
        sSearch = DaveSearch('flight_leg', [
                (act_time, '>', '%d' % fromTime),
                (act_time, '<', '%d' % toTime),
            ])
        return self._services.getDaveConnector().runSearch(sSearch)



# FlightFlyoverScheduledTimeTrigger ============================================={{{2

def from_CT(ct):
    """Takes an int (which represente Carmen Time (minutes))
    Returns datetime.datetime"""
    return carmentime.fromCarmenTime(ct)

def to_CT(DT):
    """Takes a Python datetime.datetime.
    Returns an int"""
    return carmentime.toCarmenTime(DT)


class FlightFlyoverScheduledTimeTrigger(FlightTimeTrigger):

    def _inFlyoverTable(self, flight, foTable, fromTime, toTime):
        dep = self._countryForAirport(flight['adep'])
        dest = self._countryForAirport(flight['ades'])
        ctFromTime = to_CT(fromTime)
        ctToTime = to_CT(toTime)
        for fo in foTable:
            for a, b in [(dep, dest), (dest, dep)]:
                if (a == fo['country_a']) and (b == fo['country_b']):
                    if ctFromTime >= fo["validfrom"]:
                        vt = fo["validto"]
                        if not (vt or vt == 0) or ctToTime <= vt:
                            return True
        return False


    """Trigger n minutes before scheduled departure for flights flying over specified countries."""
    def _getFlights(self, fromTime, toTime, destCountry=None):
        """Use scheduled time (STD)."""
        # Use off-block time if departure, in-block time if arrival.
        sched_time = ('sibt', 'sobt')[bool(self._isDeparture)]
        sSearch = DaveSearch('flight_leg', [
                (sched_time, '>', '%d' % fromTime),
                (sched_time, '<', '%d' % toTime),
            ])
        return self._services.getDaveConnector().runSearch(sSearch)


    def _filterFlights(self, flights, mbd, destCountry, depCountry, fromTime, toTime, exceptionHandle=None):
        foSearch = DaveSearch('flyover', [
                ('flyover', '=', destCountry),
            ])
        foTable = self._services.getDaveConnector().runSearch(foSearch)

        self._services.logger.debug("List of countries where %s is overflown:" % destCountry)
        for fo in foTable:
            self._services.logger.debug("%s <-> %s" % (fo['country_a'], fo['country_b']))

        # Remove any flights already reported for the given trigger criteria.
        # If destCountry or depCountry is specified, also remove flights with 
        # other dest/departure country.
        # if onlyOperatedBySAS is specified, also remove flights with other employer, flight_leg.aco != "SK"
        result = []
        now = self._services.now()
        skip1 = 0
        skip2 = 0
        skip3 = 0
        skip4 = 0
        for f in flights:
            if not self._inFlyoverTable(f, foTable, fromTime, toTime):
                skip1 += 1
#                self._services.logger.debug("Excluded non-flyover %s flight: udor %s, fd %s, dep %s, des %s" % (destCountry, f['udor'], f['fd'], self._countryForAirport(f['adep']), self._countryForAirport(f['ades'])))
                continue
            # Exclude domestic flights, if configured to do so
            if not self._includeDomestic:
                if self._countryForAirport(f['adep']) == self._countryForAirport(f['ades']):
                    self._services.logger.debug("Excluded domestic flight: udor %s, fd %s, adep %s" % (f['udor'], f['fd'], f['adep']))
                    skip2 += 1
                    continue
            if self._reportedFlightsContains(f, mbd):
                self._services.logger.debug("Already reported flight: udor %s, fd %s, adep %s (%s minutes before %s)" % (
                    self._makeFlightKey(f,mbd) + (self._dep_arr,)))
                skip3 += 1
                continue
            if self._onlyOperatedBySAS == "True":
                if ((not f['aco'] == "SK") and (not f['aco'] == "SVS")):
                    self._services.logger.debug("Excluded flight not operated by SAS: aco %s, fd %sss, adep %s" % (f['aco'], f['fd'], f['adep']))
                    skip4 += 1
                    continue
                
            result.append(f)
        self._services.logger.info("Count %d, skip1(%s,%s) = %d, skip2 = %d, skip3 = %d, skip4 = %d" % (len(result), destCountry, depCountry, skip1, skip2, skip3, skip4))
        return result


class FlightFlyoverActualTimeTrigger(FlightFlyoverScheduledTimeTrigger):

    def _getFlights(self, fromTime, toTime, destCountry=None):
        """This method is called in handle, and the result is passed to _filterFlights.
            That means that the flyover-filter in this classes parent-class will be applied to and changed flights found.
        """
        # Russia is to receive reports at ATOT whether changes or not
        if destCountry == "RU":
            return super(FlightFlyoverActualTimeTrigger, self)._getFlights(fromTime, toTime, destCountry)

        self._minutesBefore = str(fromTime)

        start_CT = fromTime
        now_CT = carmentime.toCarmenTime(self._services.now())
        dave_connector = self._services.getDaveConnector()

        flights = flights_with_changed_crew(start_CT, now_CT, dave_connector)

        self._services.logger.info('Changed flights:')
        for f in flights:
            self._services.logger.info('Flight changed %s' % f)

        return flights



def flights_with_changed_crew(crewchange_minutes_before_limit, now_carmentime, dave_connector, ATOT_minutes_after_limit=2*60, search_minutes_before=24*60):
    """Finds flight where crew hav changed between scheduled report and ATOT.

    Return list of dictionaries (in "flight_leg-format"). This list will
    contain flights that have been "changed" within
    "minutes_before" from "now_time", and
    ATOT if ATOT is found for a flight within ATOT_time_limit else SOBT.

    :param now_carmentime: The current time.  Can be anything, especially for testing.
    :type CarmenTime
    :param crewchange_minutes_before_limit:
    How far before SOBT the schedule report should have been sent.
    This value should come from the triggers' config-file
    and be the same as when a scheduled report is to be sent.
    :type int
    :param dave_connector: for running the SQL query
    :type DaveConnector
    :param ATOT_minutes_after_limit: (default '2*60')
    ATOT is guaranteed to be within this far after SOBT
    :type int
    :param search_minutes_before: how far back from now to look at flights with flight SOBT
     - in case of system inaccuracy and/or downtime.
    :type int
    """

    # We have to use Level-1 connection for this query.
    espec = dave_connector.getConnection().getEntitySpec("flight_leg")

    # Get columns in 'flight_leg'.
    columns = []
    for ix in xrange(espec.getColumnCount()):
        columns.append(espec.getColumnByNum(ix).getName())

    late_crew_query = (
        "SELECT "
            "dr.committs as dr_committs, %(columns)s "
        "FROM "
            "flight_leg fl  "
        "INNER JOIN "
            "crew_flight_duty cfd "
        "ON "
            "fl.fd = cfd.leg_fd AND "
            "fl.udor = cfd.leg_udor AND "
            "fl.adep = cfd.leg_adep "
        "INNER JOIN "
            "dave_revision dr "
        "ON "
            "cfd.revid = dr.revid "
        "WHERE "
            # 1. Locate any flight with SOBT within the given search-window
            "fl.sobt > %(search_start_CT)d AND fl.sobt <= %(search_end_CT)d "
            # 2. See if ATOT is set, or if it has gone more than two hours (ATOT should have been set!)
            "AND (fl.atot IS NOT NULL OR fl.sobt + %(ATOT_minutes_after_limit)d < %(now_CT)d) "
            # 3.   Look for changes:
            # 3.1. There is a commit time-stamp within the change-frame
            "AND dr.committs/60 BETWEEN fl.sobt-%(crewchange_minutes_before_limit)d AND %(now_CT)d "
            # 3.2. There is no "next_revid", signifying this is the last change
            "AND fl.next_revid = 0 "
        "ORDER BY "
            "dr.committs DESC "
    ) % dict(
        crewchange_minutes_before_limit=crewchange_minutes_before_limit,
        ATOT_minutes_after_limit=ATOT_minutes_after_limit,
        search_start_CT=now_carmentime - search_minutes_before - ATOT_minutes_after_limit,
        search_end_CT=now_carmentime - ATOT_minutes_after_limit,
        now_CT=now_carmentime,
        columns=(", ".join(["fl.%s" % col for col in columns]))
    )

#    self._services.logger.info(carmlog.Msg(descr='%s' % late_crew_query))

    reported = set()
    flights = []

    for f in level_1_query(dave_connector, late_crew_query, ["dr_committs"] + columns):
        # flights will arrive with max "committs" first, throw away the other rows.
        if not (f['fd'], f['udor'], f['adep']) in reported:
            flights.append(f)
        reported.add((f['fd'], f['udor'], f['adep']))


    return flights





# BaggagePickUpTrigger ==================================================={{{2
class BaggagePickUpTrigger(FlightScheduledTimeTrigger):
    """Trigger n minutes before scheduled departure and if there has been any
    late crew change, add those flights as well.

          | A   |B   |C    
          |-------------------| SK 345 |

    At we will create a report at time point A (e.g. 240 minutes before flight)
    If we have a late crew change at time B, we will send the report again
    at time C. It will trigger on any type of crew change or publishing of
    a crew change.

    This trigger was created for the interface PCI (crew baggage) but could be
    used for other purposes as well.
    """

    def handle(self, message):
        self._destCountry = "*"
        return FlightScheduledTimeTrigger.handle(self, message)

    @staticmethod  # Made static to allow use from other class.  'self' must be passed in explicitly
    def _get_changed_flights(self, toTime):
        """ Return list of dictionaries (in "flight_leg-format"). This list will
            contain of flights that have been changed (committed) within
            "minutesBefore" from now, for flights that will depart within
            "minutesBefore".

        """
        # NOTE: This class will not work well with multiple 'minutesbefore' - block it.
        if len(self._minutesBefore.split(',')) > 1:
            raise errors.ChannelConfigError(("Configuration error. "
                "Cannot use multiple values of 'minutesBefore' with %s.") % self.__class__.__name__)

        # We have to use Level-1 connection for this query.
        dc = self._services.getDaveConnector()
        espec = dc.getConnection().getEntitySpec('flight_leg')

        # Get columns in 'flight_leg'.
        columns = []
        for ix in xrange(espec.getColumnCount()):
            columns.append(espec.getColumnByNum(ix).getName())

        now = carmentime.toCarmenTime(self._services.now())

        # When updating a crew, the crew_flight_duty table is updated
        # and the published_roster table. If do no publish is set for the 
        # crew that table is also updated, the pusblished_roster entry points
        # at an old commit id.
        # Publishing a new roster will change the pusblished_roster table.
        # This query consists of two parts:
        # 1. Flights changed and published within the six hour period
        # 2. Flights changed earlier with a 'do not publish' tag, where
        # the 'do not publish' is removed within the 6h period 
        late_crew_query = (
            "SELECT "
                "cfd.revid as cfd_revid, %s "          # list of columns in flight_leg
            "FROM "
                "flight_leg fl, "
                "crew_flight_duty cfd, "
                "dave_revision dr "
            "WHERE "
                "fl.next_revid = 0 AND "
                "fl.deleted = 'N' AND "
                "fl.sobt < %d AND "       # starting before 'toTime', the other ones will be picked up later
                "fl.sobt > %d AND "       # don't look at old flights
                "cfd.next_revid = 0 AND " # if crew_flight_duty has been deleted, that's also ok
                "cfd.leg_fd = fl.fd AND "
                "cfd.leg_udor = fl.udor AND "
                "cfd.leg_adep = fl.adep AND "
                "cfd.revid = dr.revid AND "
                "dr.committs / 60 >= fl.sobt - %d AND " # committed after 'minutesBefore' for flight.
                "dr.commitid <= ("        # and published...
                    "SELECT MAX(pubcid) "
                    "FROM published_roster pub "
                    "WHERE pub.next_revid = 0 AND "
                    "pub.deleted = 'N' AND "
                    "pub.crew = cfd.crew AND "
                    "pub.pubtype = 'PUBLISHED' AND "
                    "pub.pubstart <= fl.sobt AND "
                    "pub.pubend > fl.sobt"
                ") " 
            "UNION "
            "SELECT "                     # Select legs that are changed earlier with 'do not publish'
                "cfd.revid as cfd_revid, %s "
            "FROM "
                "flight_leg fl, "
                "crew_flight_duty cfd, "
                "dave_revision dr, "
                "do_not_publish dnp "
            "WHERE " 
                "fl.next_revid = 0 AND "
                "fl.deleted = 'N' AND "       # legs are removed from 'do not publish'
                "fl.sobt < %d AND "
                "fl.sobt > %d AND "
                "cfd.next_revid = 0 AND "
                "cfd.leg_fd = fl.fd AND "
                "cfd.leg_udor = fl.udor AND "
                "cfd.leg_adep = fl.adep AND "
                "dnp.next_revid = 0 AND "
                "dnp.revid = dr.revid AND "
                "dnp.deleted = 'Y' AND "
                "dnp.start_time <= fl.sobt AND "
                "dnp.end_time >= fl.sobt AND "
                "dnp.crew = cfd.crew AND "
                "dr.committs / 60 >= fl.sobt - %d "
            "ORDER BY fd, udor, adep, cfd_revid "
            "DESC"
        ) % (', '.join(['fl.%s' % col for col in columns]), # list of columns
                toTime, now, toTime - now,
             ', '.join(['fl.%s' % col for col in columns]), # list of columns, 2nd table in union
             toTime, now, toTime - now)

        reported = set()
        flights = []
                
        # Note the trick with 'cfd_revid', push that column first
        self._services.logger.info('%s' % late_crew_query)

        for f in level_1_query(dc, late_crew_query, ['cfd_revid'] + columns):
            # flights will arrive with max revid first, throw away the
            # other rows.
            if not (f['fd'], f['udor'], f['adep']) in reported:
                flights.append(f)
            reported.add((f['fd'], f['udor'], f['adep']))

        self._services.logger.info('Changed flights:')
        for f in flights:
            self._services.logger.info('Flight changed %s' % f)
        
        return flights

    def _getFlights(self, fromTime, toTime, destCountry=None):
        """Extend "normal scheduled time" (STD) search with "late crew changes"
        search."""
        f = FlightScheduledTimeTrigger._getFlights(self, fromTime, toTime, destCountry)
        # extend list of found flights with flights with late crew changes.
        c = self._get_changed_flights(self,toTime) 
        return f + c

    def _makeFlightKey(self, flight, mbd):
        # Construct a flight key from scheduled departure date of origin, flight designator,
        # airport of departure and the trigger criteria (minutes before departure/arrival).
        if 'pub_revid' in flight:
            # Don't save as a number, we could have revid = 240
            last_key = "R:%s" % flight['pub_revid']
        else:
            last_key = mbd
            
        return (flight['udor'], flight['fd'], flight['adep'], last_key)
 

# Request Builder classes ================================================{{{1

# CrewBaggageRequestBuilder =============================================={{{2
class CrewBaggageRequestBuilder:
    """
    Generates report request string for interface
    40.1 Crew Baggage Reconciliation
    """

    def __init__(self, destCountry=None, logger=None, fileName=None):
        self.__logger = logger

    def makeReportRequest(self, flight):
        # Prepare request for the report handler
        reportArgs = {
            'fd': flight['fd'],
            'udor': carmentime.fromCarmenTime(flight['udor']*1440).strftime("%Y%m%d"),
            'adep': flight['adep'],
        }
        request = reports.ReportRequest('report_sources.report_server.rs_crewbaggage', reportArgs, delta=True)
        
        return (request, reports.ReportRequestContentType(), None)


# LoadSheetRequestBuilder ==============================================={{{2
class LoadSheetRequestBuilder:
    """
    Generates report request string for interface
    41.1 Number of Crew to Load Sheet
    """

    def __init__(self, destCountry=None, logger=None, fileName=None):
        self.__logger = logger

    def makeReportRequest(self, flight):
        # Prepare request for the report handler
        reportArgs = {
            'flightId': flight['fd'],
            'originDate': carmentime.fromCarmenTime(flight['udor']*1440).strftime("%Y%m%d"),
            'adep': flight['adep'],
        }
        # Only make the request if the flight is operated by SAS
        
        request = reports.ReportRequest('report_sources.report_server.rs_loadsheet', reportArgs, delta=False)
        return (request, reports.ReportRequestContentType(), None)


# CrewManifestRequestBuilder ============================================{{{2
class CrewManifestRequestBuilder:
    """
    Generates report request string for interface
    33.8 Crew Manifest US
    33.9 Crew Manifest CN (EDIFACT version only)
    CR12 Crew Manifest JP
    CR26 Crew Manifest TH
    CR164 Crew Manifest IN
    """

    def __init__(self, destCountry=None, logger=None,
            report='report_sources.report_server.rs_crew_manifest', fileName=None):
        self.__destCountry = destCountry
        self.__logger = logger
        self.__report = report
        self.__fileName = fileName

    def makeReportRequest(self, flight):
        # Prepare request for the new report handler

        origsuffix = flight['origsuffix']
        if origsuffix is None:
            origsuffix = ''

        reportArgs = {
            'fd': flight['fd'],
            'origsuffix': origsuffix,
            'udor': carmentime.fromCarmenTime(flight['udor']*1440).strftime("%Y%m%d"),
            'adep': flight['adep'],
            'country': self.__destCountry,
            'fileName': self.__fileName,
        }
        request = reports.ReportRequest(self.__report, reportArgs, delta=True)
        
        return (request, reports.ReportRequestContentType(), None)


# CrewManifestRequestBuilderPDF ========================================={{{2
class CrewManifestRequestBuilderPDF(CrewManifestRequestBuilder):
    """
    33.9 Crew Manifest CN (PDF version only)
    """
    def __init__(self, destCountry=None, logger=None, fileName=None):
        CrewManifestRequestBuilder.__init__(self, destCountry=destCountry,
                logger=logger,
                report='report_sources.report_server.rs_crew_manifest_pdf')

# CrewManifestRequestBuilderMail ========================================={{{2
class CrewManifestRequestBuilderMail:
    """
    Generates report request string for interface
    SKCMS-2938 Crew Manifest CA
    """

    def __init__(self, destCountry=None, logger=None,
            report='report_sources.report_server.rs_crew_manifestMail', fileName=None):
        self.__destCountry = destCountry
        self.__logger = logger
        self.__report = report
        self.__fileName = fileName

    def makeReportRequest(self, flight):
        # Prepare request for the new report handler

        origsuffix = flight['origsuffix']
        if origsuffix is None:
            origsuffix = ''

        reportArgs = {
            'fd': flight['fd'],
            'origsuffix': origsuffix,
            'udor': carmentime.fromCarmenTime(flight['udor']*1440).strftime("%Y%m%d"),
            'adep': flight['adep'],
            'country': self.__destCountry,
            'fileName': "API_for_flight_"  + flight['fd'].replace(" ", "_") + carmentime.fromCarmenTime(flight['udor']*1440).strftime("%d%b").upper() + "_" + flight['adep'] + flight['ades'] + "_" + carmentime.fromCarmenTime(flight['udor']*1440).strftime("%Y%m%d"),
        }
        request = reports.ReportRequest(self.__report, reportArgs, delta=True)

        return (request, reports.ReportRequestContentType(), None)

# CrewManifestRequestBuilderForArr  ============================================{{{2
class CrewManifestRequestBuilderForArr:
    """
    Generates report request string for arrival flights for a country 
    Crew Manifest IE
    """

    def __init__(self, destCountry=None, logger=None,
            report='report_sources.report_server.rs_crew_manifest', fileName=None):
        self.__destCountry = destCountry
        self.__logger = logger
        self.__report = report
        self.__fileName = fileName
      

    def makeReportRequest(self, flight):
        # Prepare request for the new report handler
        schema =os.environ['DB_SCHEMA']
        url =os.environ['DB_URL']
        dc = DaveConnector(url, schema)
        list_country = []
        origsuffix = flight['origsuffix']
        if origsuffix is None:
            origsuffix = ''
        
        flt = str(flight['adep'])
        for entry in dbsearch(dc, 'airport', ' AND '.join((
               "id = '%s'" % flt,
               "deleted = 'N'",
               "next_revid = 0",
           ))):
           list_country.append(entry['country'])
        
        if self.__destCountry not in list_country:       
            reportArgs = {
                'fd': flight['fd'],
                'origsuffix': origsuffix,
                'udor': carmentime.fromCarmenTime(flight['udor']*1440).strftime("%Y%m%d"),
                'adep': flight['adep'],
                'country': self.__destCountry,
                'fileName': self.__fileName,
            }
        else:
            self.__report = 'report_sources.report_server.rs_crew_manifest_nonarr'
            reportArgs = {
                'fd': flight['fd'],
                'origsuffix': origsuffix,
                'udor': carmentime.fromCarmenTime(flight['udor']*1440).strftime("%Y%m%d"),
                'adep': flight['adep'],
                'country': self.__destCountry,
                'fileName': "_API_for_flight_"  + flight['fd'].replace(" ", "_") + "_" + flight['adep'] + flight['ades'] + "_",
        }
        request = reports.ReportRequest(self.__report, reportArgs, delta=True)
        return (request, reports.ReportRequestContentType(), None)         
      

# functions =============================================================={{{1

# level_1_query ----------------------------------------------------------{{{2
def level_1_query(dc, query, columns):
    """Generator - return dictionary per iteration. 'columns' is a list of
    column names."""
    l1conn = dc.getL1Connection()
    l1conn.rquery(query, None)
    R = l1conn.readRow()
    while R:
        # Create dictionary, colname=value
        d = dict(zip(columns, R.valuesAsList()))
        # Remove 'branchid' (why ??, DIG does this, but is it necessary??)
        d.pop('branchid', None)
        yield d
        R = l1conn.readRow()
    l1conn.endQuery()

def dbsearch(dc, entity, expr=[], withDeleted=False):
        """Search entity and return list of DCRecord objects."""
        if isinstance(expr, str):
            expr = [expr]
        return list(dc.runSearch(DaveSearch(entity, expr, withDeleted)))


# modeline ==============================================================={{{1
# vim: set fdm=marker fdl=0:
# eof
