"""
 $Header$
 
 Various utilities for use in reports.
  
 Created:    April 2007
 By:         Erik Gustafsson, Jeppesen Systems AB

"""
# Imports
import os
import time
import RelTime
import copy
import carmensystems.rave.api as R

def set_pp_para(new_para, start=True):
    if start:
        R.param('fundamental.%start_para%').setvalue(new_para)
    else:
        R.param('fundamental.%end_para%').setvalue(new_para)

class PPModifier:
    def __init__(self, new_start_para, new_end_para):
        self.start_para,self.end_para = R.eval(
            'fundamental.%start_para%',
            'fundamental.%end_para%',
            )
        set_pp_para(new_start_para)
        set_pp_para(new_end_para, False)
        print "ReportUtils::PPModifier: Planning period set to %s %s" %(
            new_start_para, new_end_para)
        
    def __del__(self):
        set_pp_para(self.start_para)
        set_pp_para(self.end_para, False)
        print "ReportUtils::PPModifier: Planning period reset to %s %s" %(
            self.start_para, self.end_para)

class OutputReport:
    """
    A class for output reports (csv format).
    """
    def __init__(self, reportName, SASReportObject, rows):
        """
        Creates a text file with a name generated by the report name with spaces
        removed, and with an added time stamp.
        It then adds some planning data and the supplied rows, after which it
        closes the file and returns a string with the path to the file.
        """
        # Create the csv file
        fileName = reportName.replace(" ","")
        ts = time.localtime()

        try:
            # When invoked from launcher, Rave is not there...
            comment, = R.eval("crg_comment")
        except:
            comment = ''
        time_string = "%i%02i%02i_%02i%02i_%02i" %(ts[0],ts[1],ts[2],ts[3],ts[4],ts[5])
        if comment:
            file_name = fileName+"_"+comment+"_"+time_string+".csv"
        else:
            file_name = fileName+"_"+time_string+".csv"
        
        csvPath = os.getenv("HOME")+"/"+file_name
        csvFile = open(csvPath, "w")
        csvFile.write(reportName + "\n")

        # Gathers plan data and writes it to file
        (planningPeriod, ruleSet, plan, planning_area) = SASReportObject.getPlanningDataItems()
        csvFile.write("Period;")
        csvFile.write(planningPeriod + "\n")
        csvFile.write("Rule Set;" + ruleSet + "\n")
        csvFile.write("Plan;" + plan+"\n")
        csvFile.write("Planning area;" + planning_area+"\n")
        self.csvPath = csvPath

        # Writes the data rows to file
        for row in rows:
            csvFile.write(row + "\n")
        csvFile.close()

    def getPath(self):
        """
        Returns the path of the generated csv file.
        """
        return self.csvPath

    def getInfo(self):
        """
        Returns info on the path of the generated csv file.
        """
        return "The output data is saved in %s" %self.csvPath


class DataCollection:
    """
    A class that holds calendar data for one category, with unknown sub-keys.

    Can be used in reports of distribution-type.
    """
    # Class variables

    # A list (iterable) with the dates that the collection holds data for.
    dates = None
    datesAndWeekdays = None
    
    # The key of the category that is considered to be the sum category.
    sumCategory = None

    # Supported types
    # If more non-native types are added the derefValue function
    # should be extended
    relTimeVal = RelTime.RelTime(0,0)
    intVal = 0
    floatVal = 0.0
    relTimeType = type(relTimeVal)
    intType = type(intVal)
    floatType = type(floatVal)
    knownTypes = {relTimeType : relTimeVal, intType : 0, floatType: 0.0}

    def derefValue(self, value):
        """
        A method that interprets the type of value and
        if necessary creates and returns a new value depending
        on if value has a recognized pointer type or not
        """
        if type(value) <> self.intType and type(value) <> self.floatType:
            # Assume RelTime
            (h, m) = value.split()
            return RelTime.RelTime(h, m)
        else:
            return value
        
    def __init__(self, category, dates=None, sumCategory=None):
        """
        Sets the category and initializes the data structure.

        If keyword arguments 'dates' or 'sumCategory' is supplied we
        use them instead of the class variables with the same name.
        """

        # If we're supplied with parameters we use them for object variables,
        # otherwise we use the class variables. If the class variables are None
        # we raise an exception.
        if (dates is None):
            if (DataCollection.dates is None):
                raise Exception("Class variable 'dates' hasn't been set")
            else:
                dates = DataCollection.dates
        self.dates = dates
        
        if (sumCategory is None):
            if (DataCollection.sumCategory is None):
                raise Exception("Class variable 'sumCategory' hasn't been set")
            else:
                sumCategory = DataCollection.sumCategory
        self.sumCategory = sumCategory

        self.category = category
        self.data = dict()
        self.keyTypes = dict()
        
    def initDateAndWeekdays(self):
        print "init dateAndWeekdays"
        self.datesAndWeekdays = {'Mon':[], 'Tue':[], 'Wed':[], 'Thu':[],
                                 'Fri':[], 'Sat':[], 'Sun':[]}
        print self.dates
        for date in self.dates:
            weekday, = R.eval('crg_date.%%print_weekday%%(%s)' % date)
            print date, weekday
            self.datesAndWeekdays[weekday].append(date)

        
    def get(self, key, date, type="NA"):
        """
        Get a value, None if it's not initialized.
        """
        if ((key in self.data) and (date in self.data[key])):
            return self.data[key][date]
        else:
            keyType = self.keyTypes.get(key, None)
            if not keyType:
                # The type of the key is unknown
                # For display purposes we can use the "type" parameter
                # to return a value instead of "None".
                if type == "int":
                    return 0
                elif type == "float":
                    return 0.0
                elif type == "rel":
                    return RelTime.RelTime(0,0)
                else:
                    return None
            else:
                # Return the default value of the type
                return self.knownTypes[keyType]

    
    def add(self, key, date, value):
        """
        Increase a value with a specific amount.
        """
        if not key in self.data:
            self.data[key] = dict()
            self.keyTypes[key] = type(value)
            self.data[key][date] = value
        else:
            self.data[key][date] = self.get(key, date) + value

    def inc(self, key, date):
        """
        A shortcut function to increase a value with one unit.
        """
        self.add(key, date, 1)
        
    def dec(self, key, date):
        """
        A shortcut function to decrease a value with one unit.
        """
        self.add(key, date, -1)

    def keys(self):
        """
        Returns the keys currently in the data collection.
        """
        return self.data.keys()

    def addDataCollection(self, dt):
        """
        Add the values from another data collection.

        Raises exception if performed on a collection with a category that is not
        the sum category or if the collection to add isn't the same class.
        """
        if (self.__class__ != dt.__class__):
            raise Exception("Can only add an object of the same class")
        if (self.category != self.sumCategory):
            raise Exception("Only valid for %s (category is %s)"
                            %(self.sumCategory, self.category))
        for key in self.data:
            if key in dt.keys():
                for date in self.dates:
                    dt_val = self.derefValue(dt.get(key, date))
                    self.add(key, date, dt_val)
        for key in dt.keys():
            if key not in self.data:
                for date in self.dates:
                    # dt.get(...) returns a pointer, we need to dereference somehow
                    dt_val = self.derefValue(dt.get(key, date))
                    self.add(key, date, dt_val)

    def getSum(self, key, fromDate = None, toDate = None):
        """
        Calculates the sum over dates for key
        """
        # Init dates
        if not fromDate: fromDate = self.dates[0]
        if not toDate: toDate = self.dates[-1]
                
        # Init s to the correct type using the first date. Assume the type is known
        s = self.derefValue(self.get(key, fromDate))

        # Add all other dates
        for date in self.dates[
            self.dates.index(fromDate) + 1 : self.dates.index(toDate) + 1
            ]:
            s = s + self.get(key, date)
        return s

    def getWeekdaySum(self, key, weekday):
        """
        Calculates the sum for a weekday for the specified key
        """
        # Calculate the weekdays for the dates if not yet done
        if not self.datesAndWeekdays: self.initDateAndWeekdays()

        # Init s to the correct type using the first date. Assume the type is known
        s = self.derefValue(self.get(key, self.datesAndWeekdays[weekday][0]))
        s = s - s
        
        # Iterate over the dates that are on the same weekday
        for date in self.datesAndWeekdays[weekday]:
            s = s + self.get(key, date)
        return s
        
    def getAverage(self, key, fromDate = None, toDate = None, isDated = True):
        """
        Calculates the average over all dates for key
        If isDates is false the assumption is that the averages is over
        one week, i.e. divisor = 7
        """
        # Init dates
        if not fromDate: fromDate = self.dates[0]
        if not toDate: toDate = self.dates[-1]
        # Use float conversion to get decimals if the sum
        # is of integer type
        if isDated:
            l = float((toDate - fromDate) / RelTime.RelTime(24, 0)) + 1
        else:
            l = 7.0
        return self.getSum(key, fromDate, toDate) / l

    def getWeekdayAverage(self, key):
        """
        Calculates the average over all weekdays for key
        """
        # Calculate the weekdays for the dates if not yet done
        if not self.datesAndWeekdays: self.initDateAndWeekdays()

        # Init s to the correct type using the first date. Assume the type is known
        s = self.derefValue(self.get(key, self.datesAndWeekdays[0][0]))
        s = s - s
        
        # Use float conversion to get decimals if the sum
        # is of integer type
        l = float(len(self.datesAndWeekdays))
        for (weekday, x) in self.datesAndWeekdays:
            s = s + self.getWeekdaySum(key, weekday)
        return s / l
            
def sumDataCollections(sumCategory, data):
    """
    Adds the values from all categories in the data and creates a data
    collection with the total sum.
    """
    sum = DataCollection(sumCategory)
    for category in data:
        sum.addDataCollection(data[category])
    data[sumCategory] = sum

# End of file
