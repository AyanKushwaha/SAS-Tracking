"""
Block Time Balance Report
------------------------------------------

This is a base report used to implement the block_hour_report.
The report is grouped by base and rank.

@date: 22Feb2016
@author: Fredrik Sjunnesson
@org: Jeppesen Systems AB


<rst only="default_jcr" suffix="#object_reports#">

.. index::
   single: Report; Block time balance

.. _block_time_balance.py:

Block Time Balance
-------------------

This report displays how many block hours that have been assigned to specific crew members, sorted by their fairness group.
In addition, three limits connected to block time is visualized in the graph. Assigned block hours are shown as green bars (clickable) and the limits as
colored lines:

    * Black (Monthly averaged yearly limit)
          The annual block time limit divided by 12.

    * Red (Monthly limit from the Annual Block Hours)
          Limit from the rule Annual Block Hours, derived from historical block time, yearly limit and how
          many months there are in until the end of the year.

    * Blue (Fairness target)
          The block time target generated by the Fairness package.


The report is grouped by rank and base (fairness groups) to simplify the block time analysis. The group name is
clickable and will display the crew members that have been processed by the report for that specific fairness group.
The selection in the left crew margin decides the input to the report, meaning that the report can be run for both a
small selection of crew or the whole plan.


**Available Actions**

    * | By clicking on a bar in the histogram, the correspondent roster will be displayed in a separate Studio.

    * | By clicking on the name of a fairness group, all rosters that has been processed by the report and belongs to
        the specific fairness group will be displayed in a separate
        studio window.

**Access in Studio**

    * | Crew -> Generate Report(Object)... -> fairness_details.py
        - This will generate and display the report for *one or more currently selected* crew members.



**File Locations (Python)**

    ``lib/python/report_sources/include/block_time_balance.py``

    ``lib/python/report_sources/crew_margin_window_object/block_time_balance.py``

</rst>

"""

import carmensystems.publisher.api as prt
import carmensystems.rave.api as rave
import Gui
import Cui
from carmstd import area
from carmstd import select
from Localization import MSGR
from report_sources.include.studiopalette import studio_palette as sp
from report_sources.include.roster_report import RosterReport
import Localization as L


MAX_CREW_COUNT_WITH_X_LABELS = 70
CHART_WIDTH = 700
CHART_HEIGHT = 300


class Report(RosterReport):

    def create(self):
        self.setpaper(orientation=prt.LANDSCAPE, size=prt.A4)

        super(Report, self).create()
        if not self.bag:
            return

        self.max_work_per_year = self.get_year_limit()
        self.days_left_in_year_at_pp_start = float(rave.eval('rules_indust_ccr.%days_left_in_year_at_pp_start%')[0])
        self.days_in_pp = float(rave.eval('fundamental.%nr_days_in_pp%')[0])

        group_data = []
        sort_by = "fairness.%fairness_crew_group%"

        for base_rank_bag in self.bag.fairness.crew_fairness_group_set(sort_by=sort_by):
            base = base_rank_bag.crew.homebase_pp_start()
            rank = base_rank_bag.crew.rank()
            group = base_rank_bag.fairness.fairness_crew_group()

            # Prune data for groups that might exist in plan, but not in report period
            if base_rank_bag.rules_indust_ccr.any_crew_available_for_block_time_report(base, rank):
                base_rank_data = BalanceData(group)
                self._get_roster_data(base_rank_bag, base_rank_data)
                group_data.append(base_rank_data)

        self._create_report_body(group_data)

    def _get_roster_data(self, roster_bag, bd):
        """
        Fill data structure with target, planned work, remaining work and monthly limit (pro rated)
        taken denotes days where a crew already has registered a duty
        """

        for roster in roster_bag.iterators.roster_set():
            bd.roster_items.append(
                RosterData(roster.crew.id(),
                           float(self.get_target_work_for_roster(roster)),
                           float(self.get_planned_work_for_roster(roster)),
                           float(self.get_annual_block_hours_limit(roster))))

    def _create_report_body(self, group_data):
        """
        Create the report.
        """
        for crew_group_data in group_data:
            group = crew_group_data.group
            self._create_chart(crew_group_data, group)
            self.newpage()

    def _create_chart(self, crew_group_data, group):
        leg_in_rtd_color = sp.Leg_in_RTD
        max_per_year_color = sp.Black
        remaining_work_time_color = sp.BrightRed
        target_color = sp.DarkBlue

        max_per_year_value = self.max_work_per_year / 12.0

        #pp_fraction_year = min(1.0, self.days_in_pp / self.days_left_in_year_at_pp_start)

        planned_work_data = []
        target_work_data = []
        max_per_year_data = []
        block_hours_left_data = []
        crew_x_pos = []
        for roster_data in sorted(crew_group_data.roster_items, key=lambda item: item.planned_work):
            crew_id = roster_data.crew_id
            crew_x_pos.append(crew_id)
            planned_work_data.append((crew_id, roster_data.planned_work / 60.0))
            target_work_data.append((crew_id, roster_data.target_work / 60.0))
            max_per_year_data.append((crew_id, max_per_year_value / 60.0))
            block_hours_left_data.append((crew_id, roster_data.annual_block_hours_limit / 60.0))

        crew_count = len(planned_work_data)

        clear_label = lambda x: ""
        use_label = lambda x: x
        xaxis_format_func = use_label if crew_count < MAX_CREW_COUNT_WITH_X_LABELS else clear_label

        def create_line(data, label, color):
            g = prt.Line(colour=color) if crew_count > 2 else prt.Limit(linewidth=1, colour=color)
            return prt.Series(data, label=label, graph=g)

        limit_bars_comb = prt.Combine(
            prt.Series(planned_work_data,
                       label="Assigned Block Hours",
                       graph=prt.Bar(fill=leg_in_rtd_color),
                       action=prt.chartaction(lambda x, _: self.filter_obj(self.current_area, x)),
                       tooltip=prt.charttooltip(lambda x, y: "Crew id: %s" % (x, ))),
            create_line(block_hours_left_data, "Monthly Limit From Annual Block Hours", remaining_work_time_color),
            create_line(max_per_year_data, "Monthly Averaged Yearly Limit", max_per_year_color),
            create_line(target_work_data, "Fairness Target", target_color),
            on_top=False,
            yaxis_name='Block Hours')

        padding = prt.padding(left=35)
        font = prt.font(size=8)

        frac_of_max = min(1.0, float(crew_count) / float(20))
        chart_width = max(150, float(CHART_WIDTH) * frac_of_max)

        xaxis_name = 'Crew id' if crew_count < MAX_CREW_COUNT_WITH_X_LABELS else 'Crew'

        chart = prt.Chart(chart_width,
                          CHART_HEIGHT,
                          limit_bars_comb,
                          padding=padding,
                          font=font,
                          xaxis_rotate_tags=True,
                          xaxis_format=xaxis_format_func,
                          xaxis_name=xaxis_name)

        row = prt.Row(chart)
        self.add(prt.Text(group + " (%d crew)" % crew_count,
                          action=prt.action(self.filter_fairness_group, (group, ))))
        self.add(row)

    def get_year_limit(self):
        return float(rave.eval('rules_indust_ccr.%max_block_time_in_calendar_year_int%')[0])

    def get_header_text(self):
        return L.MSGR('Block Time Balance Report')

    def get_target_work_for_roster(self, roster):
        try:
            value = roster.fairness.target("BLOCK TIME", "") or 0
        except:
            value = 0
        return value

    def get_planned_work_for_roster(self, roster):
        return roster.rules_indust_ccr.pp_block_time_int()

    def get_annual_block_hours_limit(self, roster):
        return roster.rules_indust_ccr.max_block_time_annual_in_pp_int()

    @staticmethod
    def filter_obj(current_area, crew_id):

        filter_area = area.get_opposite_area(current_area)

        Cui.CuiExecuteFunction('PythonEvalExpr("0")',
                               MSGR("Block time balance filtering"),
                               Gui.POT_REDO,
                               Gui.OPA_OPAQUE)

        select.display_given_objects([crew_id],
                                     filter_area,
                                     Cui.CrewMode,
                                     Cui.CrewMode)

    @staticmethod
    def filter_fairness_group(fairness_group):

        crew_filter1 = {
            'FORM': 'blockTimeBalanceReport',
            'DEFAULT': ''}
        crew_filter2 = {
            'FORM': 'blockTimeBalanceReport',
            'FL_TIME_BASE': 'RDOP',
            'FILTER_PRINCIP': 'ANY',
            'FILTER_METHOD': 'REPLACE',
            'FILTER_MARK': 'NONE',
            'CRC_VARIABLE_0': 'fairness.%fairness_crew_main_func%',
            'CRC_VALUE_0': '%s' % fairness_group,
            'CRC_VARIABLE_1': 'marked_crew',
            'CRC_VALUE_1': 'TRUE',
            'OK': ''}

        try:
            cmd = '''PythonEvalExpr("Cui.CuiFilterObjects(%s,%s,Cui.gpc_info,%s,'CrewFilter','%s',0)")''' \
                  % (crew_filter1, crew_filter2, Cui.CuiArea1, crew_filter2["FORM"])

            Cui.CuiExecuteFunction(cmd,
                                   "blockTimeBalanceReport",
                                   Gui.POT_REDO,
                                   Gui.OPA_OPAQUE)
        except KeyboardInterrupt:
            return None
        except:
            pass


class BalanceData(object):
    """
    Represents all forecast balance data (crew counts, pre-assignments, etc.)
    for a given crew group e.g. CP-GOT
    """

    def __init__(self, group):
        self.roster_items = []
        self.group = group


class RosterData(object):

    def __init__(self, crew_id, target_work, planned_work, annual_block_hours_limit):
        self.crew_id = crew_id
        self.target_work = target_work
        self.planned_work = planned_work
        self.annual_block_hours_limit = annual_block_hours_limit
